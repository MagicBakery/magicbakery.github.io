<!DOCTYPE html>
<html>
<head>
	<link rel="manifest" href="/mt_manifest.json">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
	<title>Magic Theater</title>
	<meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
	<meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">
	<link rel="icon" type="image/png" href="https://magicbakery.github.io/images/Star.png">
	<meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="/icons/star_192.png">
	<script>
		const APP_VERSION = "20260207024000"; //#Version
		const APP_ANNOUNCEMENT = "20260207: Goto another card."
	</script>
	<style>
		:root {
			--bg: #000;
			--panel: rgba(15, 15, 15, 0.5);
			--border: rgba(255, 255, 255, 0.1);
			--accent: #fff;
			--text: #fff;
			--text-dim: #CCC;
			--grid-cols: 3;
			--sidebar-w: 300px;
			--gold: #ffd700;
			--h-dir: row;
			--green: #4CAF50;
		}

		* {
			box-sizing: border-box;
		}

		/* Target normal, visited, and active states */
		a,
		a:active,
		a:hover,
		a:visited {
			color: inherit;
			text-decoration: none;
		}

		/* Only triggers when running as an installed Windows app */
		@media (display-mode: standalone) {
			body {
				/* Adds a little breathing room at the top for the window controls */
				padding-top: env(safe-area-inset-top);
			}
		}


		html,
		body {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
		}

		/* Ensure the tagging mode is clear but doesn't break pill visibility */
		body.tag-assign-active {
			/* Optional: subtle cursor change for the whole app */
			cursor: crosshair;
		}

		input {
			padding: 8px;
			border-radius: 4px;
			border: 1px solid #444;
			background: #2222;
			color: #fff;
			width: 100%;
			font-family: monospace;
		}

		/* The Green Tint Highlight */
		.already-has-tag {
			background-color: rgba(0, 255, 0, 0.2) !important;
			/* Green tint */
			outline: 2px solid var(--green) !important;
			box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
			transition: background-color 0.2s;
		}

		/* Visual indicator for "Already Tagged" items */
		.already-has-tag::before {
			content: "✅";
			position: absolute;
			top: 2px;
			right: 5px;
			color: var(--green);
			font-weight: bold;
			z-index: 10;
		}

		.modal-overlay {
			position: fixed;
			inset: 0;
			background: rgba(0, 0, 0, 0.7);
			backdrop-filter: blur(10px);
			display: flex;
			align-items: center;
			justify-content: center;
			z-index: var(--z-Notifications);
		}

		.modal-content {
			background: #222;
			padding: 20px;
			border-radius: 15px;
			border: 1px solid var(--gold);
			text-align: center;
		}

		.modal-btns button {
			padding: 10px 25px;
			border-radius: 8px;
			border: none !important;
			cursor: pointer;
			font-weight: bold;
			transition: all 0.3s ease;
			/* Smooth color switching */
			filter: grayscale(0);
			opacity: 1;
		}

		.confirm-yes {
			background-color: var(--green);
			color: white;
		}

		.confirm-no {
			background-color: #444;
			color: #ccc;
		}

		.confirm-no:hover {
			background-color: #cc0000;
			color: white;
		}

		#custom-confirm:has(.confirm-no:hover) .confirm-yes {
			background-color: #444;
			color: #888;
			filter: grayscale(1);
			opacity: 0.6;
		}


		.choice-bubble {
			position: fixed;
			width: 50px;
			height: 50px;
			background: rgba(255, 255, 255, 0.05);
			backdrop-filter: blur(1px);
			border: 3px solid rgba(255, 255, 255, 0.1);
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			cursor: pointer;
			transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
			z-index: var(--z-SpeechBubble);
			box-shadow: 0 0 15px rgba(255, 255, 255, 0.05);
			animation: floatSpore 6s infinite ease-in-out;
		}

		/* Hover state: It glows and expands slightly */
		.choice-bubble:hover {
			background: rgba(255, 255, 255, 0.5);
			border-color: rgba(255, 255, 255, 0.6);
		}

		/* When it's been "seen" but not chosen, we change the color */
		.choice-bubble.opened {
			background: rgba(100, 150, 255, 0.2);
			/* Soft Blue/Purple hint */
			border-color: rgba(100, 150, 255, 0.4);
		}

		@keyframes floatSpore {

			0%,
			100% {
				transform: translateY(0) scale(1);
			}

			33% {
				transform: translateY(-15px) scale(1.5);
			}

			66% {
				transform: translateY(5px) scale(0.75);
			}
		}

		#choice-container {
			display: none;
			/* Change from flex to block */
			width: 100%;
			max-height: 100%;
			/* Vertical limit */
			overflow-y: auto;
			/* Force vertical scroll */
			overflow-x: hidden;
			/* Kill horizontal scroll */
			margin-top: 10px;
			/*padding-right: 10px;*/
			/* Space for the scrollbar */
		}
		#choice-container.active{
			display:block;
		}

		/* Chrome/Safari Scrollbar styling */
		#choice-container::-webkit-scrollbar {
			width: 2px;
		}

		#choice-container::-webkit-scrollbar-thumb {
			background: var(--gold);
			border-radius: 10px;
		}

		.choice-entry {
			display: block;
			/* Each entry is a full-width block */
			width: 100%;
			/* Fill the container */
			margin-bottom: 12px;
			/* Vertical spacing between items */
			background: rgba(255, 255, 255, 0.08);
			border: 1px solid rgba(255, 255, 255, 0.2);
			border-radius: 50px;
			padding: 15px;
			cursor: pointer;
			position: relative;
			/* For positioning internal buttons */
			font-size: 18px;
			text-align: center;
		}

		.choice-entry.selected {
			border: 2px solid var(--gold);
			background: rgba(255, 215, 0, 0.1);
		}

		.choice-actions {
			display: flex;
			gap: 10px;
		}

		.confirm-btn,
		.dismiss-btn {
			background: none;
			border: 1px solid rgba(255, 255, 255, 0.3);
			color: white;
			border-radius: 4px;
			padding: 4px 8px;
			cursor: pointer;
		}

		.confirm-btn:hover {
			background: var(--green);
		}

		.dismiss-btn:hover {
			background: #d9534f;
		}

		.speech-bubble {
			position: relative;
			z-index: 1;
			padding: 25px 25px;
			/* Give it padding so the text doesn't touch the edges */
			flex-direction: column;
			gap: 20px;
			background: rgba(255, 255, 255, 0.5);
			opacity: 1;
			background: transparent;
			width: auto;
			min-width: 100px;
			max-width: 800px;
			pointer-events: auto;
		}

		.speech-bubble.narrative-mode {
			width: 100vw;
			max-width: 100vw;
			border-radius: 0;
			background: rgba(0, 0, 0, 0.75);
			/* Cinematic dark bar */
			backdrop-filter: blur(10px);
			color: white;
			padding: 30px 10% 30px 10%;
			/* More breathing room for wide text */
			border-left: none;
			border-right: none;
			border-top: 1px solid rgba(255, 255, 255, 0.2);
			border-bottom: 1px solid rgba(255, 255, 255, 0.2);
		}
		.speech-bubble.narrative-mode:has(#choice-container.active){
			padding: 30px 10% 40px 10%;
		}

		.speech-bubble::before {
			content: '';
			position: absolute;
			/* MUST HAVE THESE to show up */
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			min-width: 0px;
			max-width: 100%;

			background: rgba(255, 255, 255, 0.3);
			backdrop-filter: blur(15px);
			border-radius: 50px;
			z-index: -1;
			border: 3px solid white;
			animation: bubblePulse 10s infinite ease-in-out;
			display: block;
		}

		.speech-bubble.narrative-mode::before {
			display: none;
		}

		@keyframes bubblePulse {

			0%,
			100% {
				opacity: 1;
				transform: scale(1) rotate(var(--bubble-rot, 0deg));
			}

			25% {

				transform: scale(1.025) rotate(var(--bubble-rot, 3deg));
			}

			50% {
				opacity: 0.8;
				transform: scale(1.) rotate(var(--bubble-rot, 0deg));
			}

			75% {
				transform: scale(1.025) rotate(var(--bubble-rot, -3deg));
			}
		}


		.close-dialog-btn {
			position: absolute;
			top: 0px;

			right: 0px;

			width: 30px;
			height: 30px;
			border-radius: 50%;
			border: none;
			border: 3px solid rgba(255, 255, 255, 0.7);
			;
			background: rgba(0, 0, 0, 0.3);
			color: white;
			font-size: 20px;
			cursor: pointer;
			display: flex;
			opacity: 0;
			align-items: center;
			justify-content: center;
			transition: background 0.2s;
			line-height: 1;
		}

		.speech-bubble:hover .close-dialog-btn {
			opacity: 1;
		}

		.close-dialog-btn:hover {
			background: darkgreen;
			color: white;
		}

		.dialogue-overlay {
			position: fixed;
			bottom: 25vh;
			left: 50%;
			width: 100%;
			max-height: 50vh;
			transform: translateX(-50%);
			justify-content: center;
			z-index: var(--z-SpeechBubble);
			pointer-events: none;
			display: flex;
			visibility: hidden;
			opacity: 0;
			transition: all 0.4s ease-out;
		}

		.dialogue-overlay.active {
			opacity: 1;
			visibility: visible;

		}

		.dialogue-overlay.narrative-mode {
			bottom: 10vh;
		}


		.speech-content {
			font-size: 20px;
			/*line-height: 1;*/
			color: #111;

			max-height: 150px;
			overflow-y: auto;
			text-align: center;
			word-wrap: break-word;
			font-weight: bold;
			white-space: pre-wrap;

			&::-webkit-scrollbar {
				display: none;
			}

			-ms-overflow-style: none;
			scrollbar-width: none;
		}

		.speech-content a {
			color: gold;
		}

		.speech-bubble.narrative-mode .speech-content {
			color: #CCC;
		}

		/* The New Button Row */
		.choice-row {
			display: flex;
			justify-content: center;
			/* Center buttons horizontally */
			align-items: center;
			gap: 15px;
			flex-wrap: wrap;
			/* Wrap buttons if there are many */
		}

		.choice-btn {
			width: 40px;
			height: 40px;
			border-radius: 50%;
			border: 2px solid #fff;
			cursor: pointer;
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
			transition: transform 0.2s, box-shadow 0.2s;
		}

		.choice-btn:hover {
			transform: scale(1.15) translateY(-2px);
			box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
		}


		/* Container for the Tab Buttons */
		.panel-tabs {
			display: flex;
			gap: 10px;
			margin-bottom: 5px;
			padding-bottom: 0px;
		}

		.script-step-btn {
			transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
		}

		.script-step-btn:active {
			transform: scale(0.8) rotate(-10deg);
		}

		.notes-btn {
			background: none;
			border-radius: 10px;
			color: var(--text-dim);
			cursor: pointer;
			display: none;
			font-size: 12px;
			padding: 2px 5px;
			height: 24px;
			width: 36px;
			margin:0px -5px;
		}

		#command-panel.edit-size-3 .notes-btn,
		#command-panel.edit-size-2 .notes-btn,
		.notes-panel:focus-within .notes-btn {
			display: inline-block;
		}

		.tab-btn {
			background: none;
			border: none;
			color: var(--text-dim);
			cursor: pointer;
			font-size: 0.9rem;
			padding: 5px 5px;
			transition: color 0.3s;
		}
		.tab-btn.active {
			color: var(--gold);
			font-weight: bold;
		}

		#tab-card-notes {
			display: block;
			/* Hidden by default */
			flex-direction: column;
			gap: 10px;
			height: 100%;
		}

		/* If the input has text, change the cursor across the app */
		#assign-tag-input:not(:placeholder-shown)~#main-content {
			cursor: copy;
		}

		/* The Highlight State */
		.file-item .card.already-has-tag {
			background-color: rgba(46, 204, 113, 0.25) !important;
			/* Green tint */
			outline: 2px solid #2ecc71 !important;
			transition: background-color 0.2s, outline 0.2s;
			position: relative;
		}

		/* Optional: Add a small green indicator dot or checkmark */
		.file-item.already-has-tag::after,
		.card.already-has-tag::after {
			content: '●';
			position: absolute;
			top: 5px;
			right: 8px;
			color: #2ecc71;
			font-size: 12px;
			text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
		}

		/* Highlight items on hover when a tag is ready to be assigned */
		.tag-assign-active .card:hover,
		.tag-assign-active .file-item:hover {
			outline: 2px solid #00ff00;
		}

		.card-textarea {
			width: 100%;
			min-height: 13vh;
			/* Adjust based on sidebar height */
			background: rgba(255, 255, 255, 0.05);
			border: 1px solid var(--border);
			color: var(--text);
			padding: 10px;
			border-radius: 8px;
			resize: none;
			font-family: inherit;
			font-size: 16px;
			line-height: 1.5;
			outline: none;
			overflow-y: auto;
		}
		#command-panel.edit-size-3 .card-textarea{
			min-height: 80vh;
		}
		#command-panel.edit-size-2 .card-textarea{
			min-height: 40vh;
		}
		#command-panel.edit-size-1 .card-textarea{
			min-height: 13vh;
		}

		.card-textarea.infocus {
			border: 1px solid gold;
		}

		#command-panel:has(.unsaved) .card-textarea:focus {
			border-color: var(--gold);
		}

		/* The Save Button Styling */
		.save-notes-btn {
			align-self: flex-end;
			background: transparent;
			border: 1px solid #888;
			color: #888;
			/* Grayed out by default */
			padding: 0px;
			border-radius: 5px;
			cursor: default;
			/* Not clickable when clean */
			transition: all 0.3s ease;
			display: flex;
			align-items: center;
			gap: 8px;
			/*filter: grayscale(1);*/
			/*opacity: 0.5;*/
		}

		/* The "Dirty" State: When user has typed but not saved */
		#command-panel:has(.unsaved) .save-notes-btn {
			color: var(--gold);
			border: 3px solid gold;

			cursor: pointer;
			filter: grayscale(0);
			opacity: 1;
			box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
		}

		#command-panel:has(.unsaved) .save-notes-btn:hover {
			background: rgba(255, 215, 0, 0.1);
		}

		.bottom-menu-container {
			position: fixed;
			bottom: 0;
			left: 50%;
			transform: translateX(-50%);
			z-index: var(--z-TransparentControls);
			display: flex;
			flex-direction: row;
			align-items: center;
			padding-bottom: 0;

		}


		.semi-circle-btn {
			width: 100px;
			height: 50px;
			background: rgba(255, 255, 255, 0.0);
			border: 1px solid rgba(255, 255, 255, 0.0);
			border-bottom: none;
			border-radius: 50px 50px 0 0;
			cursor: pointer;
			display: flex;
			justify-content: center;
			align-items: center;

			/* Layering & Transparency */
			z-index: 2;
			/* Higher than the panel */
			opacity: 0;
			/* Completely transparent */
			transition: opacity 0.3s ease;

			/* Backdrop blur looks great even when semi-transparent */
			backdrop-filter: blur(5px);
		}

		.bottom-menu-container:hover .semi-circle-btn {
			opacity: 1;
			/* Reveals on hover */
		}


		/* Graphic inside (matching your existing corner button style) */
		.menu-icon-graphic {
			display: flex;
			flex-direction: column;
			gap: 3px;
			margin-top: 5px;
			/* Adjusting for the half-shape visual center */
		}

		.menu-icon-graphic span {
			display: block;
			width: 20px;
			height: 2px;
			background: grey;
		}

		/* The Panel that pops up */
		.bottom-menu-panel {
			display: none;
			/* Hidden by default */
			width: auto;
			max-width: 800px;
			position: fixed;
			bottom: 0px;
			left: 50%;
			transform: translateX(-50%);
			background: rgba(0, 0, 0, 0.05);
			border: 1px solid var(--border);
			backdrop-filter: blur(10px);
			border-radius: 20px 20px 0 0;
			padding: 10px;
			margin: 0px;
			flex-direction: row;
			gap: 8px;
			text-align: center;
			justify-content: center;
			/* Sits above the button */
			z-index: var(--z-TransparentControls);
		}

		.bottom-menu-panel.active {
			display: flex;
		}


		#loading-screen {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: #000;
			z-index: var(--z-LoadingScreen, 1000);
			display: flex;
			justify-content: center;
			align-items: center;
			transition: opacity 0.8s ease-in-out, visibility 0.8s;
		}

		#sidebar *,
		.tag-cloud,
		.file-list,
		.track {
			-ms-overflow-style: none;
			scrollbar-width: none;

		}

		#sidebar *::-webkit-scrollbar,
		.track::-webkit-scrollbar {
			display: none;
		}

		/* Mobile-specific override */
		@media (max-width: 768px) {

			#sidebar,
			#collapsible-collections,
			#collapsible-tags,
			#collapsible-images,
			#header-bar {
				opacity: 1 !important;
				/* Optional: If you have a semi-transparent background,
	you might want to force it to solid as well */
				background-color: rgba(26, 26, 26, 1) !important;

				/* Ensures any transitions don't fight with the opacity */
				transition: none !important;
			}
		}

		body {
			background: var(--bg);
			/* This is #000, so it fades from black */
			color: var(--text);
			font-family: monospace;
			margin: 0;
			display: flex;
			height: 100vh;
			height: 100dvh;
			width: 100vw;
			overflow: hidden;
			background-size: cover;
			background-position: center;
			background-attachment: fixed;
			transition: background-image 0.5s ease-in-out;
		}

		body::before {
			content: "";
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.2);
			z-index: -1;
			pointer-events: none;
		}

		#splash-screen {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			height: 100dvh;
			background-color: #000;
			display: none;
			justify-content: center;
			align-items: center;
			z-index: var(--z-ExamineScreen);
			overflow: hidden;
			/* Hide scrollbars during panning */
			touch-action: none;
			/* Prevents browser interference on mobile */
		}

		#splash-img {
			max-width: 100%;
			max-height: 100%;
			width: 100vw;
			height: 100vh;
			height: 100dvh;
			object-fit: contain;
			transition: transform 0.1s ease-out;
			/* Smooths out the zoom/pan */
			cursor: grab;
			user-select: none;
			display: block;
			margin: 0;
		}

		#splash-img:active {
			cursor: grabbing;
		}

		/* Your existing trigger/corner buttons */
		.hover-trigger,
		#ghost-restore {
			z-index: var(--z-TransparentControls);
			/* Always on top */
		}

		@keyframes zoomIn {
			from {
				transform: scale(0.5);
				opacity: 0;
			}

			to {
				transform: scale(1);
				opacity: 1;
			}
		}

		/* Update the CSS for your menu toggle buttons */
		#menu-toggle,
		.corner-button-id {
			z-index: var(--z-TransparentControls);
			/* One level higher than the splash screen */
			position: fixed;
			/* Ensures they stay pinned to the corner */
		}

		body:has(.card.is-active.pinned) .star-btn,
		body:has(.card.is-active.pinned) .pin-btn {
			color: var(--gold) !important;
			background: rgba(255, 215, 0, 0.1) !important;
			border-color: var(--gold) !important;
		}

		#multitrack {
			flex: 1;
			display: flex;
			overflow: hidden;
			order: 1;
			gap: 0px;

		}

		/* HORIZONTAL: Tracks are stacked vertically as Rows */
		#body-wrap:not(.max-width) #multitrack {
			flex-direction: column-reverse;
		}

		#body-wrap:not(.max-width) .track {
			flex-direction: row;
			height: 100%;
			/* Becomes 50% automatically if a second track is added */
			width: 100%;
			display: flex;
			align-items: center;
			overflow-x: auto;
			overflow-y: hidden;

		}

		/* VERTICAL: Tracks are placed side-by-side as Columns */
		#body-wrap.max-width #multitrack {
			flex-direction: row;
		}

		#body-wrap.max-width .track {
			flex-direction: column;
			width: 100%;
			/* Becomes 50% automatically if a second track is added */
			height: 100%;
			display: flex;
			align-items: center;
			overflow-y: auto;
			overflow-x: hidden;

		}

		/* Push the main content over when sidebar is visible */
		body:not(.collapsed) #multitrack {
			/*margin-left: var(--sidebar-w);*/
			transition: margin-left 0.3s ease;
		}

		body.collapsed #multitrack {
			margin-left: 0;
		}



		/* Optional: Make cards look "dangerous" or fragile when in removal mode */
		body.removal-mode .card:hover,
		body.removal-mode .file-item:hover {
			border-color: #ff4444;
			filter: sepia(1) saturate(2) hue-rotate(-50deg);
			outline: 3px solid #ff4444;
			cursor: pointer;
		}

		body.removal-mode .track:hover:not(:has(.card:hover)) {
			background: rgba(128, 0, 0, 0.5) !important;
			cursor: pointer;
		}



		.sidebar-inner {
			container-type: inline-size;
			container-name: sidebar-container;
			border-radius: 30px 30px 0px 0px;
			max-height: calc(100vh - 128px);
			max-height: calc(100dvh - 128px);
			min-height: 0;
			backdrop-filter: blur(10px);

			height: auto;
			/* New Flex Logic */
			display: flex;
			flex-direction: column;
			justify-content: flex-start;
			/* Pushes content to the bottom */

			overflow-y: hidden;
			/* Keeps it scrollable if content overflows */
			-webkit-overflow-scrolling: touch;
			/* Adds smooth momentum scrolling for mobile */
			opacity: 0;
			transition: opacity 0.5s ease 0s;
		}



		#sidebar {
			position: fixed;
			border-radius: 30px;
			bottom: 0;
			top: auto;
			width: var(--sidebar-w);
			max-height: 100vh;
			max-height: 100dvh;
			height: auto;
			background: transparent;
			backdrop-filter: none;


			z-index: var(--z-GUIControls);
			/* Below Splash, as requested earlier */

			/* New Flex Logic */
			display: flex;
			flex-direction: column;
			justify-content: flex-start;
			/* Pushes content to the bottom */

			overflow-y: auto;
			/* Keeps it scrollable if content overflows */
			-webkit-overflow-scrolling: touch;
			/* Adds smooth momentum scrolling for mobile */

			transition: background 0.5s ease 0s, backdrop-filter 0.5s ease 0s;
		}

		#sidebar:hover {
			/* When hovered, the background and blur return INSTANTLY */
			background: rgba(0, 0, 0, 0.0);
			backdrop-filter: none;
			transition: background 0.2s ease, backdrop-filter 0.2s ease;
		}

		/* 20251228: Tanya: Don't hide the upper panel, it blocks clicks. */
		#sidebar:hover:has(.sidebar-upper) {
			/*#sidebar:has(.sidebar-upper) {*/
			/* When hovered, the background and blur return INSTANTLY */
			background: var(--panel);
			backdrop-filter: blur(20px);
			transition: background 0.2s ease, backdrop-filter 0.2s ease;
		}


		#sidebar>*:not(.header-bar) {
			opacity: 1;
			/* Fade out after 3 seconds */
		}

		/* 20251228: Tanya: Don't hide the upper panel, it blocks clicks.*/
		#sidebar:not(:hover)>*:not(.header-bar) {
			opacity: 0.1;
			pointer-events: none;
			transition: opacity 0.5s ease 0 los;
		}

		/* Ensure children don't stretch awkwardly */
		#sidebar>* {
			flex-shrink: 0;
		}

		/* Default Right Docked */
		body:not(.dock-left) #sidebar {
			right: 0;
			left: auto;
			order: 2;

		}

		/* Left Docked */
		body.dock-left #sidebar {
			left: 0;
			right: auto;
			order: 0;

		}

		/* Hidden States: Force the sidebar to the literal edges */
		body.collapsed:not(.dock-left) #sidebar {
			position: fixed;
			right: 0;
			top: 0;
			height: 100%;
			transform: translateX(100%);
		}

		body.collapsed.dock-left #sidebar {
			position: fixed;
			left: 0;
			top: 0;
			height: 100%;
			transform: translateX(-100%);
			/* Slides completely off-screen to the left */
		}

		/* Hidden States: No sliding, just fade out */
		body.collapsed #sidebar {
			opacity: 0;
			visibility: hidden;
			pointer-events: none;
			position: absolute;
			/* Take out of flow so .track expands instantly */
		}

		/* Visible States: Fade in */
		body:not(.collapsed) #sidebar {
			opacity: 1;
			visibility: visible;
			pointer-events: auto;
			position: fixed;
			/* Changed from relative */
			bottom: 0;
		}

		.control-panel-grid {
			display: grid;
			grid-template-columns: repeat(3, 1fr);
			gap: 8px;
			padding: 15px;
			border-top: 1px solid var(--border);
		}

		.sq-btn {
			aspect-ratio: 1 / 1;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 1.2rem;

			/* Normal state: semi-transparent */
			background: rgba(255, 255, 255, 0.5);
			border: 1px solid rgba(255, 255, 255, 0.1);
			color: rgba(255, 255, 255, 0.4);
			/* Dimmed text/icon */

			cursor: pointer;
			border-radius: 4px;
			transition: all 0.2s ease;
			/* Smooth fade effect */
		}


		.sq-btn:hover:not(.dim) {
			background: rgba(255, 255, 255, 0.15);
			border-color: rgba(255, 255, 255, 0.8);
			color: rgba(255, 255, 255, 1);
			/* Full white text/icon */
			box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
		}

		/* Special styling for the active mode toggle button */
		body.auto-flush #command-panel .auto-flush-btn {
			color: lightskyblue;
			border-color: lightskyblue;
			background-color: rgba(0, 0, 0, 0.25);
		}

		body.auto-random .auto-random-btn {
			color: var(--green);
			border-color: var(--green);
			background-color: rgba(0, 0, 0, 0.25);
		}

		body.auto-random .auto-random-btn {
			animation: pulse-green 5s ease-in-out infinite;
		}

		@keyframes pulse-green {
			0% {
				color: darkgreen
			}

			25% {
				color: var(--green)
			}

			100% {
				color: white;
				border-color: white
			}
		}

		body.removal-mode .removal-mode-btn {
			color: Crimson;
			border-color: Crimson;
			background-color: rgba(0, 0, 0, 0.25);
			transition: all 0.3s ease;
		}

		.sq-btn.active-gold {
			color: var(--gold);
			border-color: rgba(255, 215, 0, 0.3);
		}

		#auto-flush-btn:hover,
		.sq-btn.active-gold:hover {
			border-color: var(--gold);
			color: var(--gold);
			opacity: 1;
			transition: all 0.2s ease;
		}

		#toast {
			position: fixed;
			top: 20%;
			left: 50%;
			transform: translateX(-50%);
			background: rgba(255, 215, 0, 0.6);
			backdrop-filter: blur(8px);
			color: #000;
			padding: 10px 20px;
			border-radius: 8px;
			font-weight: bold;
			font-size: 16px;
			z-index: var(--z-Notifications);
			opacity: 0;
			transition: opacity 0.3s ease;
			pointer-events: none;
			border: 1px solid rgba(255, 255, 255, 0.2);
			text-align: center;
		}

		#toast.show {
			opacity: 1;
		}

		/* Hide the old ghost restore button */
		#ghost-restore {
			display: none !important;
		}

		/* New Hover-to-Show zones: Always on top */
		.hover-trigger {
			position: fixed;
			bottom: 0;
			/* Changed from top: 0 */
			width: 50px;
			height: 50px;
			z-index: var(--z-TransparentControls);
			display: flex;
			align-items: center;
			justify-content: center;
			background: rgba(255, 255, 255, 0.05);
			backdrop-filter: blur(5px);
			cursor: pointer;
			font-size: 20px;
			color: #fff;
			opacity: 0;
			transition: opacity 0.3s ease, background 0.2s;
			border: 1px solid var(--border);
		}

		.hover-trigger:hover {
			opacity: 1;
			background: rgba(255, 255, 255, 0.15);
		}

		#trigger-left {
			left: 0;
			border-radius: 0 15px 0 0;
			/* Adjusted for bottom left */
		}

		#trigger-right {
			right: 0;
			border-radius: 15px 0 0 0;
			/* Adjusted for bottom right */
		}

		/* Ensure triggers only appear when collapsed */
		body.collapsed .hover-trigger {
			display: flex;
		}

		body.dock-left #ghost-restore {
			right: auto;
			left: 15px;
		}

		body.collapsed #ghost-restore {
			display: flex;
		}

		.track {
			flex: 1;
			padding: 0px;
			display: flex;
			gap: 0px;
			/* Wider gap for cleaner storyboard look */
			transition: width 0.3s ease;
			height: 100vh;
			height: 100dvh;
			order: 1;
			flex-direction: var(--h-dir);

			/* align-items: center;
	justify-content:flex-start;*/

			justify-content: safe center;
			/* Test */
			width: 100%;
			/* Test */

			align-items: center;
			overflow-x: auto;
			overflow-y: hidden;
			flex-wrap: nowrap;


			scroll-behavior: smooth;
			/* Ensure the container transitions smoothly if padding changes */
			transition: padding 0.5s ease;
		}

		/* Ensure vertical mode keeps its original padding */
		body.max-width .track {

			padding-top: 5px;
			padding-bottom: 5px;
			/* Adds empty space at the bottom so the last card can scroll up to the middle */
			flex-direction: column;
			align-items: center;
			overflow-y: auto;
			overflow-x: hidden;
		}


		/* Add this to your <style> section */
		.settings-close {
			width: 24px !important;
			height: 24px !important;
			font-size: 14px !important;
			background: rgba(255, 255, 255, 0.05) !important;
			border-color: var(--border) !important;
		}

		.settings-close:hover {
			background: rgba(255, 50, 50, 0.2) !important;
			/* Subtle red hover for "close" */
			border-color: rgba(255, 50, 50, 0.5) !important;
		}

		.card {
			position: relative;
			border: 3px solid rgba(255, 255, 255, 0.2);
			border-radius: 14px;
			flex-shrink: 0;
			/* CHANGE: Uses 98% of the parent track's height instead of a fixed 98vh */
			height: 100%;
			overflow: hidden;
			background: transparent;
			transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
			animation: cardEntrance 0.6s cubic-bezier(0.23, 1, 0.32, 1) both;
			box-shadow: 0 1px 1px rgba(0, 0, 0, 0.5);
			display: inline-block;
		}

		.card:has(.scaled) {
			overflow: visible;
		}

		.card img {
			height: 100%;
			width: auto;
			object-fit: contain;
			display: block;
		}
		.card:hover{
			background-color: rgba(255,215,0,0.25);
		}


		/* The active/centered card style */
		.card.is-active {
			border-color: rgba(255, 215, 0, 0.6);
			/*Gold Color */
			box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
			transform: scale(1.02);
			z-index: var(--z-Gallery);
		}

		/* Keyframes for the new card appearing */
		@keyframes cardEntrance {
			0% {
				opacity: 0;
				transform: scale(0.8) translateY(20px);
				filter: blur(10px);
			}

			100% {
				opacity: 1;
				transform: scale(1) translateY(0);
				filter: blur(0);
			}
		}

		body.max-width .card {
			width: 98%;
			height: auto;
		}

		body.max-width .card img {
			width: 100%;
			height: auto;
		}



		.card.pinned::after {
			content: "";
			/* Empty content because we are using a background image */
			position: absolute;
			top: -4px;
			left: -4px;
			width: 36px;
			height: 36px;
			/* Using a data URI SVG so you don't need an external file */
			background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 30 30' fill='%23FFC700' stroke='rgba(255,255,255,0.5)' stroke-width='2' stroke-linejoin='round'%3E%3Cpath d='M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z'/%3E%3C/svg%3E");
			/*background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23FFD700'%3E%3Cpath d='M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z'/%3E%3C/svg%3E");*/
			background-size: contain;
			background-repeat: no-repeat;
			/* Optional: Add a subtle drop shadow to make it pop against card art */
			filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.5));
			pointer-events: none;
			/* Let clicks pass through the icon to the card */
			z-index: calc(var(--z-Gallery)+1);
			opacity: 0;
			transition: opacity 0.3s ease 10s;
		}

		/* Ensure the card is wide enough for a document */
		.card:has(embed),
		.card:has(iframe) {
			width: 100vw;
			/* Or 90vw for mobile responsiveness */
			height: 100%;
			display: flex;
			justify-content: center;
			align-items: stretch;
		}

		/* Force the embed to take all available space */
		embed {
			display: block;
			width: 100% !important;
			height: 100% !important;
		}

		/* When the track is vertical, ensure the PDF card spans more height */
		.max-width .track .card:has(embed),
		.max-width .track .card:has(iframe) {
			height: 100vh !important;
			/* Spans 80% of the screen height */
			width: 100%;
			/* Takes full width of the vertical track */
			max-width: none;
			min-height: none;
			/* Ensures it's never too 'flat' to read */
		}

		/* Ensure the embed fills the newly sized card */
		.card embed,
		.card iframe {
			width: 100%;
			height: 100%;
			object-fit: contain;
		}

		body:has(#sidebar:hover) .card.pinned::after,
		body:has(#command-panel:not(.hidden)) .card.pinned::after {
			opacity: 1;
			transition: opacity 0.3s ease;
		}

		.tool-btn {
			background: rgba(0, 0, 0, 0.1);
			color: rgba(255, 255, 255, 0.1);
			border: 1px solid rgba(255, 255, 255, 0.1);
			width: 36px;
			height: 36px;
			cursor: pointer;
			border-radius: 8px;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 16px;
			text-decoration: none;
		}

		.tool-btn.half {
			width: 54px;
			height: 54px;
			font-size: 27px;
		}

		.tool-btn.large {
			width: 72px;
			height: 72px;
			font-size: 36px;
		}

		.tool-btn.full {
			width: 108px;
			height: 108px;
			font-size: 54px
		}

		.tool-btn:hover {
			border: 1px solid rgba(255, 255, 255, 0.8);
			color: rgba(255, 255, 255, 0.8);
		}

		.import-btn {
			background: var(--gold);
			color: #000;
			border: none;
			padding: 8px;
			border-radius: 4px;
			cursor: pointer;
			font-family: monospace;
			font-weight: bold;
			width: 100%;
		}

		.css-grid {
			width: 14px;
			height: 14px;
			display: grid;
			grid-template-columns: 1fr 1fr;
			grid-template-rows: 1fr 1fr;
			gap: 2px;
		}

		.css-grid div {
			border: 1.5px solid currentColor;
			border-radius: 1px;
		}

		.css-list {
			width: 14px;
			height: 14px;
			display: flex;
			flex-direction: column;
			justify-content: space-between;
			padding: 1px 0;
		}

		.css-list div {
			height: 2px;
			background: currentColor;
			width: 100%;
			border-radius: 1px;
		}

		.css-mag {
			width: 14px;
			height: 14px;
			border: 2px solid currentColor;
			border-radius: 50%;
			position: relative;
		}

		.css-mag::after {
			content: "";
			position: absolute;
			top: 11px;
			left: 11px;
			width: 6px;
			height: 2px;
			background: currentColor;
			transform: rotate(45deg);
			transform-origin: top left;
		}

		.css-wall {
			width: 12px;
			height: 12px;
			border: 2px solid currentColor;
			border-radius: 50% 50% 50% 0;
			transform: rotate(-45deg);
			position: relative;
			top: -2px;
		}

		.header-bar {
			background-color: transparent;
			padding: 0px;
			transition: background-color 0.3s ease;
			flex-shrink: 0;
			/* Smooth fade effect */
		}

		.header-bar:hover {
			backdrop-filter: none;
		}


		.btn-group {
			display: flex;
			gap: 8px;
			/* Slightly wider gap for better touch/click targets */
			justify-content: center;
			/* Centers the buttons horizontally */
			width: 100%;
		}

		/* Ensure buttons within the group don't stretch */
		.btn-group .sq-btn {
			flex: 0 0 auto;
		}

		.grid-container {
			display: grid;
			/* This tells the grid: "Make as many columns as fit, 
       with a minimum width of 100px and a maximum of 1fr" */
			grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
			gap: 10px;
			padding: 10px;
			width: 100%;
		}

		.sq-btn {
			background: rgba(255, 255, 255, 0.5);
			border: none;
			width: 40px;
			height: 40px;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 18px;
			color: #000 !important;
			border-radius: 8px;
			flex-shrink: 0;
			transition: all 0.2s;
			text-decoration: none;
		}

		.sq-btn.dim {
			background: rgba(255, 255, 255, 0.25);
			color: rgba(0, 0, 0, 0) !important;
			transition: background 0.5s ease 10s, color 0.5s ease 1s;
		}

		#sidebar:hover .sq-btn.dim {
			background: rgba(255, 255, 255, 0.5);
			color: rgba(0, 0, 0, 0.75) !important;
			transition: background 0.5s ease, color 0.5s ease;
		}




		.sq-btn.active-gold {
			background: var(--gold);
			color: #000 !important;
		}

		/* Centers the wallpaper icon inside the sidebar square button */
		.sq-btn .css-wall {
			margin: 0 auto;
			transform: rotate(-45deg) scale(1.2);
			/* Slightly larger for the sidebar */
		}

		.active-preview-container {
			display: flex;
			align-items: center;
			gap: 0px;
			padding: 0px;
			/*background: rgba(255, 255, 255, 0.05);*/
			border-radius: 8px;
			border: 1px solid rgba(255, 255, 255, 0.1);
		}

		#active-preview-thumb {
			width: 32px;
			height: 32px;
			object-fit: contain;
			border-radius: 4px;
			/*border: 1px solid #ffd700;*/
			/* A little gold border to match the star theme */
			box-shadow: 0 0 5px rgba(255, 215, 0, 0.3);
		}

		#active-preview-label {
			font-size: 0.8rem;
			color: #ccc;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			max-width: 120px;
		}

		.tabs-contents {
			display: block;
			/* Ensure it's a block container */
			max-height: 90vh; 
			/* The limit */
			overflow-y: auto;
			/* Enable vertical scroll */
			overflow-x: hidden;
			/* Prevent horizontal shifting */
			box-sizing: border-box;
			/* CRITICAL: Includes padding in the 30vh calculation */
			padding-bottom: 10px;
			/* Gives the inputs some breathing room at the bottom */
		}

		/* Width of the scrollbar */
		.tabs-contents::-webkit-scrollbar {
			width: 6px;
		}

		/* The background track */
		.tabs-contents::-webkit-scrollbar-track {
			background: transparent;
		}

		/* The actual draggable handle */
		.tabs-contents::-webkit-scrollbar-thumb {
			background-color: rgba(155, 155, 155, 0.5);
			/* Semi-transparent grey */
			border-radius: 10px;
			/* Rounded edges */
		}

		/* Handle on hover */
		.tabs-contents::-webkit-scrollbar-thumb:hover {
			background-color: rgba(155, 155, 155, 0.8);
		}

		/* For Firefox support */
		.tabs-contents {
			scrollbar-width: thin;
			scrollbar-color: rgba(155, 155, 155, 0.5) transparent;
		}

		#command-panel {
			position: fixed;
			/* Changed from absolute */
			bottom: 0px;
			/* Distance from bottom of screen */
			left: 50%;
			/*transform: translateX(-50%);*/

			width: 100vw;
			/* You can now make it wider than the sidebar */
			max-height: 100vh;
			max-width: 792px;

			background: rgba(0, 0, 0, 0.4);
			backdrop-filter: blur(20px);
			border: 2px solid rgba(255, 255, 255, 0.4);
			border-radius: 15px;
			padding: 10px;

			z-index: var(--z-GUIControls);
			/* Keeps it above the sidebar */

			flex-direction: column;
			gap: 15px;
			box-shadow: 0 10px 10px rgba(0, 0, 0, 0.8);
			font-size: 1.5em;
			transform: translateX(-50%) translateY(0%);
			opacity: 1;
			transition: all 0.3s ease-out;
		}

		#command-panel.hidden {
			/* Keep X at -50% so it stays centered while sliding up */
			transform: translateX(-50%) translateY(100%);
			opacity: 0;
		}


		/* Custom Scrollbar Styling */
		#command-panel textarea::-webkit-scrollbar {
			width: 6px;
			/* Very thin */
		}

		#command-panel textarea::-webkit-scrollbar-track {
			background: transparent;
			/* Makes the track invisible */
		}

		#command-panel textarea::-webkit-scrollbar-thumb {
			background: rgba(255, 255, 255, 0.2);
			/* Subtle white thumb */
			border-radius: 10px;
		}

		#command-panel textarea::-webkit-scrollbar-thumb:hover {
			background: var(--gold);
			/* Highlights gold on hover to match your UI */
		}

		/* For Firefox */
		#command-panel textarea {
			scrollbar-width: thin;
			scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
		}


		.unified-width {
			width: 100%;
			background: rgba(255, 255, 255, 0.0);
			color: #fff;
			border: 1px solid var(--border);
			font-family: monospace;
			outline: none;
			border-radius: 6px;
			padding: 8px;
		}

		.tag-cloud {
			display: flex;
			flex-wrap: wrap;
			gap: 4px;
			padding: 5px 15px;
			max-height: 25vh;
			overflow-y: auto;
		}

		.tag-pill {
			background: rgba(0, 0, 0, 0.5);
			color: var(--text-dim);
			padding: 4px 8px;
			border: 1px solid var(--border);
			font-size: 10px;
			cursor: pointer;
			border-radius: 4px;
		}

		.tag-pill.active {
			background: var(--accent);
			color: #000 !important;
		}

		.tag-count-small {
			opacity: 0.5;
			font-size: 9px;
		}

		.action-btn {
			background: rgba(255, 255, 255, 0.1) !important;
			color: var(--text-dim) !important;
			border: 1px solid var(--border) !important;
			opacity: 0.7;
		}

		.action-btn:hover {
			background: rgba(255, 255, 255, 0.2) !important;
			color: #fff !important;
			opacity: 1;
		}

		/* Current State: Solid/Bright */
		.state-active {
			background: var(--accent) !important;
			color: #000 !important;
			opacity: 1 !important;
		}

		.stats-bar {
			display: flex;
			align-items: center;
			justify-content: space-between;
			padding: 8px 15px;
			background: rgba(0, 0, 0, 0.3);
			border-bottom: 1px solid var(--border);
			font-size: 14px;
		}

		.stats-clickable {
			cursor: pointer;
			white-space: nowrap;
			/* Prevents text from wrapping */
			flex-shrink: 0;
			/* Prevents the label from being squashed */
			width: fit-content;
			/* Only takes the space of the words */
		}

		.stats-clickable:hover {
			color: #fff;
		}

		/* Centering logic for Tags Bar */
		.stats-bar.tags-bar {
			display: flex;
			align-items: center;
			gap: 10px;
			padding: 8px 15px;
		}

		.stats-bar-spacer {
			width: 32px;
			flex-shrink: 0;
		}

		.version-code {
			font-size: 9px;
			color: var(--text-dim);
			opacity: 0.6;
			font-family: monospace;
			flex-grow: 1;
			text-align: center;
		}




		/* Matches Sort button width */
		.tags-bar-center {
			display: flex;
			align-items: center;
			justify-content: center;
			flex-grow: 1;
			gap: 8px;
			overflow: hidden;
		}

		.inline-toggle {
			background: transparent;
			border: 1px solid var(--border);
			color: var(--text-dim);
			cursor: pointer;
			border-radius: 4px;
			padding: 4px 6px;
			display: flex;
			align-items: center;
			transition: all 0.2s;
			font-size: 10px;
			min-width: 32px;
			justify-content: center;
		}

		.inline-toggle:hover {
			border-color: var(--accent);
			color: #fff;
		}


		/* Ensure the image container grows to fill all vertical space */
		#collapsible-images {
			flex: 1;
			display: flex;
			/* Default to flex so it fills space */
			flex-direction: column;
			overflow: hidden;
			min-height: 0;
			background: rgba(0, 0, 0, 0.2);
		}

		#file-list {
			flex: 1;
			overflow-y: auto;
			width: 100%;
			min-height: 0;
		}


		.button-grid {
			/* Optional: visual separator */
			display: grid !important;
			gap: 2px;
			grid-template-columns: repeat(7, 1fr);
			/* 6 buttons per row */
			height: auto;
			padding: 2px 2px;
			width: 100%;
		}

		#collapsible-collections {
			display: flex;

			gap: 8px;
			flex-direction: column;
			border-bottom: 1px solid var(--border);
			background: rgba(0, 0, 0, 0.2);
		}

		#master-search {
			flex: 1;
			/* This makes the search box grow to fill all available space */
			min-width: 50px;
			/* Prevents it from disappearing on tiny screens */
			text-align: center;
			background: rgba(255, 255, 255, 0.05);
			border: 1px solid var(--border);
			color: #fff;
			border-radius: 6px;
			padding: 6px;
			outline: none;
			transition: border-color 0.2s;
		}

		#master-search:focus {
			border-color: var(--accent);
		}

		/* Ensure the label and button don't shrink */
		.tags-bar .stats-clickable,
		#tag-sort-btn {
			flex-shrink: 0;
		}

		/* Collection Path List Styles */
		#path-list-container {
			display: flex;
			flex-direction: column;
			gap: 4px;
			margin-top: 5px;
			max-height: 150px;
			overflow-y: auto;
			padding-right: 4px;
		}

		.path-entry {
			display: flex;
			align-items: center;
			gap: 6px;
			background: rgba(255, 255, 255, 0.05);
			padding: 4px;
			border-radius: 4px;
		}

		.path-entry input[type="text"] {
			flex: 1;
			background: transparent;
			border: none;
			color: var(--text-dim);
			font-size: 9px;
			pointer-events: none;
		}

		.path-entry input[type="checkbox"] {
			cursor: pointer;
			width: 16px;
			height: 16px;
			accent-color: var(--gold);
		}

		.path-entry.stale input[type="checkbox"] {
			accent-color: var(--gold);
		}

		.path-entry.loaded input[type="checkbox"] {
			accent-color: var(--green);
		}

		.path-text {
			flex: 1;
			background: transparent;
			border: none;
			color: var(--text-dim);
			font-size: 10px;
			cursor: pointer;
			/* Updated for full path visibility */
			word-break: break-all;
			/* Breaks long strings like URLs */
			white-space: normal;
			/* Allows wrapping to new lines */
			line-height: 1.2;
			padding: 2px 0;
		}

		.path-entry {
			display: flex;
			align-items: flex-start;
			/* Align checkbox/trash to the top of wrapped text */
			gap: 6px;
			background: rgba(255, 255, 255, 0.05);
			padding: 6px;
			border-radius: 4px;
			margin-bottom: 2px;
		}

		.path-text:hover {
			color: #fff;
			text-decoration: underline;
		}

		.trash-btn {
			background: transparent;
			border: none;
			color: #ff4444;
			cursor: pointer;
			font-size: 12px;
			padding: 2px 6px;
			opacity: 0.7;
		}

		.trash-btn:hover {
			opacity: 1;
		}

		.file-list {
			flex: 1;
			overflow-y: auto;
		}

		.grid-view {
			display: grid !important;
			grid-template-columns: repeat(var(--grid-cols), 1fr) !important;
			grid-auto-rows: min-content;
			gap: 6px;
			padding: 8px;
		}

		.grid-view .file-item {
			padding: 0;
			border: 1px solid var(--border);
			aspect-ratio: 1/1;
			border-radius: 6px;
			position: relative;
			overflow: hidden;
			display: block;
		}

		.grid-view .file-item img {
			width: 100%;
			height: 100%;
			object-fit: contain;
			position: absolute;
			top: 0;
			left: 0;
		}

		.grid-view .active-item {
			border: 5px solid var(--gold) !important;
			z-index: var(--z-Listings);
			transform: scale(1.02);
		}

		.file-item {
			padding: 10px 15px;
			border-bottom: 1px solid rgba(255, 255, 255, 0.05);
			font-size: 11px;
			cursor: pointer;
			color: var(--text-dim);
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			transition: all 0.2s ease;
		}

		.file-item.active-item {
			color: var(--gold) !important;
			font-weight: bold;
			background: rgba(255, 215, 0, 0.15) !important;
			/* Visible highlight */
		}

		.grid-view .file-item.active-item {
			border: 3px solid var(--gold) !important;
			transform: scale(1.05);
			z-index: var(--z-Listings);
			background: transparent !important;
			/* Hide list bg in grid mode */
		}

		.active-item {
			color: var(--gold) !important;
			font-weight: bold;
			background: rgba(255, 215, 0, 0.1);
		}

		.card-tag-overlay {
			display: none;
			/* Controlled by toggleOverlay */
			position: absolute;
			top: 55px;
			/* Positions it just below the card-tools buttons */
			right: 15px;
			width: 200px;
			/* Constrains the width to a small side frame */
			max-height: 70%;
			flex-wrap: wrap;
			gap: 5px;
			padding: 10px;
			background: rgba(0, 0, 0, 0.85);
			border: 1px solid var(--border);
			border-radius: 8px;
			z-index: var(--z-Gallery);
			/* Above the image but below main sidebar */
			overflow-y: auto;
			backdrop-filter: blur(10px);

		}

		#grid-slider-container {
			display: none;
			/* JavaScript toggles this to 'flex' */
			align-items: center;
			margin-left: 15px;
			/* Space after "Images" text */
			margin-right: 15px;
			/* Space before the grid button */
			flex: 1;
			/* Fills the entire gap */
			min-width: 0;
		}

		#col-slider {
			-webkit-appearance: none;
			width: 100%;
			/* Slider stretches to fill the whole container */
			height: 4px;
			background: var(--border);
			border-radius: 2px;
			outline: none;
			cursor: pointer;
			accent-color: var(--accent);
			padding: 0px;
		}

		#grid-toggle-btn {
			flex-shrink: 0;
			/* Keeps the button square and fixed to the right */
		}

		#col-slider::-webkit-slider-thumb {
			-webkit-appearance: none;
			width: 12px;
			height: 12px;
			background: var(--accent);
			border-radius: 50%;
			cursor: pointer;
		}



		#sidebar #remove-mode-btn,
		#sidebar #auto-flush-btn,
		.dimmer {
			opacity: 0;
			transition: opacity 0.3s ease 0s;
		}

		#remove-mode-btn:hover,
		#auto-flush-btn:hover,
		#sidebar:hover .active-gold,
		body.auto-flush #auto-flush-btn,
		.dimmer:hover {
			opacity: 1 !important;
			transition: opacity 0.5s ease;
		}

		#remove-mode-btn.removal-active,
		.removal-mode-btn .removal-active {
			opacity: 1 !important;
			background: darkred !important;
			color: white !important;
			border-color: darkred !important;
			box-shadow: 0 0 15px rgba(255, 0, 0, 0.4);
		}

		.sq-btn.dimmer {
			background: rgba(0, 0, 0, 0.0);
			color: var(--text-dim) !important;
		}



		/* The main container for the icon */
		.floppy-icon {
			position: relative;
			width: 20px;
			height: 20px;
			background-color: currentColor;
			/* Matches the text color of the button */
			border-radius: 2px 4px 2px 2px;
			/* The top-right is slightly more rounded/clipped */
			display: inline-block;
			vertical-align: middle;
		}

		/* The Metal Shutter (Top part) */
		.floppy-icon::before {
			content: '';
			position: absolute;
			top: 2px;
			left: 4px;
			width: 10px;
			height: 6px;
			background-color: var(--bg, #000);
			/* Uses your app's background color */
			border-radius: 1px;
		}

		/* The Label (Bottom part) */
		.floppy-icon::after {
			content: '';
			position: absolute;
			bottom: 2px;
			left: 3px;
			right: 3px;
			height: 8px;
			background-color: rgba(255, 255, 255, 0.8);
			border-radius: 1px;
		}

		/* Center the character containers perfectly */
		.icon-h,
		.icon-v {
			display: flex;
			align-items: center;
			justify-content: center;
			width: 24px;
			/* Fixed width to prevent shifting */
			height: 24px;
			/* Fixed height to prevent shifting */
			font-size: 24px;
			font-weight: bold;
			color: #fff;
			line-height: 0;
			/* Strips font-specific vertical padding */
			pointer-events: none;
			user-select: none;
			margin: 0 auto;
			/* Centers the div within the square button */
		}

		/* Horizontal Dash centering */
		.icon-h::before {
			content: '—';
			transform: translateY(-2px);
			/* Corrects the typical 'sink' of a dash */
		}

		/* Vertical Pipe centering */
		.icon-v::before {
			content: '|';
			transform: translateX(0);
			/* Ensure no horizontal bias */
		}

		/* Hover Preview Logic: Ensure previews use the same offsets as active states */
		#mode-toggle:hover .icon-h::before {

			opacity: 0.7;
			transform: translateY(0);
			/* Remove the dash-specific vertical shift */
		}

		#mode-toggle:hover .icon-v::before {

			opacity: 0.7;
			transform: translateY(-2px);
			/* Apply the dash-specific vertical shift */
		}


		/* CSS Star Icon */
		/* Perfect 5-Point Star using Clip-Path */
		.icon-star {
			width: 20px;
			height: 20px;
			background: currentColor;
			clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
		}

		.icon-star::after {
			content: "";
			position: absolute;
			top: 6px;
			left: -10px;
			border-left: 10px solid transparent;
			border-right: 10px solid transparent;
			border-top: 18px solid currentColor;
		}

		/* When the card is pinned, turn the star button gold and solid */
		.card.pinned .pin-btn {
			color: var(--gold) !important;
			background: rgba(0, 0, 0, 0.4);
			/* Slightly darker background to pop the gold */
			border-color: var(--gold);
		}

		/* Ensure that when NOT pinned, the star stays semi-transparent even on the 'centered' card */
		.pin-btn {
			color: rgba(255, 255, 255, 0.1) !important;
		}

		/* Hovering over the star should still make it visible */
		.pin-btn:hover {
			color: rgba(255, 255, 255, 0.8) !important;
		}



		/* Simple Perfect Circle Icon */
		.icon-circle {
			width: 14px;
			height: 14px;
			border: 2px solid currentColor;
			/* Matches the button's text color */
			border-radius: 50%;
			display: inline-block;
			background: transparent;
			/* Hollow circle */
		}

		/* Optional: Solid circle on hover */
		.action-btn:hover .icon-circle {
			background: currentColor;
		}

		.stage-area {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			z-index: 40;
			/* Above Backstage (30), below Dialog (60) */
			background-color: #000;
			background-size: cover;

			background-position: center;
			opacity: 0;
			visibility: hidden;
			pointer-events: none;
			/* Hidden by default */
			opacity: 0;
			transition: opacity 1s ease-in-out, visibility 1s;
		}

		.stage-area.active {

			opacity: 1;
			visibility: visible;
			pointer-events: auto;
		}

		/* The Pulsing Next Button */
		.stage-next-btn {
			position: fixed;
			bottom: 5px;
			left: 50%;
			width: 75px;
			height: 75px;
			background: rgba(255, 255, 255, 0.2);
			border-radius: 50%;
			cursor: pointer;
			z-index: 55;
			/* Just below dialog bubbles */
			display: none;
			align-items: center;
			justify-content: center;
			transform: translateX(-50%) translateY(0%);
			animation: invisiblePulse 10s infinite;
		}

		body:has(.stage-area.active) .stage-next-btn {
			display: flex;
		}

		.stage-next-btn:hover {
			opacity: 0.75 !important;
			animation: none !important;
		}

		.actor {
			position: absolute;
			bottom: 0;
			/* Anchors the container to the floor */
			left: 50%;
			/* Anchors the container to the horizontal center */
			width: 0;
			/* Zero size container so it doesn't block clicks */
			height: 100%;
			display: flex;
			justify-content: center;
			align-items: flex-end;
			pointer-events: none;
			opacity: 0;
			visibility: none;
			transition: opacity 0.5s ease-in-out, visibility 0.5s;

		}

		.stage-area.active .actor.active {
			opacity: 1;
			visibility: visible;
		}

		.actor img {
			position: absolute;
			pointer-events: auto;
			/*transform-origin: center bottom;*/
			/* Optional, since you are moving to 50% 50% logic */
			max-width: none;
			height: 100%;
			/* Prevents the image from being squished */
		}


		body:has(.choice-entry.selected) .stage-next-btn {
			background-color: gold;
			animation: invisiblePulse 5s infinite;
		}

		@keyframes invisiblePulse {

			0%,
			30%,
			70%,
			100% {
				opacity: 0.5;
			}

			40%,
			50%,
			60% {
				opacity: 0.0;
			}
		}

		@keyframes selectedPulse {

			0%,
			25%,
			75%,
			100% {
				opacity: 0.5;
			}

			50% {
				opacity: 0.0;
			}
		}

		body:has(.card.card.is-active img.scaled) .scale-btn,
		body:has(.card.card.is-active img.left) .flip-btn,
		body:has(.card.card.is-active img.grounded) .ground-btn {
			background-color: palegreen;
		}

		body:has(.card.card.is-active img.right) .flip-btn {
			background-color: gold;
		}

		#card-id,
		#card-img-url,
		#card-notes,
		#card-script,
		#card-path-url,
		#card-sprite-parameters,
		#card-title,
		#card-tag-section{
			display:none;
		}

		#card-id.active,
		#card-img-url.active,
		#card-notes.active,
		#card-script.active,
		#card-path-url.active,
		#card-sprite-parameters.active,
		#card-title.active,
		#card-tag-section.active{
			display:block;
		}

		.sec-btn {
			background: rgba(0,0,0,0.0);
			border-radius: 10px;
			color: grey;
			cursor: pointer;
			font-size: 12px;
			padding: 2px 0px;
			height: 24px;
			width: 32px;
			margin:0px -5px;
		}
		.sec-btn.on{			
			color:white;
			display: inline-block;
		}
		/* #CSS END */
	</style>
</head>

<body id="body-wrap" contenteditable="false">
	<div id="multitrack">
		<div class="track"></div>
	</div>


	<div id="sidebar">
		<div id="collapsible-collections">
			<div class="stats-bar">
				<div class="stats-clickable" onclick="toggleCollections(event)">Collections (<span
						id="collection-count">0</span>)
				</div>
				<a href="https://magicbakery.github.io/?id=P202512210026" target="_blank" rel="noopener noreferrer"
					class="bakery-link" id="version-link">ⓘ</a>
			</div>
			<div style="padding:0px 5px">
				<input type="file" id="json-input" style="display:none" accept=".json" onchange="importJSON(this)">
				<div style="display:flex; gap:4px;">
					<input type="file" id="mobile-file-input" style="display:none" accept="image/*">
					<button class="import-btn action-btn" style="width: 32px;" onclick="smartImport()">+</button>
					<button class="import-btn action-btn" style="flex: 1;" onclick="exportFilteredData('path')"
						title="Export Path">PATH</button>
					<button class="import-btn action-btn" style="flex: 1;" onclick="exportFilteredData('base64')"
						title="Export Base64">BASE64</button>
					<button class="import-btn action-btn" style="flex: 1;" onclick="exportMultiTrack()"
						title="Export or Import Multitrack DOM">DOM</button>
					<button class="import-btn action-btn" style="flex: 1;" onclick="exportGallery()"
						title="Export HTML">HTML</button>
				</div>
				<div id="path-list-container"></div>
			</div>
		</div>
		<div id="collapsible-images" class="sidebar-upper"
			style="flex: 1; display: flex; flex-direction: column; overflow: hidden; background: rgba(0,0,0,0.2);">
			<div class="stats-bar">
				<div class="stats-clickable" onclick="toggleImages(event)">Images (<span id="img-count">0</span>)</div>
				<div id="grid-slider-container">
					<input type="range" id="col-slider" min="1" max="5" value="3" oninput="updateGridCols(this.value)">
				</div>
				<button class="inline-toggle" id="grid-toggle-btn" onclick="toggleSidebarView()">
					<div class="css-grid" id="toggle-icon">
						<div></div>
						<div></div>
						<div></div>
						<div></div>
					</div>
				</button>
			</div>
			<div id="file-list" class="file-list"></div>
		</div>
		<div id="collapsible-tags" class="sidebar-upper">
			<div id="tag-cloud" class="tag-cloud"></div>
			<div class="stats-bar tags-bar">
				<span class="stats-clickable" onclick="toggleTagCloud(event)">Tags (<span id="tag-count">0</span>)</span>
				<input type="text" id="master-search" class="unified-width" style="width:100px; text-align:center"
					placeholder="SEARCH..." oninput="refreshAllUI()">
				<button class="inline-toggle" id="tag-sort-btn" onclick="toggleTagSort()">A-Z</button>
			</div>



		</div>

		<div class="header-bar">
			<div id="button-palette" style="display:block;"><!--@@Stage-->
				<div class="button-grid">
					<!--Star Button-->
					<button class="sq-btn dimmer star-btn" onclick="togglePinActiveCard(event)" title="Star Active Card">
						<svg viewBox="0 0 24 24" width="36" height="36" fill="currentColor" stroke="currentColor" stroke-width="2"
							stroke-linejoin="round">
							<path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
						</svg>
					</button>
					<!--Collections Button-->
					<button class="sq-btn dimmer" onclick="toggleCollections(event)" title="Collections">
						<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
							stroke-linecap="round" stroke-linejoin="round">
							<rect x="7" y="7" width="14" height="14" rx="2" ry="2"></rect>
							<path d="M3 15v-8c0-1.1.9-2 2-2h8"></path>
						</svg>
					</button>

					<!--Save button-->
					<!--
					<button class="sq-btn dim" onclick="memDOM()" title="Save Changes">
						<svg viewBox="0 0 100 100" style="width:90%; height:90%;">
							<path d="M20,15 H70 L85,30 V85 H20 Z" fill="none" stroke="currentColor" stroke-width="6" />

							<rect x="35" y="15" width="30" height="25" fill="none" stroke="currentColor" stroke-width="4" />

							<rect x="30" y="55" width="40" height="30" fill="none" stroke="currentColor" stroke-width="4" />
							<rect x="55" y="60" width="10" height="20" fill="currentColor" />
						</svg>

					</button>-->
					<!--Remove Track Button ◸-->
					<button class="sq-btn dimmer" onclick="removeTrackRelative(event,+1)" title="Remove Track Above/Left">
						<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
							<path d="M100,50 L50,50 L50,100 Z" fill="none" stroke="currentColor" stroke-width="6" />
						</svg>
					</button>
					<!--UP BUTTON-->
					<button class="sq-btn dim" onclick="moveActiveCard(event, 'up')" title="Move Up">
						<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
							<polygon points="10,80 50,10 90,80" fill="currentColor" />
						</svg>
					</button>
					<!--Add Track Button ◥-->
					<button class="sq-btn dimmer" onclick="addTrackRelative(event,+1)" title="Add Track Above/Right">
						<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
							<polygon points="50,100 50,50 0,50" fill="currentColor" />
						</svg>
					</button>



					<button class="sq-btn dimmer"></button>
					<button class="sq-btn dimmer" onclick="createCard()" title="Random Draw">
						<svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
							<path d="M12 3L19 7L12 11L5 7L12 3Z" fill="currentColor" fill-opacity="0.3" stroke="currentColor"
								stroke-width="1.5" stroke-linejoin="round" />
							<path d="M12 11L19 7V15L12 19V11Z" fill="currentColor" fill-opacity="0.1" stroke="currentColor"
								stroke-width="1.5" stroke-linejoin="round" />
							<path d="M5 7L12 11V19L5 15V7Z" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round" />
							<circle cx="12" cy="7" r="1" fill="currentColor" />
							<circle cx="7" cy="11" r="1" fill="currentColor" />
							<circle cx="10" cy="15" r="1" fill="currentColor" />
							<circle cx="14" cy="15" r="1" fill="currentColor" />
							<circle cx="15.5" cy="13" r="1" fill="currentColor" />
							<circle cx="17" cy="11" r="1" fill="currentColor" />
						</svg>
					</button>

					<!--Auto Flush Mode Button ↻-->
					<button id="auto-flush-btn" class="sq-btn action-btn auto-flush-btn" onclick="toggleAutoFlush(event)">
						<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
							<path d="M75,30 C65,15 35,15 25,30 M25,70 C35,85 65,85 75,70" fill="none" stroke="currentColor"
								stroke-width="8" stroke-linecap="round" />
							<polygon points="70,12 88,28 68,40" fill="currentColor" />
							<polygon points="30,88 12,72 32,60" fill="currentColor" />
						</svg>
					</button>
					<!--Tags Button-->
					<button class="sq-btn dimmer " onclick="toggleTagCloud(event)" title="Tags">
						<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
							stroke-linecap="round" stroke-linejoin="round">
							<line x1="4" y1="9" x2="20" y2="9"></line>
							<line x1="4" y1="15" x2="20" y2="15"></line>
							<line x1="10" y1="3" x2="8" y2="21"></line>
							<line x1="16" y1="3" x2="14" y2="21"></line>
						</svg>
					</button>


					<!--LEFT BUTTON-->
					<button class="sq-btn dim" onclick="moveActiveCard(event,'left')" title="Move Left">
						<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
							<polygon points="80,10 10,50 80,90" fill="currentColor" />
						</svg>
					</button>
					<!--Scroll Orientation Button-->
					<button id="mode-toggle" class="sq-btn dimmer" onclick="toggleScrollMode(event)" title="Scroll Direction">
						<div class="icon-h"></div>
					</button>
					<!--RIGHT BUTTON-->
					<button class="sq-btn dim" onclick="moveActiveCard(event,'right')" title="Move Right">
						<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
							<polygon points="20,10 90,50 20,90" fill="currentColor" />
						</svg>
					</button>
					<!--Set Wallpaper Button-->
					<button class="sq-btn dimmer" onclick="setCenteredAsWallpaper(event)" title="Set Active Card as Wallpaper">
						<svg viewBox="0 0 100 100" class="icon-svg">

							<rect x="15" y="20" width="70" height="60" rx="5" fill="none" stroke="currentColor" stroke-width="6" />
							<path d="M15,70 L35,45 L55,70 L70,55 L85,75" stroke="currentColor" stroke-width="6" stroke-linecap="round"
								fill="none" stroke-linejoin="round" />
							<circle cx="65" cy="40" r="6" fill="currentColor" />
						</svg>
						<!--<div class="css-wall"></div>-->
					</button>
					<!--Remove Mode Button-->
					<button id="remove-mode-btn" class="sq-btn action-btn removal-mode-btn" onclick="toggleRemovalMode(this)"
						ondblclick="clearWorkspace(event)" title="Toggle Removal Mode">
						<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
							<path d="M20,20 L80,80 M80,20 L20,80" fill="none" stroke="currentColor" stroke-width="8" />
						</svg>
					</button>
					<!--Clear Workspace-->
					<!--<button class="sq-btn dim" onclick="clearWorkspace(event)">CW</button>-->
					<!--Show/Hide Custom Buttons-->
					<button class="sq-btn dimmer" onclick="toggleAllBlockByID(event,'custom-buttons')"
						title="Toggle custom buttons"></button>
					<!--Listing Button-->
					<button class="sq-btn dimmer" onclick="toggleImages(event)" title="Listing">
						<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<rect x="3" y="3" width="7" height="7"></rect>
							<rect x="14" y="3" width="7" height="7"></rect>
							<rect x="14" y="14" width="7" height="7"></rect>
							<rect x="3" y="14" width="7" height="7"></rect>
						</svg>
					</button>
					<!--Add Track Button ◣-->
					<button class="sq-btn dimmer" onclick="addTrackRelative(event,-1)" title="Add Track Below/Left">
						<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
							<polygon points="50,0 50,50 100,50" fill="currentColor" />
						</svg>
					</button>
					<!--DOWN BUTTON-->
					<button class="sq-btn dim" onclick="moveActiveCard(event,'down')" title="Move Down">
						<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
							<polygon points="10,20 50,90 90,20" fill="currentColor" />
						</svg>
					</button>
					<!--Remove Track Button ◿-->
					<button class="sq-btn dimmer" onclick="removeTrackRelative(event,-1)" title="Add Track Below/Right">
						<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
							<path d="M50,0 L50,50 L0,50 Z" fill="none" stroke="currentColor" stroke-width="6" />
						</svg>
					</button>
					<!--NOTES BUTTON-->
					<button class="sq-btn dimmer" id="settings-btn" onclick="toggleCommandPanel(event)">
						<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
							<rect x="20" y="15" width="60" height="70" rx="5" fill="none" stroke="currentColor" stroke-width="6" />

							<line x1="35" y1="35" x2="65" y2="35" stroke="currentColor" stroke-width="6" stroke-linecap="round" />
							<line x1="35" y1="50" x2="65" y2="50" stroke="currentColor" stroke-width="6" stroke-linecap="round" />
							<line x1="35" y1="65" x2="55" y2="65" stroke="currentColor" stroke-width="6" stroke-linecap="round" />
						</svg>
					</button>

					<!--Show/Hide Custom Buttons-->
					<button class="sq-btn dimmer" onclick="toggleAllBlockByID(event,'custom-buttons')"
						title="Toggle custom buttons"></button>
				</div>
			</div>
			<div id="custom-buttons-old" style="display:none;">
				<div class="button-grid">
					<button class="sq-btn dimmer" onclick="toggleAllBlockByID(event,'button-palette')"
						title="Toggle Button Grid"></button>
					<button class="sq-btn dimmer">A</button>
					<button class="sq-btn dimmer">B</button>
					<button class="sq-btn dimmer">C</button>
					<button class="sq-btn dimmer">D</button>
					<button class="sq-btn dimmer">E</button>
					<button class="sq-btn dimmer" onclick="toggleAllBlockByID(event,'button-palette')"
						title="Toggle Button Pallete"></button>
				</div>
			</div>
		</div>
	</div>
	<div id="command-panel" class="hidden" style="display:none">
		<!--Float Right Elements-->
		<button class="tool-btn settings-close" onclick="toggleCommandPanel(event)" style="float:right">×</button>
		<a class="tool-btn" target="_blank" title="Log Bugs" style="float: right;height:24px;width:24px;margin-right:5px"
			href="https://docs.google.com/forms/d/e/1FAIpQLSeOpcxl7lS3R84J0P3cYZEbkRapkrcpTrRAtWA8HCiOTl6nTw/viewform">
			<svg viewBox="-3 -3 30 30" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
				stroke-linejoin="round">
				<path d="M4 4h16c1.1 0 2 0.9 2 2v12c0 1.1-0.9 2-2 2H4c-1.1 0-2-0.9-2-2V6c0-1.1 0.9-2 2-2z"></path>
				<polyline points="22,6 12,13 2,6"></polyline>
			</svg>
		</a>
		<a href="https://magicbakery.github.io/?id=P202512210026" target="_blank" rel="noopener noreferrer"
			class="tool-btn bakery-link" style="float: right;height:24px;width:24px;margin-right:5px" title="Visit Homepage">
			<svg viewBox="-3 -3 30 30" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
				stroke-linejoin="round">
				<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
				<polyline points="9 22 9 12 15 12 15 22"></polyline>
			</svg>
		</a>

		<div class="panel-tabs">
			<div class="active-preview-container">
				<img id="active-preview-thumb" class="save-notes-btn" src="" referrerpolicy="no-referrer" alt="" style="display: none;"
					onclick="saveCardNotes(event)" title="Save changes to this card">
				<button class="tab-btn" onclick="toggleTab(event,'tab-card-notes')" title="Details">
					<svg width="24" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2"
						stroke-linecap="round">
						<line x1="3" y1="6" x2="21" y2="6"></line>
						<line x1="3" y1="12" x2="15" y2="12"></line>
						<line x1="3" y1="18" x2="11" y2="18"></line>
					</svg>
				</button>


				<!--<button class="tab-btn save-notes-btn" onclick="saveCardNotes(event)" title="Save">
					<svg viewBox="0 0 100 100" style="width:16px; height:16px;">
					<path d="M20,15 H70 L85,30 V85 H20 Z" fill="none" stroke="currentColor" stroke-width="6" />

					<rect x="35" y="15" width="30" height="25" fill="none" stroke="currentColor" stroke-width="4" />

					<rect x="30" y="55" width="40" height="30" fill="none" stroke="currentColor" stroke-width="4" />
					<rect x="55" y="60" width="10" height="20" fill="currentColor" />
				</svg>
				</button>-->
			</div>
			<!--<button class="tab-btn" onclick="toggleTab(event,'tab-card-tags')">Tags</button>-->
			<button class="tab-btn" onclick="toggleTab(event,'tab-controls')" title="Controls">
				<svg width="24" height="18" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"
					style="transform: scale(1.4);">
					<path d="M12 9.5L9 6.5V3H15V6.5L12 9.5Z" stroke="currentColor" stroke-width="1" stroke-linejoin="round" />
					<path d="M12 14.5L15 17.5V21H9V17.5L12 14.5Z" stroke="currentColor" stroke-width="1"
						stroke-linejoin="round" />
					<path d="M9.5 12L6.5 15H3V9H6.5L9.5 12Z" stroke="currentColor" stroke-width="1" stroke-linejoin="round" />
					<path d="M14.5 12L17.5 9H21V15H17.5L14.5 12Z" stroke="currentColor" stroke-width="1"
						stroke-linejoin="round" />
				</svg>
			</button>
			<button class="tab-btn" onclick="toggleTab(event,'tab-dev-notes')">
				<svg width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
					stroke-linecap="round" stroke-linejoin="round" style="transform: scale(1.1);">
					<path d="M12 3v3m0 12v3M5.3 5.3l2.1 2.1m9.2 9.2l2.1 2.1M3 12h3m12 0h3m-15.7 6.7l2.1-2.1m9.2-9.2l2.1-2.1"
						opacity="0.5" />
					<path d="M12 8l-1 4-4 1 4 1 1 4 1-4 4-1-4-1-1-4z" />
				</svg>
			</button>
		</div>
		<div class="tabs-contents">

			<div id="tab-card-notes"
				onkeydown="if (event.key.toLowerCase() === 's' && (event.ctrlKey || event.metaKey)) {event.preventDefault();saveCardNotes(event);}">
				<div id="card-tag-section" class="active">
					<div id="card-tag-list" class="tag-cloud" style="padding:5px 0px"></div>
					<input type="text" id="assign-tag-input" placeholder="Add Tag" style="display:none" enterkeyhint="go"
						inputmode="text" oninput="updateAssignmentUI()" onkeydown="handleTagKey(event)">
					
				</div>				
				<div style="display:flex">
					<input type="text" id="card-title" class="active" placeholder="Display Title" title="Title (n)" style="flex:3">
					<input type="text" id="card-id" class="active" placeholder="Unique ID" title="Card ID (p)" style="flex:1;text-align: right;">
				</div>
				<div class="card-details">
					<input type="text" id="card-path-url" placeholder="URL / File Path" title="Path/URL (u)">
					<input type="text" id="card-img-url" style="flex: 1;min-width:25%" placeholder="Image Path"
							title="Image (i)">
					<div id="card-sprite-parameters">
						<div  style="display:flex">						
							<button class="scale-btn" onclick="ImageScale()" title="Scale the image">s</button>
							<input type="number" id="card-scale" placeholder="scale" title="scale (pixels per 1m)"
								style="min-width:60px;max-width:34%;text-align: center;">
							<button class="flip-btn" onclick="ImageFlip()" title="Flip the image">x</button>
							<input type="number" id="card-x-offset" placeholder="x-offset"
								title="x-offset from left edge to center for flipping (px)"
								style="min-width:60px;max-width:34%;text-align: center;">
							<button class="ground-btn" onclick="ImageGround()" title="Ground the image">y</button>
							<input type="number" id="card-y-offset" placeholder="y-offset"
								title="y-offset from bottom edge to ground (px)" style="min-width:60px;max-width:34%;text-align: center;">

						</div>
					</div>
					
				</div>
				
				<div class="notes-panel">
					<div style="float:right;margin-bottom:2px">
						<button class="notes-btn" onclick="ScriptStart()" title="Run as Script">Run</button>
						<button class="notes-btn" onclick="PanelTextareaResize(this)"
							title="Notes/Script Display Ratio">3:1</button>
						<button class="notes-btn" onclick="PanelTextareaResizeH(this)"
						title="Change Editor Height">H1</button>
						<button class="notes-btn" style="width:55px" onclick="ScriptPublish(this)"
							title="Publish Script">Publish</button>
					</div>

					<button class="notes-btn" onclick="NoteLineSwap(true)" title="Move line up">
						<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
							<polygon points="0,100 50,10 100,100" fill="currentColor" />
						</svg>
					</button>
					<button class="notes-btn" onclick="NoteLineSwap(false)" title="Move line down">
						<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
							<polygon points="0,10 50,100 100,10" fill="currentColor" />
						</svg>
					</button>
					<button class="notes-btn" onclick="NoteInsertDTS()" title="Insert Timestamp">DTS</button>
					<div id="card-textareas" style="display:flex;clear:right" class="active">
						<textarea id="card-notes" class="card-textarea active" onfocus="PanelTextareaActivate(this)"
							oninput="markDirty(this)" style="flex: 3 3 0%" placeholder="User Notes"></textarea>
						<textarea id="card-script" class="card-textarea active" onfocus="PanelTextareaActivate(this)"
							oninput="markDirty(this)" style="flex: 1 1 0%;color:limegreen" placeholder="Public Script"></textarea>
					</div>
				</div>
				<div style="text-align:center;margin-top:5px">
					<button class="sec-btn on" onclick="ToggleByID(this,'card-tag-section')"	title="Card Tags (t)">#</button>
					<button class="sec-btn on" onclick="ToggleByID(this,'card-title')"	title="Card Title (n)">n</button>
					<button class="sec-btn on" onclick="ToggleByID(this,'card-id')"	title="Card ID (p)">id</button>
					<button class="sec-btn" onclick="ToggleByID(this,'card-path-url')"	title="Card URL (u)">u</button>
					<button class="sec-btn" onclick="ToggleByID(this,'card-img-url')"	title="Card Cover Image (i)">i</button>
					<button class="sec-btn" onclick="ToggleByID(this,'card-sprite-parameters')"	title="Card Sprite Parameters (s, x, y)">s</button>
					<button class="sec-btn on" onclick="ToggleByID(this,'card-notes')"	title="Card Notes (o)">o</button>
					<button class="sec-btn on" onclick="ToggleByID(this,'card-script')"	title="Card Script (c)">c</button>
				</div>
				
				<!--<div onclick="toggleNodeDetails(this)" style="text-align: center;width:100%;height:40px;color:grey">▽</div>-->
				

			</div>
			<div id="tab-card-tags" class="tab-content" style="display:none">



			</div>
			<div id="tab-controls" class="tab-content" style="display:none">

				<div style="display:flex;">
					<div class="button-pad left"
						style="flex:1;display:flex;flex-wrap:wrap-reverse;justify-content: flex-start;flex-direction:column;height:108px;overflow-x:auto;box-sizing: content-box;align-items: flex-end;align-content: flex-start;scrollbar-width: none; -ms-overflow-style: none;">
						<!--Random Draw-->
						<button class="tool-btn half auto-random-btn" onclick="toggleAutoRandom()" title="Random Draw">
							<svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
								<path d="M12 3L19 7L12 11L5 7L12 3Z" fill="currentColor" fill-opacity="0.3" stroke="currentColor"
									stroke-width="1.5" stroke-linejoin="round" />
								<path d="M12 11L19 7V15L12 19V11Z" fill="currentColor" fill-opacity="0.1" stroke="currentColor"
									stroke-width="1.5" stroke-linejoin="round" />
								<path d="M5 7L12 11V19L5 15V7Z" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round" />
								<circle cx="12" cy="7" r="1" fill="currentColor" />
								<circle cx="7" cy="11" r="1" fill="currentColor" />
								<circle cx="10" cy="15" r="1" fill="currentColor" />
								<circle cx="14" cy="15" r="1" fill="currentColor" />
								<circle cx="15.5" cy="13" r="1" fill="currentColor" />
								<circle cx="17" cy="11" r="1" fill="currentColor" />
							</svg>
						</button>
						<!--Auto Flush Mode Button ↻-->
						<button class="tool-btn half auto-flush-btn" onclick="toggleAutoFlush(event)">
							<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
								<path d="M75,30 C65,15 35,15 25,30 M25,70 C35,85 65,85 75,70" fill="none" stroke="currentColor"
									stroke-width="8" stroke-linecap="round" />
								<polygon points="70,12 88,28 68,40" fill="currentColor" />
								<polygon points="30,88 12,72 32,60" fill="currentColor" />
							</svg>
						</button>
						<!--Star Button-->
						<button class="tool-btn half star-btn" onclick="togglePinActiveCard(event)" title="Star Active Card">
							<svg viewBox="0 0 24 24" width="36" height="36" fill="currentColor" stroke="currentColor" stroke-width="2"
								stroke-linejoin="round">
								<path
									d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
							</svg>
						</button>
						<!--Removal Mode Button-->
						<button class="tool-btn half removal-mode-btn" onclick="toggleRemovalMode(this)"
							ondblclick="clearWorkspace(event)" title="Toggle Removal Mode">
							<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
								<path d="M20,20 L80,80 M80,20 L20,80" fill="none" stroke="currentColor" stroke-width="8" />
							</svg>
						</button>
						<button class="tool-btn half" title="Create a blank card" onClick="createCard(null,true)">C+</button>
						<button class="tool-btn half" title="Toggle Speech Bubble" onClick="SpeechBubbleShow()">SB</button>
						<button class="tool-btn half" title="Focus on this Track" onClick="TrackFocus(this)">TF</button>
						<button class="tool-btn half" title="Show Tracks" onClick="showAllTracks()">TR</button>
						<button class="tool-btn half" title="Expand Track" onClick="activeTrackWidth(1)">T+</button>
						<button class="tool-btn half" title="Shrink Track" onClick="activeTrackWidth(-1)">T-</button>
						<button class="tool-btn half" title="Move Track to Next" onClick="TrackMove(true)">TN</button>
						<button class="tool-btn half" title="Move Track to Previous" onClick="TrackMove(false)">TP</button>


						<!--<button class="tool-btn full">L1</button>-->
						<!--<button class="tool-btn half">L2</button>-->
						<!--<button class="tool-btn half">L3</button>-->
						<!--<button class="tool-btn half">L4</button>-->
						<!--<button class="tool-btn half">L5</button>-->
						<button class="tool-btn">L6</button>
						<button class="tool-btn">L7</button>
						<button class="tool-btn">L8</button>
						<button class="tool-btn">L9</button>
						<button class="tool-btn">L10</button>
						<button class="tool-btn">L11</button>
						<button class="tool-btn">L12</button>
						<button class="tool-btn">L13</button>
						<button class="tool-btn">L14</button>
						<button class="tool-btn half">L15</button>
						<button class="tool-btn half">L16</button>
						<button class="tool-btn half">L17</button>
						<button class="tool-btn half">L18</button>
						<button class="tool-btn full">L19</button>
					</div>
					<div style="display:flex;flex-wrap:wrap;flex:0 0 auto;justify-content: center;width:120px;height:108px;">
						<!--Remove Track Button ◸-->
						<button class="tool-btn" onclick="removeTrackRelative(event,+1)" title="Remove Track Above/Left">
							<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
								<path d="M100,50 L50,50 L50,100 Z" fill="none" stroke="currentColor" stroke-width="6" />
							</svg>
						</button>
						<!--UP BUTTON-->
						<button class="tool-btn" onclick="moveActiveCard(event, 'up')" title="Move Up">
							<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
								<polygon points="10,80 50,10 90,80" fill="white" />
							</svg>
						</button>
						<!--Add Track Button ◥-->
						<button class="tool-btn" onclick="addTrackRelative(event,+1)" title="Add Track Above/Right">
							<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
								<polygon points="50,100 50,50 0,50" fill="currentColor" />
							</svg>
						</button>
						<div style="flex-basis:100%;height:0"></div>
						<!--LEFT BUTTON-->
						<button class="tool-btn" onclick="moveActiveCard(event,'left')" title="Move Left">
							<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
								<polygon points="80,10 10,50 80,90" fill="white" />
							</svg>
						</button>
						<!--Scroll Orientation Button-->
						<button id="mode-toggle" class="tool-btn" onclick="toggleScrollMode(event)" title="Scroll Direction">
							<div class="icon-h"></div>
						</button>
						<!--RIGHT BUTTON-->
						<button class="tool-btn" onclick="moveActiveCard(event,'right')" title="Move Right">
							<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
								<polygon points="20,10 90,50 20,90" fill="white" />
							</svg>
						</button>
						<div style="flex-basis:100%;height:0"></div>
						<!--Add Track Button ◣-->
						<button class="tool-btn" onclick="addTrackRelative(event,-1)" title="Add Track Below/Left">
							<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
								<polygon points="50,0 50,50 100,50" fill="currentColor" />
							</svg>
						</button>
						<!--DOWN BUTTON-->
						<button class="tool-btn" onclick="moveActiveCard(event,'down')" title="Move Down">
							<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
								<polygon points="10,20 50,90 90,20" fill="white" />
							</svg>
						</button>
						<!--Remove Track Button ◿-->
						<button class="tool-btn" onclick="removeTrackRelative(event,-1)" title="Add Track Below/Right">
							<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
								<path d="M50,0 L50,50 L0,50 Z" fill="none" stroke="currentColor" stroke-width="6" />
							</svg>
						</button>
					</div>
					<div class="button-pad right custom-buttons"
						style="flex:1;display:flex;flex-wrap:wrap;justify-content: center;flex-direction:column;height:108px;overflow-x:auto;box-sizing: content-box;align-items: flex-start; scrollbar-width: none; -ms-overflow-style: none;align-content: flex-start">
						<!--Next Button-->
						<button class="tool-btn full script-step-btn" onClick="ScriptStart(this)" title="Play Script">
							<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"
								style="transform: scale(3)" title="Next">
								<rect x="17" y="5" width="2" height="14" rx="1" fill="currentColor" />
								<polygon points="5,5 15,12 5,19" fill="currentColor" />
							</svg>
						</button>

						<!--<button class="tool-btn full">R1</button>-->
						<button class="tool-btn half">R2</button>
						<button class="tool-btn half">R3</button>
						<button class="tool-btn half">R4</button>
						<button class="tool-btn half">R5</button>
						<button class="tool-btn">R6</button>
						<button class="tool-btn">R7</button>
						<button class="tool-btn">R8</button>
						<button class="tool-btn">R9</button>
						<button class="tool-btn">R10</button>
						<button class="tool-btn">R11</button>
						<button class="tool-btn">R12</button>
						<button class="tool-btn">R13</button>
						<button class="tool-btn">R14</button>
						<button class="tool-btn half">R15</button>
						<button class="tool-btn half">R16</button>
						<button class="tool-btn half">R17</button>
						<button class="tool-btn half">R18</button>
						<button class="tool-btn full" onClink="getActiveCard()?.classList.toggle('2s');">R19</button>
					</div>
				</div>




			</div>
			<div id="tab-dev-notes" style="display:none;padding-bottom:40px">
				<div style="display:flex; gap:5px; align-items:center;">
					<a id="add-btn" href="#" target="_blank" class="sq-btn action-btn" onclick="handleLinkAction(event)">+</a>
					<input type="text" id="add-url-input" class="unified-width" placeholder="URL for + button..."
						oninput="updateAddUrl(this.value)">
				</div>
				<input type="text" id="dev-command" class="unified-width" placeholder="Command..." oninput="memDEV()"
					onkeydown="if (event.key === 'Enter' || event.keyCode === 13) {event.preventDefault(); processScriptLine(this.value)}">
				<textarea id="user-note" class="unified-width card-textarea"
					style="resize:none;height:172px; margin-bottom:5px;font-size:16px;overflow-y: auto;" placeholder="NOTES..."
					oninput="saveNotes(this.value)"></textarea>


			</div>

		</div>
	</div>
	<div id="stage-area" class="stage-area">
	</div>

	<div id="stage-ui" class="stage-ui">
		<div class="stage-next-btn" onclick="ScriptRun()">
			<svg viewBox="0 0 24 24" width="40" fill="white">
				<path d="M8 5v14l11-7z" />
			</svg>
		</div>
	</div>
	<div id="dialogue-overlay" class="dialogue-overlay">
		<div class="speech-bubble">
			<button class="close-dialog-btn" onclick="SpeechBubbleShow(false)">
				<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
					<path d="M5 12L10 19L19 7" stroke="currentColor" stroke-width="5" stroke-linecap="round"
						stroke-linejoin="round" />
				</svg>
			</button>

			<div id="speech-text" class="speech-content"></div>
			<div id="choice-container" class="choice-row"></div>
		</div>
	</div>
	<div id="splash-screen" onclick="if(event.target === this) hideSplash()">
		<img id="splash-img" src="" alt="Enlarged View">
	</div>
	<!--
	<div class="bottom-menu-container" id="bottom-nav">
		<button class="semi-circle-btn" onclick="toggleBottomMenu(event)" title="Show Action Bar">
			<div class="menu-icon-graphic">
				<span></span><span></span><span></span>
			</div>
		</button>
	</div>
	<div id="bottom-menu-items" class="bottom-menu-panel">		
		<button class="sq-btn dim" onclick="toggleRemovalMode(this)" title="Removal Mode">✕</button>	
		<button id="mode-toggle" class="sq-btn active-gold" onclick="toggleScrollMode()" title="Scroll Wheel Direction">
					<div class="icon-h"></div>
				</button>	
		<button class="sq-btn dim" onclick="toggleBottomMenu(event)" title="Close Action Bar"><div class="menu-icon-graphic">
				<span></span><span></span><span></span>
			</div></button> 
		<button class="sq-btn dim" style="margin:-30px 0px 30px 0px" onclick="" title="">&#9664;</button>
		<button class="sq-btn dim" onclick="" title=""></button>	
	</div>-->
	<!--Transparent Buttons-->

	<div id="loading-screen" onclick="fadeLoadingScreen(false)"></div>
	<div id="trigger-left" class="hover-trigger" onclick="handleCornerClick('left')">☰</div>
	<div id="trigger-right" class="hover-trigger" onclick="handleCornerClick('right')">☰</div>
	<div id="ghost-restore" onclick="toggleSidebar(true)">☰</div>
	<div id="custom-confirm" class="modal-overlay" style="display:none;">
		<div class="modal-content">
			<p id="confirm-text" style="color: white; margin-bottom: 20px;font-size:20px"></p>
			<div class="modal-btns">
				<button id="btn-yes" onclick="confirmChoice(true)" class="confirm-yes">Yes</button>
				&nbsp;&nbsp;&nbsp;
				<button id="btn-no" onclick="confirmChoice(false)" class="confirm-no">No</button>
			</div>
		</div>
	</div>
	<div id="toast"></div>
	<script>
		let DATA = [];
		let ALL_TAGS = [];
		let activeTags = new Set(), sidebarIsGrid = false, currentDock = 'right', autoFlush = false;
		let tagSortMode = 'alpha', savedPaths = [];

		window.onload = () => {
			initZLayers();

			// Inject the version code into the info link tooltip
			document.getElementById('version-link').title = "Ver." + APP_VERSION;

			// 1. Tag Sort Initialization (Future State)
			tagSortMode = localStorage.getItem('gallery_tag_sort') || 'alpha';
			const tagBtn = document.getElementById('tag-sort-btn');
			tagBtn.innerText = (tagSortMode === 'alpha') ? '1-9' : 'A-Z';
			tagBtn.className = 'inline-toggle action-btn';

			// 2. View Mode Initialization (Future State / Reversed)
			const savedMax = localStorage.getItem('gallery_is_max_width') === 'true';
			const bodyWrap = document.getElementById('body-wrap');
			const btn = document.getElementById('mode-toggle');

			if (savedMax) {
				bodyWrap.classList.add('max-width');
				if (btn) btn.innerHTML = '<div class="icon-v"></div>';
			} else {
				bodyWrap.classList.remove('max-width');
				if (btn) btn.innerHTML = '<div class="icon-h"></div>';
			}

			persistentWallpaper();
			initScrollDirection();

			// 3. Restore Sidebar Docking
			currentDock = localStorage.getItem('gallery_dock') || 'right';
			updateDock(currentDock);

			// 4. Restore Settings & Notes
			const n = localStorage.getItem('gallery_notes');
			if (n) document.getElementById('user-note').value = n;

			autoFlush = localStorage.getItem('gallery_flush') === 'true';
			document.body.classList.toggle("auto-flush", autoFlush);
			updateAutoFlushUI();



			// Restore Grid Columns
			const savedCols = localStorage.getItem('gallery_cols') || 3;
			document.documentElement.style.setProperty('--grid-cols', savedCols);
			document.getElementById('col-slider').value = savedCols;



			// Set initial slider visibility
			const container = document.getElementById('grid-slider-container');
			const icon = document.getElementById('toggle-icon');

			if (sidebarIsGrid) {
				container.style.display = 'flex';
				icon.className = 'css-list';
				icon.innerHTML = '<div></div><div></div><div></div>';
			} else {
				container.style.display = 'none';
				icon.className = 'css-grid';
				icon.innerHTML = '<div></div><div></div><div></div><div></div>';
			}


			const savedAddUrl = localStorage.getItem('gallery_add_url');
			if (savedAddUrl) {
				document.getElementById('add-url-input').value = savedAddUrl;
				document.getElementById('add-btn').href = savedAddUrl;
			}

			// Restore or initialize Collections
			const rawPaths = localStorage.getItem('gallery_paths');
			if (rawPaths) {
				savedPaths = JSON.parse(rawPaths).map(p => ({ ...p, data: null }));
			} else {
				// DEFAULT PATH: Starter Pack
				savedPaths = [{
					path: "https://magicbakery.github.io/starterpack.json",
					//path: "https://gist.githubusercontent.com/MagicBakery/5f922bc0fe8b3eae4726e723aa15ad27/raw/",
					checked: true,
					data: null
				}];
			}

			renderPathList();
			// Load data for all checked paths
			savedPaths.forEach((item, index) => {
				if (item.checked && (item.path.startsWith('http'))) {
					importFromURL(item.path);
				}
			});

			// STEP: Content ready to be shown			
			summonQuickCast();
			summonFairyQueen();
			summonGateGuardian();


		};
		/* #ALPHABETICALLY SORTED CODE */
		const zLayers = ['Notifications', 'LoadingScreen', 'TransparentControls', 'ExamineScreen', 'SpeechBubble', 'StageGUI', 'Stage', 'GUIControls', 'Listings', 'Gallery', 'AppWallpaper'];
		const assetLibrary = {}; // { "key1": AudioObject }
		

		let autoRandomTimer = null;
		let autoRandomTrack = null;
		let firstLoad = true; // 20260203: To process URL param just once.
		const injectedCSS = new Set();
		let isRemovalMode = false; /* 20251226: StarTree: Used for the Removal button */
		let resolveConfirm = null;
		const soundMap = {};    // { "Name": Set(["key1", "key2"]) }
		let SFXTrack1 = null;		// Sound Track Channel 1.

		// FOR ZOOMING:
		// Persistent state (Global)
		let initialDist = 0;
		let scale = 1; // Usually used for zoom
		// Interaction anchors (Global)
		let startX = 0;
		let startY = 0;




		function addButton(label, size, script) {
			const container = document.querySelector('.custom-buttons');
			if (!container) return;

			// 1. Cleanup: Remove existing buttons that don't have an 'onclick' attribute
			const legacyButtons = container.querySelectorAll('button:not([onclick])');
			legacyButtons.forEach(btn => btn.remove());

			// 2. Create the new button
			const newBtn = document.createElement('button');
			newBtn.className = 'tool-btn ' + size.toLowerCase();

			// 3. Set the Label (supports SVG or Text)
			newBtn.innerHTML = label;

			// 4. Set the Logic
			// We wrap the script in a string for the attribute
			newBtn.setAttribute('onclick', script);

			// 5. Add to the container
			container.appendChild(newBtn);
		}
		function ActorData(name, filters) {
			// 20260125: Tanya: Returns the DATA item that has the actor image data.
			if (typeof filters === 'string') filters = filters.split(' ');
			name = name.toUpperCase();
			let topMatches = [];
			let topScore = -1;
			// For each item in DATA, find one that has "[ACTOR]" tag and "NAME" tag.
			// Skip the ones that don't even have those two required tags.
			// Then check each tag in filters one by one, if it has it, increment its matching score. If it scores equal to the current topMatch, add it to the list of topMatches.
			// If it scores higher, flush the current topMatches and add it as the only.

			DATA.forEach(item => {
				// 1. Mandatory Tag Check
				// Assuming item.tags is an array. If it's a string, use item.tags.includes()
				const tags = item.t || [];
				const hasActorTag = tags.includes('[ACTOR]');
				const hasNameTag = tags.includes(name);
				if (!hasActorTag || !hasNameTag) return;
				// 2. Scoring Logic
				let currentScore = 0;
				filters.forEach(f => {
					if (tags.includes(f)) {
						currentScore++;
					}
				});
				// 3. Comparison Logic
				if (currentScore > topScore) {
					// Higher score found: Flush and replace
					topScore = currentScore;
					topMatches = [item];
				} else if (currentScore === topScore) {
					// Equal score: Add to pool
					topMatches.push(item);
				}
			});
			if (topMatches.length === 0) return null;
			const randomIndex = Math.floor(Math.random() * topMatches.length);
			return topMatches[randomIndex];
		}
		function ActorSet(command) {
			// 20260125: Evelyn: Process a script command line that starts with @.
			// Here the @ at the beginning is already removed.
			// STEP: Get the name of the actor.
			let actorName = command.leftOf(' ').trim();
			let rest = command.rightOf(actorName).trim();

			if (!actorName) { DEBUG("Actor is missing in: @" + command); }
			// STEP: If the actor is not already on stage, bring it on stage.
			const elStage = document.getElementById('stage-area');
			let actor = elStage.querySelector(`.actor[data-name="${actorName}" i]`);
			let filters = [];

			// If the command is it get the actor off stage
			let arg1 = rest.toUpperCase();
			if (rest === '!OFF') { if (actor) { actor.remove(); } return true; }

			if (!actor) {
				actor = document.createElement('div');
				const img = document.createElement('img');
				actor.className = 'actor';
				actor.dataset.name = actorName;
				const actorData = ActorData(actorName, filters);

				if (actorData) {
					actor.dataset.p = actorData.p;
					actor.dataset.i = getFullResURL(actorData.u);
					img.src = actor.dataset.i;
					img.dataset.s = actorData.s || 700;
					img.dataset.x = actorData.x || (img.naturalWidth / 2);
					img.dataset.y = actorData.y || 0;
				}
				// Make the img code inside the actor div, and run SpriteOnStage for the img.
				actor.append(img);
				elStage.append(actor);
				let rndX =0;
				if(actorData.s > 0){rndX= Math.random()*40;	}
				if (actorData.x >= 0) {
					// Enter from right and face left.
					SpriteOnStage(img, rndX, 0, true, true, true);
				} else {
					// Enter from left and face right.
					SpriteOnStage(img, -rndX, 0, true, false, true);
				}
			}


			// STEP: Clear the active status of all other actors on stage, and set this to be active.
			elStage.querySelectorAll('.actor').forEach(a => { a.classList.remove('active'); });
			actor.classList.add('active');
			// STEP: Process the rest of the command		
			if(rest == '')	{
				SpeechBubbleShow(false);
				return false;
			}
			return processScriptLine(rest);
		}
		function ChoiceAdd(choice) {
			// 20260118: StarTree: Adds a choice to the multitrack DOM so that it is easy to debug, save and load.
			const forbiddenChars = /[\s"'><\/=]/;
			if (forbiddenChars.test(choice)) {
				DEBUG("RETURN: Choice contains invalid attribute characters.", true);
				return;
			}
			Multitrack()?.setAttribute(ChoiceName(choice), '');

			DEBUG('@@ChoiceAdd: ' + ChoiceName(choice), true);
			memDOM();
		}
		function ChoiceCheck(choice) {
			// 20260118: StarTree: Returns true if the choice is active.
			return Multitrack()?.hasAttribute(ChoiceName(choice));
		}
		function ChoiceCommit() {
			const entry = document.querySelector('.choice-entry.selected');
			if (!entry) return false;
			entry.classList.remove('selected');

			// Reset the narration streak
			const bubble = document.querySelector('.speech-bubble');
			bubble.classList.remove('narrative-mode');

			const code = entry.dataset.code;
			const choiceList = document.getElementById('choice-container');
			choiceList.classList.remove('active');			
			ChoiceAdd(code);
			ChoiceBubblePop(null, true);
			ScriptBubbleSpawning(null, true);

			return true;
		}
		function ChoiceEntry(code, choiceText) {
			const div = document.createElement('div');
			div.className = 'choice-entry';
			div.dataset.code = code;
			const content = `
				<span class="choice-label">${choiceText}</span>
				<div class="choice-actions">
					<!--<button class="confirm-btn" onclick="ChoiceCommit('${code}')">✔</button>-->
					<!--<button class="dismiss-btn" onclick="this.parentElement.parentElement.remove()">✖</button>-->
				</div>
			`;
			div.innerHTML = content;
			div.onclick = (e) => {
				// Prevent the buttons from triggering the "bump" logic
				if (e.target.tagName === 'BUTTON') return;

				const isAlreadySelected = div.classList.contains('selected');

				if (!isAlreadySelected) {
					// Step A: Deselect others and highlight this one soft gold
					document.querySelectorAll('.choice-entry').forEach(el => el.classList.remove('selected'));
					div.classList.add('selected');
				} else {
					// Just move up one slot.
					const previous = div.previousElementSibling;
					if (previous && previous.classList.contains('choice-entry')) {
						previous.before(div);
						div.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
						div.animate([{ transform: 'scale(1.05)' }, { transform: 'scale(1)' }], { duration: 200 });
					}
					/*// Step B: If clicked again while selected, bump to top
					const parent = div.parentElement;
					parent.prepend(div);*/
					// Optional: Add a little "bump" animation

				}
			};

			return div;
		}
		function ChoiceName(choice) {
			// 20260118: StarTree: Returns the attribute name for embedding the choice
			return "choice-" + choice.toLowerCase();
		}
		function ChoiceRemove(choice, bAll) {
			// 20260118: StarTree: Removes a choice embedded in multitrack
			const multitrack = Multitrack();
			if (bAll) {
				const toRemove = Array.from(multitrack.attributes)
					.map(attr => attr.name)
					.filter(name => name.startsWith('choice-'));

				toRemove?.forEach(name => multitrack.removeAttribute(name));
			} else {
				multitrack?.removeAttribute(ChoiceName(choice));
			}
			memDOM();
			return true;
		}
		function ChoiceBubblePop(bubble, popAll) {
			// 20260119: Skyle: Pops choice bubbles.
			if (popAll) {
				const choiceBubbles = document.querySelectorAll(".choice-bubble");
				choiceBubbles.forEach(i => { i.remove(); });
			} else {
				bubble.closest(".choice-bubble").remove();
			}
		}
		function ChoiceBubbleSpawn(code, choiceText) {
			// 20260119: LRRH: Enter spawning mode
			const scriptEngine = ScriptEngine();
			scriptEngine.setAttribute('SE-BubbleSpawning', '');
			const bubble = document.createElement('div');
			bubble.className = 'choice-bubble';
			bubble.innerText = ''; // Nondescript at first

			// Random position within safe center area
			const top = Math.floor(Math.random() * 80 + 10); // 10% to 90%
			const left = Math.floor(Math.random() * 80 + 10); // 10% to 90%
			const size = Math.floor(Math.random() * 50 + 50);
			let r = Math.random() > 0.25 ? 255 : 0;
			let g = Math.random() > 0.25 ? 255 : 0;
			let b = Math.random() > 0.25 ? 255 : 0;
			if (r + g + b === 0) { r = 255; g = 255; b = 255; }


			//bubble.style.borderColor = `rgba(${r}, ${g}, ${b}, 0.15)`;
			bubble.style.background = `rgba(${r}, ${g}, ${b}, 0.1)`;
			bubble.style.width = `${size}px`;
			bubble.style.height = `${size}px`;
			bubble.style.top = `${top}vh`;
			bubble.style.left = `${left}vw`;
			bubble.dataset.code = code;
			bubble.dataset.choiceText = choiceText;
			document.body.appendChild(bubble);
		}
		function ChoiceListAppend(code,choiceText,bPrepend){
			const choiceList = document.getElementById('choice-container');
			choiceList.classList.add('active');
			const choiceEntry = ChoiceEntry(code, choiceText);
			if(bPrepend){
				choiceList.prepend(choiceEntry);
			}else{
				choiceList.append(choiceEntry);
			}			
			choiceEntry.scrollIntoView();
			ScriptEngine().setAttribute('SE-BubbleSpawning', '');
		}
		function DATABestMatch(requiredTags, optionalTags) {
			// 20260125: Sasha: Returns the best match in an array of items, where item.t has an array of tags in upper case.
			// Scoring: The candidate must have the required tags given in an array to have a score of 0. Then for each optional tag it has, add 1 point.
			// When the result candidate list has more than one item, pick one randomly.
			let candidates = [];
			let bestScore = -1;
			DATA.forEach(item => {
				const tags = item.t || [];
				const hasAllRequired = requiredTags.every(req => tags.includes(req.toUpperCase()));
				if (hasAllRequired) {
					// 2. Calculate Optional Score: +1 for every matching optional tag
					let currentScore = 0;
					optionalTags.forEach(opt => {
						if (tags.includes(opt.toUpperCase())) {
							currentScore++;
						}
					});

					// 3. Update Candidates List
					if (currentScore > bestScore) {
						// Found a new "Best" - clear the old ones and start fresh
						bestScore = currentScore;
						candidates = [item];
					} else if (currentScore === bestScore) {
						// Tied with current "Best" - add to the pool for random selection
						candidates.push(item);
					}
				}

			});
			if (candidates.length === 0) return null;
			const randomIndex = Math.floor(Math.random() * candidates.length);
			return candidates[randomIndex];
		}
		function DATAByID(id) {			
			return DATA.find(item => String(item.p) === String(id));
		}
		function DATAFullResURL(item) {
			// 20260119: Sasha: Given a DATA object, return the full res URL of its image.
			let imgURL = item.i;
			if (!imgURL || imgURL.trim() == "") { imgURL = item.u; }
			if (!imgURL || imgURL.trim() == "") { imgURL = item.p; }
			return getFullResURL(imgURL);
		}
		function DialogFormat(text) {
			text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
			text = text.replace(/\[url\]([^\[]+)\[\/url\]/gi, '<a href="$1" target="_blank">$1</a>');
			text = text.replace(/\[url=([^\]]+)\]([^\[]+)\[\/url\]/gi, (match, url, label) => {
				return `<a href="${url.trim()}" target="_blank" rel="noopener">${label}</a>`;
			});

			// 20260127: StarTree: Format some of the text to avoid allowing full html.
			//text = text.replaceAll("//","\n");

			return text;
		}
		function DEBUG(msg, bCompact) {
			// 20260125: Evelyn: Help locate where all the console log are and where they are called.
			if (bCompact) { console.log(msg); return; }
			const err = new Error();
			const stack = err.stack.split('\n');
			const callerLine = stack[2].trim();
			console.log(`[${callerLine}]`, msg);
			// Show Toast if the callierLine contains "file:///"
			if (callerLine.indexOf('file:///') > -1) {
				showToast(`[${callerLine}] ${msg}`);
			}
		}
		function DTS(){
			// 20260206: StarTree: Returns the local DTS timestamp.
			const now = new Date();
			const timestamp = now.getFullYear().toString() +
				(now.getMonth() + 1).toString().padStart(2, '0') +
				now.getDate().toString().padStart(2, '0') +
				now.getHours().toString().padStart(2, '0') +
				now.getMinutes().toString().padStart(2, '0') +
				now.getSeconds().toString().padStart(2, '0');
			return timestamp;
		}
		function exportMultiTrack() {
			// 20260104: Sasha: Export MultiTrack if it is not empty. If it is empty, import.
			const multiTrackDOM = document.getElementById('multitrack'); // Adjust ID to match your container
			if (!multiTrackDOM) {
				showToast("Error: MultiTrack container not found.");
				return;
			}
			const tracks = multiTrackDOM.querySelectorAll(".track");
			if (tracks.length <= 1 && tracks[0].innerHTML == "") {
				// The Multitrack section is empty. Switch to Import.
				importMultiTrackDOM();
				return;
			}
			const blob = new Blob([multiTrackDOM.outerHTML], { type: 'text/html' });
			const a = document.createElement('a');
			a.href = URL.createObjectURL(blob);
			a.download = `MultiTrack_${new Date().toISOString().slice(0, 10)}.dom`;

			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);

			showToast("MultiTrack HTML exported!");
		}
		function fadeLoadingScreen(bIn) {
			// 20251225: Tanya: Remove the loading screen after z-index are initialized.
			// 20251225: StarTree: bIn = false means fade out
			return new Promise((resolve) => {
				const curtain = document.getElementById('loading-screen');
				if (!curtain) return;
				if (bIn) {
					curtain.style.visibility = 'visible';
					curtain.style.display = "flex";
					curtain.style.opacity = '1';
					resolve();
				} else {
					curtain.style.visibility = 'hidden';
					curtain.style.opacity = '0';
					// Wait for the transition to finish (time defined in CSS)
					// then remove it from the layout entirely
					setTimeout(() => { curtain.style.display = 'none'; }, 1000);
				}
			});
		}
		function fairyActiveCardCheck(e) {
			// 20251226: StarTree: Set the card to be the active card if it is in multi track mode.
			// 20260108: LRRH: Clicking on a tag toggles it.
			const tagPill = e.target.closest('.tag-pill');
			if (tagPill) {
				e.stopPropagation();
				const t = tagPill.firstChild.textContent.trim();
				toggleTag(t);
				return true;
			}
			const tagList = e.target.closest('#card-tag-list');
			if (tagList) {
				e.stopPropagation();
				toggleAddTag(false);
				return true;
			}
			const file = e.target.closest('.file-item');
			if (file) {
				e.stopPropagation();
				const id = file.dataset.id;
				const item = DATA.find(i => i.p === id);
				if (item) {
					createCard(item);
				}
				return true;
			}
			const card = e.target.closest('.card');
			if (card) {
				e.stopPropagation();
				if (getActiveCard() == card) {
					if (isHidden("command-panel")) {
						toggleCommandPanel(e);
					} else {
						ScriptStart();
					}
				}
				setActiveCard(card);

				return true;
			}
			return false;
		}
		async function fairyBlessCheck(e) {
			const tag = document.getElementById('assign-tag-input').value.trim().toUpperCase();
			if (tag == "") { return false; }
			const file = e.target.closest('.file-item');
			const card = e.target.closest('.card');
			const track = e.target.closest('.track');

			// 1. Click on File in Sidebar
			if (file) {
				e.stopPropagation();
				const item = DATA.find(i => i.p === file.dataset.id);
				if (item && !item.t.includes(tag)) {
					item.t.push(tag);
					showToast(`Added [${tag}] to ${item.n}`);
					refreshAllUI();
				}
				return true;
			}

			// 2. Click on Card in Track
			if (card) {
				e.stopPropagation();
				const item = DATA.find(i => i.p === card.dataset.id);
				if (item && !item.t.includes(tag)) {
					item.t.push(tag);
					showToast(`Added [${tag}] to card`);
					refreshAllUI();
				}
				return true;
			}

			// 3. Click on Track (Background)
			if (track) {
				e.stopPropagation();
				const cards = Array.from(track.querySelectorAll('.card'));
				if (cards.length > 0) {
					const count = cards.length;
					if (await showConfirm(`Add tag [${tag}] to all ${count} cards in this track?`)) {
						cards.forEach(c => {
							const item = DATA.find(i => i.u === c.dataset.id);
							if (item && !item.t.includes(tag)) item.t.push(tag);
						});
						showToast(`Tagged track with [${tag}]`);
						refreshAllUI();
					}
				}
				return true;
			}

			return false;
		}
		async function fairyBubblePopping(e) {
			const bubble = e.target.closest('.choice-bubble');
			if (!bubble) return false;
			e.stopPropagation();
			// 20250119: Evelyn: If a bubble is clicked, add its choice to the main bubble and remove the bubble itself.				
			ChoiceListAppend(bubble.dataset.code,bubble.dataset.choiceText,true);
			ChoiceBubblePop(bubble);
		}
		async function fairyRemovalCheck(e) {
			// 20251226: StarTree: Handle element removal
			// Returns true if the click is processed.
			if (!isRemovalMode) return false;
			const tagPill = e.target.closest('.tag-pill');
			if (tagPill) {
				e.stopPropagation();
				const t = tagPill.firstChild.textContent.trim();

				// 1. Check if it's in the Command Panel (Card Tags)
				if (e.target.closest('#card-tag-list')) {
					const activeCardData = getActiveCardData();
					if (activeCardData && activeCardData.t) {
						activeCardData.t = activeCardData.t.filter(tag => tag !== t);
						showToast(`Removed ${t} from current card`);
					}
				}
				// 2. Otherwise, assume it's in the Sidebar Tag Cloud
				else if (e.target.closest('#tag-cloud')) {
					const targetFiles = getFilteredData();
					// Find the count span inside the clicked tag-pill
					const countSpan = tagPill.querySelector('.tag-count-small');
					const displayCount = countSpan ? countSpan.textContent : targetFiles.length;
					if (await showConfirm(`Remove tag "${t}" from the ${displayCount} currently shown?`)) {
						targetFiles.forEach(item => {
							item.t = item.t.filter(tag => tag !== t);
						});
						// If the tag being removed was an active filter, clear it
						activeTags.delete(t);
						showToast(`Bulk removed tag: ${t}`);
					}
				}

				refreshAllUI();
				renderCardTags(); // Sync the command panel
				memDOM();
				return true;
			}

			const card = e.target.closest('.card');
			const track = e.target.closest('.track');
			const file = e.target.closest('.file-item');

			if (file) {
				e.stopPropagation();
				const idToRemove = file.dataset.id;

				// If it's a blob, tell the browser to release the memory
				if (idToRemove.startsWith('blob:')) {
					URL.revokeObjectURL(idToRemove);
				}

				// 1. Remove from the master DATA array
				DATA = DATA.filter(item => item.p !== idToRemove);

				// 2. Also remove it from the [Orphan Files] in savedPaths so it stays gone
				savedPaths.forEach(entry => {
					if (entry.data) {
						entry.data = entry.data.filter(item => item.p !== idToRemove);
					}
				});

				// 3. Visual feedback & Save
				file.style.opacity = "0";
				file.style.transform = "translateX(-20px)";

				setTimeout(() => {
					refreshAllUI(); // Rebuilds the list without the deleted item
					memDOM();       // Persists the change to localStorage
				}, 200);
				return true;
			}
			if (card) {
				e.stopPropagation();
				if (card.classList.contains('pinned')) {
					if (await showConfirm("This card has a ⭐. Keep it?")) { return true; }
				}
				// Perform the removal
				card.style.transform = "scale(0.8) translateY(20px)";
				card.style.opacity = "0";
				setTimeout(() => {
					card.remove();
					refreshAllUI(); // Update your "Stage (X)" count in the sidebar
					memDOM();   // Ensure the deletion is saved to localStorage
				}, 300);
				return true;
			}
			if (track) {
				removeTrack(track);
				return true;
			}
			return false;
		}
		function FilterDraw() {
			// 20260119: StarTree: Returns a DATA entry from the current filtered list.
			const choices = document.querySelectorAll(".file-item:not(.active-item)");
			const numChoices = choices.length;
			if (choices.length < 1) { return null; }
			const file = choices[Math.floor(Math.random() * choices.length)];
			const id = file.dataset.id;
			return DATA.find(i => i.p === id);
		}
		function flushCSS() {
			// 1. Clear the JS Set
			injectedCSS.clear();

			// 2. Clear the actual Style Tag in the DOM
			const styleTag = document.getElementById('dynamic-injected-style');
			if (styleTag) {
				styleTag.textContent = '';
			}

			// 3. Optional: Remove custom classes from the bubble so it returns to normal
			/*const bubble = document.querySelector('.speech-bubble');
			if (bubble) {
				// This removes every class that starts with 'custom_mood'
				const moodClasses = Array.from(bubble.classList)
					.filter(c => c.startsWith('custom_mood'));
				moodClasses.forEach(c => bubble.classList.remove(c));
			}*/

			DEBUG("CSS Registry and Styles flushed.", true);
		}
		function flushSounds() {
			// Clear the object
			for (let key in soundLibrary) {
				delete soundLibrary[key];
			}
			DEBUG("Sound library cleared.", true);
		}
		function getFullResURL(url) {
			// 20260110: Sasha: Given the url, get the full resolution URL.
			const substackRegex = /https:\/\/substackcdn\.com\/image\/fetch\/.*?\/(https%3A%2F%2Fsubstack-post-media\.s3\.amazonaws\.com%2F[^\s"']+)/;
			const match = url.match(substackRegex);
			return match ? decodeURIComponent(match[1]) : url;
		}
		function getImageURL(item) {
			// 20260103: Lei: Returns the image path for thumbnail when the item is not an image file.
			const imageExtensions = ['jpg', 'jpeg', 'png', 'webp', 'gif', 'svg', 'avif', 'url'];
			const nonimageExtensions = ['pdf','doc','docx','html','json'];
			// Priority 1: If the item has an image, use it.			
			if (item.i && item.i.trim() !== "") return item.i;

			// Priority 2: If the item has a path that is an image, use it.
			// Check if the path is a Base64 image string

			if (item.u) {
				if (typeof item.u === 'string' && item.u.startsWith('data:image/')) {
					return item.u; // Return as-is, browser can render this
				}
				// 2. Handle Mobile Blob URLs (Always images in our use case)
				if (typeof item.u === 'string' && item.u.startsWith('blob:')) {
					return item.u;
				}
				const cleanPath = URLHotLink(item.u);
				const parts = cleanPath.split('.');
				if (parts.length > 1) {
					const extension = parts.pop().toLowerCase();

					if (!nonimageExtensions.includes(extension)) {
						return cleanPath;
					}
				}
			}
			// Priority 3: use P if it is a path.
			if (item.p) {
				if (typeof item.p === 'string' && item.p.startsWith('data:image/')) {
					return item.p; // Return as-is, browser can render this
				}
				// 2. Handle Mobile Blob URLs (Always images in our use case)
				if (typeof item.p === 'string' && item.p.startsWith('blob:')) {
					return item.p;
				}
				const cleanPath2 = item.p.trim();
				const parts2 = cleanPath2.split('.');
				if (parts2.length > 1) {
					const extension2 = parts2.pop().toLowerCase();
					if (!nonImageExtensions.includes(extension2)) {
						return cleanPath2;
					}
				}
			}
			
			const fileName = item.n;
			if (fileName.trim() == "") {
				fileName = cleanPath.split(/[/\\]/).pop().split(/[?#]/)[0];
			}
			return getPlaceholderDataURL(fileName || 'FILE');
		}
		function getPlaceholderDataURL(text) {
			const canvas = document.createElement('canvas');
			canvas.width = 400;
			canvas.height = 100;
			const ctx = canvas.getContext('2d');

			// Draw Background
			ctx.fillStyle = '#000';
			ctx.fillRect(0, 0, canvas.width, canvas.height);

			// Draw Text
			ctx.fillStyle = '#fff';
			ctx.font = canvas.height / 2.5 + 'px monospace';
			ctx.textAlign = 'center';
			ctx.textBaseline = 'middle';
			ctx.fillText(text, canvas.width / 2, canvas.height / 2);

			return canvas.toDataURL(); // Returns a string starting with "data:image/png;base64..."
		}
		function getThumbnailURL(url, res = 256) {
			// 20260110: Sash: Return the thumbnail image URL if it is from substack.
			if (url.includes("substackcdn.com")) {
				// This regex finds "w_" followed by any digits and replaces it with the new res
				const resRegex = /w_\d+/;
				return url.replace(resRegex, `w_${res}`);
			}
			return url;
		}
		function getURL(item) {
			// 20260106: Skyle: Returns the URL for a data entry.
			// 20260110: Sasha: If the path link is a substack proxy compression link, return the link to the full image.
			// 20260118: Ivy: p is the unique ID, u is the URL or path. Use P as the path only if it contains / or \.
			if (item.u) { return getFullResURL(item.u); }
			if (item.p && isPath(item.p)) { return getFullResURL(item.p); }
			if (item.i) { return getFullResURL(item.i); }
			return "";
		}
		function GroundLine(sprite, dist = 1) {
			// 20260121: LRRH: Perspective-based ground line calculation
			// Returns position of the ground line based on a sprite's distance (meters) from the viewer.
			// When the distance is Infinity, it is interpreted as infinity so the ground line should be at the vertically centered horizon of the viewing frame.
			// The viewing frame is the stage if the sprite is closest to a stage. Otherwise it is the track if it is closest to a track.
			// Zooming: When dist=1, the ground line should be 25% of the frame's height below the frame.
			const frame = sprite.closest('#stage-area') || sprite.closest('.track');
			const H = frame.offsetHeight;
			const horizon = H / 2; // Vertically centered horizon
			if (dist === Infinity || dist === null) return horizon;
			const offsetAtOneMeter = 0.75 * H;
			const groundY = horizon + (offsetAtOneMeter / dist);
			return H - groundY;

		}
		function ImageFlip(img, xOffset, faceLeft) {
			const curImg = getActiveCard().querySelector('img');
			const curScaled = curImg.classList.contains('scaled');
			const curLeft = curImg.classList.contains('left');
			const curRight = curImg.classList.contains('right');
			const curGrounded = curImg.classList.contains('grounded');
			return SpriteOnStage(null, 0, 0, null, undefined, null);

			return SpriteOnStage(null, 0, 0, curScaled, undefined, curGrounded);
			if (!img) {
				const activeCard = getActiveCard();
				if (!activeCard) return;
				img = activeCard.querySelector('img');
				const data = getActiveCardData();
				xOffset = data.x;
			}

			const naturalWidth = img.naturalWidth;
			let pivotPercent = 50;
			if (naturalWidth && xOffset != null) {
				pivotPercent = (xOffset / naturalWidth) * 100;
			}

			// Handle Switch
			const isCurrentlyRight = img.classList.contains('rightFacing');
			const shouldFaceRight = (faceLeft === undefined) ? !isCurrentlyRight : !faceLeft;
			img.classList.toggle('rightFacing', shouldFaceRight);

			// Apply ORIGIN (combining X from here and Y from ground)
			const currentYOrigin = img.style.transformOrigin.split(' ')[1] || "50%";
			img.style.transformOrigin = `${pivotPercent}% ${currentYOrigin}`;

			// USE INDEPENDENT SCALE PROPERTY
			// This won't overwrite the 'translate' property used by grounding
			img.style.scale = shouldFaceRight ? "-1 1" : "1 1";
			document.querySelector(".flip-btn").innerHTML = shouldFaceRight ? 'R' : 'L';

		}
		function ImageGround(img, yOffset, ground, distance) {
			const curImg = getActiveCard().querySelector('img');
			const curScaled = curImg.classList.contains('scaled');
			const curLeft = curImg.classList.contains('left');
			const curGrounded = curImg.classList.contains('grounded');
			return SpriteOnStage(null, 0, 0, null, null, undefined);

			if (!img) {
				const activeCard = getActiveCard();
				if (!activeCard) return;
				img = activeCard.querySelector('img');
				yOffset = getActiveCardData().y || 0;
			}

			const groundPos = (typeof ground === 'number') ? ground : GroundLine(img, distance);
			// Handle Switch
			const isCurrentlyGrounded = img.classList.contains('grounded');
			const shouldBeGrounded = (typeof ground === 'number' || distance !== undefined)
				? true
				: (ground === undefined ? !isCurrentlyGrounded : ground);
			img.classList.toggle('grounded', shouldBeGrounded);
			if (shouldBeGrounded) {
				// Apply ORIGIN (combining Y from here and X from flip)
				const naturalHeight = img.naturalHeight;
				const renderedHeight = img.offsetHeight || naturalHeight; // Current visible height
				const internalPercent = (naturalHeight && yOffset) ? (yOffset / naturalHeight) * 100 : 0;
				const externalPercent = (groundPos / renderedHeight) * 100;


				const finalTranslateY = internalPercent - externalPercent;
				const currentXOrigin = img.style.transformOrigin.split(' ')[0] || "50%";
				img.style.transformOrigin = `${currentXOrigin} ${100 - internalPercent}%`;
				// USE INDEPENDENT TRANSLATE PROPERTY
				// This won't overwrite the 'scale' property used by flipping
				img.style.translate = `0 ${finalTranslateY}%`;
				document.querySelector(".ground-btn").innerHTML = "G"
			} else {
				img.style.translate = `0 0`;
				document.querySelector(".ground-btn").innerHTML = "-"
			}
		}
		function ImageScale(bScale) {
			const curImg = getActiveCard().querySelector('img');
			const curScaled = curImg.classList.contains('scaled');
			const curLeft = curImg.classList.contains('left');
			const curGrounded = curImg.classList.contains('grounded');

			return SpriteOnStage(null, 0, 0, undefined, null, null);
			// 20260122: Skyle: This is just a demo function to show the math of scaling without applying X and Y offset.
			// Forget about distance for now, assume that the target scale is 700px per meter.
			// The sprite data.s has the sprite's px/m value.
			// When the scale is applied to the sprite, set its class .scaled, and set its data-s attribute to store data.s
			const card = getActiveCard();
			const data = getActiveCardData();
			if (!card || !data) return;
			const sprite = card.querySelector('img');
			if (!sprite) return;
			// 1. Calculate the Ratio
			const targetPxPerMeter = 700;
			const spritePxPerMeter = data.s || 700;
			const scaleFactor = targetPxPerMeter / spritePxPerMeter;
			// 2. Handle the Three-Way Switch (true/false/toggle)
			const isCurrentlyScaled = sprite.classList.contains('scaled');
			const shouldScale = (bScale === undefined) ? !isCurrentlyScaled : bScale;
			// 3. Apply Metadata and Classes
			sprite.classList.toggle('scaled', shouldScale);
			sprite.setAttribute('data-s', spritePxPerMeter);
			// 4. Apply the Transform
			if (shouldScale) {
				// We use the independent 'scale' property to avoid clobbering 'translate'
				sprite.style.scale = `${scaleFactor}`;
			} else {
				sprite.style.scale = "1";
			}
		}
		async function importMultiTrackDOM() {
			// 1. Create a hidden file input to trigger the dialog
			const fileInput = document.createElement('input');
			fileInput.type = 'file';
			fileInput.accept = '.DOM, .html, .txt'; // Accept your custom extension

			fileInput.onchange = async (e) => {
				const file = e.target.files[0];
				if (!file) return;

				const reader = new FileReader();
				reader.onload = (event) => {
					const fileContent = event.target.result;
					const parser = new DOMParser();
					const doc = parser.parseFromString(fileContent, 'text/html');
					const importedSection = doc.getElementById('multitrack');

					if (importedSection) {
						const mainContainer = document.getElementById('multitrack');

						// 3. Replace the live container's content with the imported content
						mainContainer.innerHTML = importedSection.innerHTML;
						MigrationChecks();

						showToast("MultiTrack section restored from file.");

						// 4. Update memory and UI
						if (typeof memDOM === 'function') memDOM();
						updateAllCardOverlays(); // Re-sync any visual states
					} else {
						showToast("Could not find the [multi-track-container] in that file.");
					}
				};

				reader.readAsText(file);
			};

			fileInput.click();
		}
		function initZLayers() {
			// 20251225: Tanya: Enumerate the layers by code.
			const root = document.documentElement;
			let zi = (zLayers.length) * 10;
			zLayers.forEach(layer => {
				root.style.setProperty(`--z-${layer}`, zi);
				zi -= 10;
			});
		}
		function injectCSS(cssCode) {
			if (injectedCSS.has(cssCode)) { return; }

			let styleTag = document.getElementById('dynamic-injected-style');

			// 1. Create the tag if it's the first time
			if (!styleTag) {
				styleTag = document.createElement('style');
				styleTag.id = 'dynamic-injected-style';
				document.head.appendChild(styleTag);
			}
			const cleanCSS = cssCode.replace(/transformtransform/g, 'transform').trim();
			styleTag.textContent += "\n" + cleanCSS;
			injectedCSS.add(cssCode);
			DEBUG("New CSS appended to library.", true);
		}
		function isHidden(elID) {
			const el = document.getElementById(elID);
			if (!el) return true;
			return !el.checkVisibility();
		}
		function isMobile() {
			const isSmallScreen = (window.innerWidth <= 768 || window.innerHeight <= 768);
			return isSmallScreen;
			const userAgent = navigator.userAgent || navigator.vendor || window.opera;
			const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);


			// Check for specific mobile strings in User Agent
			const isMobileUA = /android|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());

			//return isMobileUA || isTouch;

		}
		function isPath(p) {
			// 20260118: Ivy: Returbs true if p looks like a path.
			const pathRegex = /[\\.\/]/;
			return pathRegex.test(p);
		}
		function memDEV(isLoad) {
			// 20260118: StarTree: Saves the developer tab content to local storage
			const devScript = document.getElementById('dev-command')
			if (isLoad) {
				devScript.value = localStorage.getItem('dev-command');
			} else {
				localStorage.setItem('dev-command', devScript.value);
			}
		}
		function memDOM(isLoad, aID) {
			// 20251226: StarTree: For a quick way to save the workspace, save the html of the multitrack section to local storage
			// .. isLoad = true means loading to the page. 
			// .. isLoad = false means saving to local storage.
			if (!aID) {
				// if aID is not defined, save everything.
				memDOM(isLoad, "multitrack");
				return;
			}
			const mSection = document.getElementById(aID);
			if (isLoad) {
				const mSavedHTML = localStorage.getItem(aID + '_snapshot');
				if (!mSavedHTML) { return; }
				mSection.innerHTML = mSavedHTML;
				MigrationChecks();
			} else {
				localStorage.setItem(aID + '_snapshot', mSection.innerHTML);
				localStorage.setItem(aID + '_snapshot_version', APP_VERSION);
			}

		}
		async function MigrationChecks() {
			// 20260118: Tanya: Temporary code to transit from #track to .track
			const tempTracks = document.querySelectorAll('#track');
			if (tempTracks.length > 0) {
				if (await showConfirm("You are loading data with an old track format. Some buttons may not work until the format is upgraded. Upgrade now?")) {
					tempTracks.forEach(t => {
						t.classList.add('track');
						t.removeAttribute('id');
					});
					localStorage.setItem(aID + '_snapshot', mSection.innerHTML);
				}
			}
			//*/ End of temporary transition fix.
		}
		function Multitrack() {
			// 20260114: Albatross: Returns the multitrack.
			const activeCard = getActiveCard();
			let multitrack = ""
			if (!activeCard) {
				multitrack = document.querySelector('#multitrack');
			} else {
				multitrack = activeCard.closest('#multitrack');
			}
			return multitrack;
		}
		function NoteInsertDTS(){
			// 20260206: StarTree: Inserts a local timestamp YYYYMMDDhhmmss to the edit textarea in focus.
			const elFrame = document.querySelector('.card-textarea.active');
			if (!elFrame || !elFrame.checkVisibility()) return;
			const text = elFrame.value;
			const start = elFrame.selectionStart;
			const end = elFrame.selectionEnd;
			const timestamp = DTS();
			elFrame.value = text.slice(0, start) + timestamp + text.slice(end);
			elFrame.selectionStart = elFrame.selectionEnd = start + timestamp.length;
			elFrame.focus();
		}
		function NoteLineSwap(bUp) {
			// 20260125: Skyle: Moves the selected line up the notes if it is not already at the top.
			const elFrame = document.querySelector('.card-textarea.active');
			if (!elFrame || !elFrame.checkVisibility()) return;
			const text = elFrame.value;
			const start = elFrame.selectionStart;
			const lines = text.split('\n');
			const currentLineIndex = text.substring(0, start).split('\n').length - 1;
			const targetIndex = bUp ? currentLineIndex - 1 : currentLineIndex + 1;
			if (targetIndex < 0 || targetIndex >= lines.length) return;
			elFrame.classList.toggle('active', true);
			const temp = lines[currentLineIndex];
			lines[currentLineIndex] = lines[targetIndex];
			lines[targetIndex] = temp;
			elFrame.value = lines.join('\n');
			const lineToJump = lines[currentLineIndex];
			const shift = (lineToJump.length + 1) * (bUp ? -1 : 1);
			elFrame.selectionStart = elFrame.selectionEnd = start + shift;
			elFrame.classList.add('unsaved');
			elFrame.focus();
		}
		function PanelTextareaActivate(elThis) {
			// 20260125: Mark the current one active and the other one not active.
			const elFrame = elThis.closest('.notes-panel');
			elFrame.querySelectorAll('.card-textarea').forEach(n => {
				n.classList.remove('infocus');
			});
			elThis.classList.add('infocus');
		}
		function PanelTextareaResize(elThis) {
			// 20260125: Cycles through the display ratios of the user notes and script areas.
			const elNotes = document.getElementById('card-notes');
			const elScript = document.getElementById('card-script');
			let flexN = elNotes.style.flex;
			let curRatio = elThis.innerText;
			switch (curRatio) {
				//case '0:4': flexN = 1; break;
				case '1:3': flexN = 2; break;
				case '2:2': flexN = 3; break;
				case '3:1': flexN = 1; break;
				//case '4:0': flexN = 0; break;
				default: flexN = 3;
			}
			const flexS = 4 - flexN;
			elNotes.style.flex = `${flexN} ${flexN} 0%`;
			elScript.style.flex = `${flexS} ${flexS} 0%`;			
			elThis.innerHTML = `${flexN}:${flexS}`;
		}
		function PanelTextareaResizeH(elThis){			
			const CP = document.getElementById('command-panel');
			let curH = 2
			if(CP.classList.contains('edit-size-3')){
				CP.classList.remove('edit-size-3');
				curH = 1;
			}else if(CP.classList.contains('edit-size-2')){
				CP.classList.remove('edit-size-2');
				curH = 3;
			}else if(CP.classList.contains('edit-size-1')){
				CP.classList.remove('edit-size-1');
				curH = 2;
			}
			CP.classList.add('edit-size-' + curH)
			elThis.innerHTML = "H"+curH;
		}
		function playSound(name, rate = 1.0, shouldLoop = false) {
			if(rate==""){rate = 1};
			if(shouldLoop==""){shouldLoop = false;}			
			const keys = soundMap[name];
			if (!keys || keys.size === 0) return;

			const keyArray = Array.from(keys);
			const randomKey = keyArray[Math.floor(Math.random() * keyArray.length)];
			const audio = assetLibrary[randomKey];

			if (audio) {
				audio.currentTime = 0;
				audio.playbackRate = parseFloat(rate);
				audio.preservesPitch = false;

				// Add this line to handle looping for BGM
				audio.loop = shouldLoop;

				audio.play().catch(e => console.warn("Playback failed", e));
			}
		}
		function processScriptCommands(line) {
			//if (!inputString.startsWith('!')) return false;
			const command = line.leftOf(' ').trim().toUpperCase();
			const after1 = line.trim().rightOf(' ').trim();
			const arg1 = after1.leftOf(' ').trim().toUpperCase();
			const after2 = after1.trim().rightOf(' ').trim();
			const arg2 = after2.leftOf(' ').trim().toUpperCase();
			const after3 = after2.trim().rightOf(' ').trim();
			const arg3 = after3.leftOf(' ').trim().toUpperCase();
		
			if (command === 'BUTTON') { addButton(arg1, arg2, after3); return true; }
			if (command === 'CHOOSE') { ChoiceAdd(arg1); return true; }
			if (command === 'CLEAR') {
				if (arg1 === 'CHOICES') { ChoiceRemove(null, true); return true; }
				if (arg1 === 'CSS') { flushCSS(); return true; }
				if (arg1 === 'TAGS') { activeTags.clear(); refreshAllUI(); return true; }
				if (arg1 === 'SOUND') { flushSounds(); return true; }
				return false;
			} else if (command === 'CSS') {
				injectCSS(after1.trim());
				return true;
			} else if (command === 'END') {
				ScriptEnd();
				return true;
			} else if (command === 'GOTO') {
				ScriptGoto(arg1);
				return true;
			} else if (command === 'PLAY') {
				playSound(arg1, arg2, arg3); return true;
			} else if (command === 'SOUND') {
				handleSoundCommand(arg1, arg2, after3);
				return true;
			} else if (command === 'STAGE') { StageSet(after1); return true; }
			return false;
		}
		function processScriptDialog(text, choiceColors = []) {
			const overlay = document.getElementById('dialogue-overlay');
			const textField = document.getElementById('speech-text');
			const choiceContainer = document.getElementById('choice-container');


			// 20260119: Skyle: If the stage is live and the text does not start with a colon, change to narrative mode.
			const prefix = text.charAt(0);
			const bubble = document.querySelector('.speech-bubble');
			//if(StageLive() && prefix != ':'){
			let continueNarration = bubble.classList.contains('narrative-mode');
			if (prefix != ':') {
				bubble.classList.add('narrative-mode');				
			} else {
				bubble.classList.remove('narrative-mode');
				text = text.substring(1).trim();
				continueNarration = false;
			}

			// Set Text
			if(continueNarration){
				textField.innerHTML += "\n" + DialogFormat(text);
			}else{
				
				textField.innerHTML = DialogFormat(text);
			}
			


			// If choiceColors is blank, hide the container.
			if (choiceColors.length == 0) {
				choiceContainer.classList.remove('active');
			} else {
				choiceContainer.classList.add('active');
			}

			

			// Clear and Populate Buttons
			choiceContainer.innerHTML = "";
			choiceColors.forEach(color => {
				const btn = document.createElement('button');
				btn.className = 'choice-btn';
				btn.style.backgroundColor = color;
				choiceContainer.appendChild(btn);
			});

			SpeechBubbleShow(true);
			document.querySelector('.speech-bubble').scrollTop = 0;

			

			// Reset the next button animation.
			const nextBtn = document.querySelector('.stage-next-btn');
			nextBtn.classList.remove('stage-next-btn');
			void nextBtn.offsetWidth;
			nextBtn.classList.add('stage-next-btn');

			return false;
		}
		async function processScriptLine(line) {
			// 20260119: Arcacia: This function runs a line in the script. if it returns true, it means that the function calling this may run the next line immediately.
			const prefix = line.charAt(0);

			// 20260120: Natalie: If there is a selected choice, set bubble spawning to done.
			ChoiceCommit();
			// 20260119: LRRH: If the engine is spawning bubbles and the prefix is not *, put the line back and return.

			const se = ScriptEngine();
			if (prefix != '*' && ScriptBubbleSpawning(null)) {
				
				se.dataset.script = line + "\n" + se.dataset.script;

				// 20260119: Skyle: If the dialog overlay is hidden, show it back so the user can confirm their choice.
				SpeechBubbleShow(true);
				showToast('Please find and select a choice.')
				return false;
			}
			const content = line.substring(1).trim();
			switch (prefix) {
				case '': return false;
				case '#': return true; // # are comments.
				case '!': return processScriptCommands(content);
				case '?': return ScriptIf(content);
				case '+': return processScriptTag(content, true);
				case '-': return processScriptTag(content, false);
				case '*': return ScriptBubbleSpawning(content);
				case '@': return ActorSet(content);
				case '>': createCard(getCardByPath(content)); return false;
				default: 
					processScriptDialog(line);
					// Continue to the next line if the next line starts with a space.
					const nextPrefix = se.dataset.script.charAt(0);
					if(nextPrefix===" " || nextPrefix==="*"){return true;}
			}
			return false;
		}
		function processScriptTag(line, bAdd) {
			const tags = line.split(' ');
			tags.forEach(rawTag => {
				const tag = rawTag.trim();
				const exactTag = ALL_TAGS.find(t => t.toLowerCase() === tag.toLowerCase());
				if (exactTag) {
					if (bAdd) {
						activeTags.add(exactTag);
					} else {
						activeTags.delete(exactTag);
					}
				}
			});
			refreshAllUI(); // Trigger the UI update
			return true;
		}
		function registerAsset(key, source) {
			if (assetLibrary[key]) return; // Key already exists

			// If source doesn't start with data:, assume it's a URL/path
			const src = source.startsWith('data:') || source.startsWith('http') || source.startsWith('./')
				? source
				: "data:audio/mpeg;base64," + source;

			assetLibrary[key] = new Audio(src);
			DEBUG(`Asset Registered: ${key}`, true);
		}
		function registerMap(name, key) {
			if (!soundMap[name]) {
				soundMap[name] = new Set();
			}

			// Set naturally prevents duplicate Name+Key pairs
			soundMap[name].add(key);
			DEBUG(`Mapping added: ${name} -> ${key}`, true);
		}
		function renderCardTags() {
			const container = document.getElementById('card-tag-list');
			if (!container) return;
			container.innerHTML = "";
			const card = document.querySelector(".card.is-active");
			if (!card) { return; }
			const id = card.dataset.id;
			const item = DATA.find(i => i.p === id);
			if (!item) return;

			[...item.t].sort().forEach(tag => {
				const p = document.createElement('div');
				const isActive = activeTags.has(tag);
				p.className = 'tag-pill' + (isActive ? ' active' : '');
				p.dataset.tag = tag;
				p.innerText = tag;
				container.appendChild(p);
			});
			toggleAddTag(true);
		}
		function saveCardNotes(e) {
			// 20251230: Cardinal			
			e?.stopPropagation();
			const activeCard = document.querySelector(".card.is-active");
			if (!activeCard) { return; }			
			activeCard.dataset.c = encodeURIComponent(document.getElementById('card-script').value);
			activeCard.dataset.i = document.getElementById('card-img-url').value.trim();
			activeCard.dataset.n = document.getElementById('card-title').value.trim();
			activeCard.dataset.o = encodeURIComponent(document.getElementById('card-notes').value);
			activeCard.dataset.p = document.getElementById('card-id').value.trim();
			activeCard.dataset.s = Number(document.getElementById('card-scale').value.trim());
			activeCard.dataset.u = document.getElementById('card-path-url').value.trim();
			activeCard.dataset.x = Number(document.getElementById('card-x-offset').value.trim());
			activeCard.dataset.y = Number(document.getElementById('card-y-offset').value.trim());

			const cardNotes = document.getElementById("card-notes");
			cardNotes.dataset.original = activeCard.dataset.o;
			cardNotes.classList.remove("unsaved");

			const cardScript = document.getElementById("card-script");			
			cardScript.dataset.original = activeCard.dataset.c;
			cardScript.classList.remove("unsaved");

			// Update the visual card immediately if the image changed
			activeCard.dataset.id = activeCard.dataset.p;
			const cardThumbnail = document.getElementById('active-preview-thumb');
			cardThumbnail.src = getImageURL(activeCard.dataset);
			if (activeCard) {
				const img = activeCard.querySelector('img');
				if (img) img.src = cardThumbnail.src;
			}
			refreshAllUI(); // So that if the p code has changed the grid view or file list button is still functional.


			activeCard.classList.add("pinned");
			saveMetadata();
			memDOM();
		}
		function saveMetadata() {
			const card = getActiveCard();
			activeCardData = getActiveCardData();
			if (!activeCardData) return;
			activeCardData.c = encodeURIComponent(document.getElementById('card-script').value);
			activeCardData.i = document.getElementById('card-img-url').value.trim();
			activeCardData.n = document.getElementById('card-title').value.trim();
			activeCardData.o = encodeURIComponent(document.getElementById('card-notes').value);
			activeCardData.p = document.getElementById('card-id').value.trim();
			activeCardData.s = Number(document.getElementById('card-scale').value.trim());
			activeCardData.u = document.getElementById('card-path-url').value.trim();
			activeCardData.x = Number(document.getElementById('card-x-offset').value.trim());
			activeCardData.y = Number(document.getElementById('card-y-offset').value.trim());

			const fields = ['c', 'i', 'n', 'o', 'p', 's', 'u', 'x', 'y'];
			fields.forEach(field => {
				const val = activeCardData[field];
				if (val === "") { delete activeCardData[field]; }
			});
			//if(activeCardData.c==0){delete activeCardData.c;}
			//if(activeCardData.y==0){delete activeCardData.y;}

			
		}
		function ScriptBubbleSpawning(line, done) {
			// 20260119: LRRH: if done, clear the bubble spawning mode.
			// This is supposed to be called by the confirm button of a choice.
			if (done) {
				ScriptEngine().removeAttribute('SE-BubbleSpawning');
				return true;
			}
			// 20260119: LRRH: If the line argument is null, return whether the engine is in bubble spawning mode.
			if (line == null) {
				return ScriptEngine().hasAttribute('SE-BubbleSpawning');
			}

			// 20260119: LRRH: When the script interpreter encounters a * command line it enters bubble spawning mode. During that mode, if it encounters a non * command line, it waits for the mode to be over. (The confirm button of a choice bubble allows the code to resume.
			// Format of the * command line itself: *A* Text of choice A
			// 20260207: StarTree: If 
			
			const parts = line.split('*');
			let code = parts[0].trim();
			const prefix = code.charAt(0);
			let choiceText = line.rightOf('*').trim();
			 if(!line.includes('*')){
				// If the line does not have a second *, just make an inert list.
				if(prefix==="!"){
					choiceText = line.rightOf('!').trim();
					ChoiceListAppend(null,choiceText);					
				}else{
					ChoiceBubbleSpawn(null, line.trim());
				}
			}else if(prefix === "!"){
				code = code.rightOf('!');
				ChoiceListAppend(code,choiceText);
			}else{
				ChoiceBubbleSpawn(code, choiceText);
			}			
			return true;
		}
		function ScriptEnd() {
			// 20260125: Evelyn: Ends the script. (To keep tht engine from running the rest.)
			const elSE = ScriptEngine();
			elSE.dataset.script = "";
			elSE.dataset.p = "";
		}
		function ScriptEngine() {
			return document.querySelector('.script-step-btn');
		}
		function ScriptGoto(label){
			// 20260202: Fina: Go to a label encapsulated by '#' in the script.
			const SE = ScriptEngine();
			let remainingScript = SE.dataset.scriptBackup;
			remainingScript = remainingScript.rightOf(`#${label}#`,true);
			//remainingScript = remainingScript.rightOf('\n');
			if(remainingScript == ""){
				// 20260206: Koyo: If the label is not found in the current script, assume that it is a card id.
				const data = DATAByID(label);
				if(data){
					if(data.c != undefined){
						remainingScript = decodeURIComponent(data.c);
					}else if (data.o !=undefined){
						remainingScript = decodeURIComponent(data.o);
					}
					if(remainingScript.trim() !=""){
						SE.dataset.p = label;
						SE.dataset.scriptBackup = remainingScript;
					}
				}
			}
			if(remainingScript ==""){
				remainingScript = SE.dataset.scriptBackup;
			}
			SE.dataset.script = remainingScript;
		}
		function ScriptIf(line) {
			// 20260119: Arcacia: The line interpreter calls this if the first character is ?
			// The format: ?ChoiceCode Line
			// What to do: Check if the ChoiceCode exists, if so, run the line.
			const parts = line.split(' ');
			const code = parts[0].trim();
			if (!ChoiceCheck(code)) { return true; }
			const remaining = line.substring(line.indexOf(' ', 1) + 1).trim();
			return processScriptLine(remaining.trim());
		}
		async function ScriptPublish(elThis) {
			// 20250125: StarTree: Save the data in "Publish" spec that does not include user notes. Show additional messages to inform the user what the button is for.

			if (!await showConfirm("This will save a copy of the data with the scripts without your user notes. Continue?")) return;
			// Check for unsaved script box
			const elScript = document.getElementById('card-script');
			if (elScript.classList.contains('unsaved')) {
				if (!await showConfirm("You have unsaved changes at the script edit box. Continue?")) { return; }
			}
			// Confirm the collection selection
			let strCollectionList = "";
			const collections = document.querySelectorAll('.path-entry:has([checked])');
			let i = 1;
			collections.forEach(c => {
				const title = c.querySelector('.path-text').innerHTML;
				strCollectionList += i + ") " + title + "\n";
				i++;
			});
			// Confirm the filter selections 
			let strTags = "";
			const tagCloud = document.getElementById('tag-cloud');
			const tags = tagCloud.querySelectorAll('.tag-pill.active');
			tags.forEach(t => {
				if (strTags != "") { strTags += ", "; }
				strTags += t.dataset.tag;
			});
			// Confirm the number of items
			const q = document.getElementById('master-search').value.toLowerCase();
			const fileList = document.getElementById('file-list');
			const files = fileList.querySelectorAll('.file-item');

			if (!await showConfirm(`This will export the data of ${files.length} card(s) from ${collections.length} collection(s):\n${strCollectionList}filtered with ${tags.length} tag(s): ${strTags} containing tag keyword "${q}". Continue?`)) { return; }

			const filtered = DATA
				.filter(i => {
					// 1. Check if item has all active tags
					const matchesActive = Array.from(activeTags).every(at => i.t.includes(at));
					// 2. Check if it matches the search query 'q'
					return matchesActive && (q === "" || i.t.some(it => it.toLowerCase().includes(q)));
				})
				.map(item => {
					// 3. Create a copy WITHOUT 'o'
					// This pulls 'o' out and puts everything else into a new object called 'cleanItem'
					const { o, ...cleanItem } = item;
					return cleanItem;
				});

			document.body.style.cursor = 'wait';
			let dataToExport = filtered;

			// standard Download Logic
			const blob = new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json' });
			const a = document.createElement('a');
			a.href = URL.createObjectURL(blob);
			a.download = `Script_Export_${new Date().toISOString().slice(0, 10)}.json`;
			a.click();

			// 5. Cleanup
			document.body.style.cursor = 'default';
			setTimeout(() => URL.revokeObjectURL(a.href), 1000);

		}
		async function ScriptRun(SE){
			// 20260129: LRRH: Runs the script that is already in the script engine.
			if(!SE) {SE = ScriptEngine();}
			let scriptToRun = SE.dataset.script;			
			const lineRegex = /^(.*?)(?:\r?\n|$)/; // Pop the first line
			const match = scriptToRun.match(lineRegex);
			if (!match || match[0].length < 1) {
				// Script finished.				
				SE.dataset.p = "";
				SpeechBubbleShow(false);
				StageFade();
				return false;
			}
			const currentLine = match[1].trim();
			SE.dataset.script = SE.dataset.script.replace(lineRegex, "");
			if (!currentLine) {
				ScriptRun(SE);
				return true;
			}
			// STEP Process the line. Returning True means continue to next line.
			if (await processScriptLine(currentLine)) {
				DEBUG("[ ] " + currentLine, true); //
				ScriptRun(SE);
			} else {
				DEBUG("[>] " + currentLine, true); //
			}

		}
		function ScriptRunID(id) {
			// 20260127: StarTree: Run the script from the DATA with the ID.
			//document.querySelector('.card.active').classList.Remove('active');
			
			const data = DATAByID(id);
			if (!data) return;
			const SE = ScriptEngine();
			SE.dataset.p = id;
			SE.dataset.script = decodeURIComponent(data.c);
			ScriptRun(SE);
		}
		async function ScriptStart(SE) {
			// 20260111: Sasha: Runs the next command in the script
			// STEP 1: Store the node ID and the Script to the button if they are different from what the button has.
			if (!SE) {SE = ScriptEngine();}
			let scriptToRun = SE.dataset.script;
			if (getActiveCard()) {
				const nodeID = document.getElementById("card-id").value;
				if (!nodeID) { return false; }
				if (nodeID != SE.dataset.p) {
					SE.dataset.p = nodeID;
					// 20260125: StarTree: Prioritize running the side that is selected. 				
					const elNotes = document.getElementById("card-notes");
					const elScript = document.getElementById("card-script");

					if (elNotes.classList.contains('infocus')) {
						scriptToRun = elNotes.value;
					} else if (elScript.classList.contains('active')) {
						scriptToRun = elScript.value;
					} else if (elScript.value.trim() != '') {
						// If neither is selected, prioritize the official script.
						scriptToRun = elScript.value;
					} else {
						scriptToRun = elNotes.value;
					}
					SE.dataset.script = scriptToRun;
					SE.dataset.scriptBackup = scriptToRun;
					SE.removeAttribute('SE-BubbleSpawning');
				}
			}

			ScriptRun(SE);
		}
		async function setActiveCard(card) {
			// 20260111: LRRH: Don't set active card if auto spawning with the notes tab open.
			if (!card) return;
			// 20260123: Natalie: Don't set another active card if the current command panel is dirty.
			const dirt = document.querySelector('#command-panel .unsaved');
			if (dirt) {
				if (await showConfirm('You have unsaved changes on the active card. Return to save them first?')) { return; }
				dirt.classList.remove('unsaved');
			}


			// 20260108: LRRH: Remove the active attribute from all cards then set this card to be active
			document.querySelectorAll('.card').forEach(card => card.classList.remove('is-active'));
			card.classList.add('is-active');
			const imgEl = card.querySelector('img');
			const data = getActiveCardData();
			const cardNotes = document.getElementById("card-notes");
			const cardScript = document.getElementById("card-script");
			// 20260123: Evelyn: Just use the data in the card if it is not found in DATA.
			//if(!data){
				document.getElementById("card-img-url").value = card.dataset.i || "";
				document.getElementById("card-title").value = card.dataset.n || "";
				document.getElementById("card-id").value = card.dataset.p || "";
				document.getElementById("card-scale").value = card.dataset.s || "";
				document.getElementById("card-path-url").value = card.dataset.u || "";
				cardNotes.value = card.dataset.o? decodeURIComponent(card.dataset.o) : "";
				cardScript.value = card.dataset.c? decodeURIComponent(card.dataset.c) : "";
				cardNotes.dataset.original = card.dataset.o || "";
				cardScript.dataset.original = card.dataset.c || "";
				
			//}
			if (data) {
				document.getElementById("card-img-url").value = data.i || "";
				document.getElementById("card-title").value = data.n || "";
				document.getElementById("card-id").value = data.p || "";
				document.getElementById("card-scale").value = data.s || "";
				document.getElementById("card-path-url").value = data.u || "";
				if(cardNotes.value == ""){
					cardNotes.value = data.o? decodeURIComponent(data.o) : "";
					cardNotes.dataset.original = data.o || "";
				}
				if(cardScript.value == ""){
					cardScript.value = data.c? decodeURIComponent(data.c) : "";
					cardScript.dataset.original = data.c || "";
				}
				
				if (data.p != document.querySelector(".script-step-btn").dataset.p) {
					SpeechBubbleShow(false);
				};
				
				/*
				if ('notes' in card.dataset) {
					cardNotes.dataset.original = card.dataset.o;
				} else {
					cardNotes.dataset.original = data.o || "";
				}
				if ('script' in card.dataset) {
					cardScript.dataset.original = card.dataset.c;
				} else {
					cardScript.dataset.original = data.c || "";
				}*/

				document.getElementById("card-x-offset").value = data.x || "";
				document.getElementById("card-y-offset").value = data.y || "";
			}
			//cardNotes.value = decodeURIComponent(cardNotes.dataset.original || "");
			//cardScript.value = decodeURIComponent(cardScript.dataset.original || "");
			renderCardTags();

			// Mirror Thumbnail.
			const mirrorImg = document.getElementById('active-preview-thumb');
			//const mirrorLabel = document.getElementById('active-preview-label');
			const cardImg = card.querySelector('img');
			const cardName = card.querySelector('.card-title')?.innerText || "Active Card";
			if (cardImg && mirrorImg) {
				mirrorImg.src = cardImg.src;
				mirrorImg.style.display = "block";
				//mirrorLabel.innerText = cardName;
			}
			// Mirror 
			memDOM();
		}
		function showAllTracks() {
			// 20260114: Albatross: for the multitrack frame of the active card (or the multitrack frame if there is no active card), make sure that the flex number of each track is at least 1.
			const activeCard = getActiveCard();
			let multitrack = ""
			if (!activeCard) {
				multitrack = document.querySelector('#multitrack');
			} else {
				multitrack = activeCard.closest('#multitrack');
			}
			multitrack.querySelectorAll('.track').forEach(t => {
				let currentFlex = parseFloat(t.style.flexGrow) || 0;
				let newFlex = Math.max(1, currentFlex);
				t.style.flex = `${newFlex} ${newFlex} 0%`;
				t.style.overflow = "";   // Restore default so content isn't clipped
				t.style.opacity = "1";   // Ensure it's visible
				t.style.padding = "";    // Restore original spacing
				t.style.margin = "";
			});
		}
		function SpeechBubbleShow(bShow) {
			const bubble = document.getElementById('dialogue-overlay');
			bubble.classList.toggle('active', bShow);
		}
		function SpriteOnStage(sprite, posX = 0, posY = 0, bScale, bLeft, bGround) {
			// 20260122: Skyle: This function sets the position of a sprite on stage (or in backstage during adjustment)
			// Treat bScale, bLeft, and bGround as three-way switches: true, false, undefined=toggle.
			// If the sprite is specified, assume that the frame is the stage.
			// If the sprite is not specified, assume that the frame is the active card at backstage.			
			const card = sprite? sprite.closest('.card') : getActiveCard(); 
			const track = card? card.closest('.track') : null;
			if (!sprite) {
				if (!card) return;
				const data = getActiveCardData();
				sprite = card.querySelector('img'); if (!sprite) return;
				sprite.dataset.s = data.s || 700;
				sprite.dataset.x = data.x || sprite.naturalWidth / 2;
				sprite.dataset.y = data.y || 0;
			}
			if (sprite.tagName === 'IMG' && !sprite.complete) {
				// If not loaded, wait for the 'load' event and run this function again
				sprite.onload = () => {
					SpriteOnStage(sprite, posX, posY, bScale, bLeft, bGround);
				};
				return; // Stop execution for now
			}

			// Double check naturalHeight isn't 0 (rare edge case for broken images)
			if (sprite.naturalHeight === 0) {
				return;
			}
			// STEP 0 Update ClassList		
			if (bLeft === undefined && posX != 0) {
				bLeft = (posX > 0);
			}
			if (bScale !== null) {
				sprite.classList.toggle('scaled', bScale)
			}
			if (bLeft !== null) {
				bLeft = sprite.classList.toggle('left', bLeft);
				sprite.classList.toggle('right', !bLeft);
			}
			if (bGround !== null) {
				sprite.classList.toggle('grounded', bGround);
			}
			let shouldScale = sprite.classList.contains('scaled');
			let shouldFaceLeft = sprite.classList.contains('left');
			let shouldFaceRight = sprite.classList.contains('right');
			let shouldGround = sprite.classList.contains('grounded');

			const frame = sprite.closest('.stage-area, .track') || sprite.parentElement;
			const frameW = frame.clientWidth;
			let frameH = frame.clientHeight;
			const naturalW = sprite.naturalWidth;
			const naturalH = sprite.naturalHeight;

			if(StageLive() || !shouldGround || !shouldScale){
				if(card){
					card.style.height = "100%";
					card.style.marginTop = "0%";
					card.style.marginBottom = "0%";
				}
			}else{
				if(card){
					card.style.height = "90%";
					card.style.marginTop = "3%";
					card.style.marginBottom = "7%";
					frameH = frameH*0.90;
				}
			}


			

			// STEP 1: Compute the final scaling needed considering if bScale is true.
			// Assume that the frame is in fit to 100% height. 
			// finalScale=1 means the image is scaled to 100% frameH.
			const autoScale = frameH / naturalH; // This is the scale ALREADY applied.
			// The 0.7 is an adjustable parameter for how many meter is shown per frameH.
			// targetScale = (0.7screen/meter)*(pixel/screen)*(meter/pixels)
			const screenScale = StageLive()? 0.7 : 0.5;
			const targetScale = screenScale * frameH / parseFloat(sprite.dataset.s);			
			const finalScale = shouldScale ? (targetScale / autoScale) : 1;

			// STEP 2: Compute the final X translation needed, consider the final scale, data.x, bLeft and the commanded posX. PosX is measured in percentage where 0 means center of the screen, 50 means the center of the right side of the screen. 
			// If bLeft is undefined but posX is a number, set bLeft to true when X is >0, set bLeft to false when x is <0, and toggle bLeft (.left abd .right) when posX is 0.
			// If bLeft and posX are both undefined, clear .left and .right and do not apply x offset. 
			let finalX = 0;
			let flipFactor = 1;

			if (shouldFaceLeft || shouldFaceRight) {
				const dataX = parseFloat(sprite.dataset.x);
				const isNaturalLeft = dataX >= 0;
				flipFactor = (shouldFaceLeft === isNaturalLeft) ? 1 : -1;
				const naturalCenter = (isNaturalLeft) ? naturalW / 2 : -naturalW / 2;
				const recenterX = flipFactor * ((naturalCenter - dataX) * finalScale);
				const stagePos = (posX / 100) * frameW / 2 || 0;
				finalX = recenterX + stagePos;
			}

			// STEP 3: Compute the final Y translation needed. Consider the final scale, the y offset, posY, and the default ground line which is 25% of the frame's height below the frame. PosY is a percentage of the frame's height above the ground line. 
			// Store the state of whether the sprite is ground using .grounded.
			let finalY = 0;
			if (shouldGround) {
				// scaleShift is the amount the sprite should shift down (+Y) when the sprite is scaled
				const scaleShift = (frameH * (1 - finalScale)) / 2; 
				// groundShift is the amount to shift when the ground line is not the bottom of the track.
				const groundShift = frameH *0.30;
				// liftPx is the amount to shift up when the sprite is supposed to be above ground line.
				const liftPx = (posY / 100) * frameH;

				// dataY is the amount in raw image pixels of the sprite's ground line
				const dataY = parseFloat(sprite.dataset.y); // pixels UP from bottom edge
				// scaledYOffset is the amount to shift down so the sprite's ground line aligns with the stage's ground line.
				// Even when finalScale is 1, dataY needs to be scaled due to fit to height.
				// The math is scaledYOffset = dataY * finalScale * autoScale = dataY * targetScale.		
				const scaledYOffset = dataY * targetScale;

				if(!StageLive()){
					// If showing in backstage, use the bottom edge of the track as the ground line.
					finalY = scaleShift + scaledYOffset - liftPx;	
				}else{
					finalY = scaleShift + scaledYOffset - liftPx + groundShift ;
				}
			}

			// STEP 4: Apply the combined transformation.
			const finalFlip = (shouldFaceLeft || shouldFaceRight) ? flipFactor : 1;

			// Explicitly reset origin to center to ensure predictable behavior
			sprite.style.scale = `${finalScale * finalFlip} ${finalScale}`;
			sprite.style.translate = `${finalX}px ${finalY}px`;
			// Shrink the margins in backstage
			if(StageLive() || !shouldGround || !shouldScale){
				sprite.style.marginLeft = 0;
				sprite.style.marginRight = 0;	
			}else{
				sprite.style.marginLeft = `-${autoScale * naturalW/5}px`;
				sprite.style.marginRight = `-${autoScale * naturalW/5}px`;	
			}
			
		}
		function Stage(){
			return document.querySelector('.stage-area');
		}
		function StageActorsOff() {
			const stageEl = document.getElementById('stage-area');
			// Deactivate all actors.
			stageEl.querySelectorAll('.actor.active').forEach(a => { a.classList.remove('active'); });
		}
		async function StageChange(url) {
			await fadeLoadingScreen(true);
			// 20260203: Auto hide all actors until they speak again.
			StageActorsOff();
			// Reset the narration streak
			const bubble = document.querySelector('.speech-bubble');
			bubble.classList.remove('narrative-mode');

			const stageEl = document.getElementById('stage-area');
			stageEl.style.backgroundImage = `url(${url})`;
			await new Promise(r => setTimeout(r, 200));
			await fadeLoadingScreen(false);
		}
		function StageFade() {
			// 20260119: Sasha: Fades the stage area away.
			const stageEl = document.getElementById('stage-area');
			StageActorsOff();
			setTimeout(() => { stageEl.classList.remove('active'); }, 800);
		}
		function StageLive() {
			// 20260119: Skyle: Returns true if the stage is live.
			return document.querySelector('.stage-area.active') ? true : false;
		}
		async function StageQuit(e) {
			// 20260119: Skyle: When the stage play button is doubleclicked, let the user quit the stage after a modal choice.
			if (!e.target.closest('.stage-next-btn')) return false;
			e.stopPropagation();
			if (StageLive()) {
				if (await showConfirm('Quit this script?')) {
					ScriptEnd();
					SpeechBubbleShow(false);
					ChoiceBubblePop(null,true);
					StageFade();
				}
			}
		}
		async function StageSet(args) {
			// 20260119: Sasha: Get the scene from current filter and show it if it is not already shown.
			const stageEl = document.getElementById('stage-area');
			// 20260125: Sasha: By default, the stage scene is the script card's cover image.
			let scene = null;
			args = args.trim();
			const argsU = args.toUpperCase()|| "SEASON";
			const prefix = args.charAt(0);

			if (argsU === "THIS") {
				//scene = getActiveCardData();
				scene = DATAByID(ScriptEngine().dataset.p);
			} else if (argsU === "SEASON") {
				const date = new Date();
				const month = date.getMonth();
				const seasons = ['WINTER', 'SPRING', 'SUMMER', "AUTUMN"];
				const curSeason = seasons[Math.floor(((month + 1) % 12) / 3)];
				const curMonthName = date.toLocaleString('en-US', { month: 'long' });
				scene = DATABestMatch(["[SCENE]"], [curSeason, curMonthName]);
			} else if (argsU === "USER") {
				scene = FilterDraw();
			} else if (args.isOnlyDigits()) {
				// Assume it is the ID
				scene = DATAByID(args);
			}else if(args.includes("/")){
				// if it contains /, assume that it is an URL.								
				StageChange(args);
				stageEl.classList.add('active');
				return true;
			}else if(prefix==='+'){
				// Apply the remaining as a class.
				Stage().classList.add(args.rightOf('+').trim());
				return true;
			}else if(prefix==='-'){
				// Apply the remaining as a class.
				Stage().classList.remove(args.rightOf('-').trim());
				return true;
			}else{
				// 20260203: Evelyn: Interpret the rest as a comma separated list of tags.
				const inlineTags = argsU.split(',');
				scene = DATABestMatch([],inlineTags);
			}
			if (!scene) { scene = getActiveCardData(); }
			if (scene) {
				StageChange(DATAFullResURL(scene));
			} else {
				// If there is no match, reset the background image to nothing.				
				StageChange('');
			}
			stageEl.classList.add('active');
			return true;
		}
		function summonGateGuardian() {
			// 20251225: LRRH, StarTree: On mobile it is too easy to accidentally refresh the page and lose the arrangement.
			if (true) {
				// 20251226: LRRH: After implementing auto save, this doesn't seem necessary.
				// 20251226: Cardinal: Need this if the user loads local collections.
				window.addEventListener('beforeunload', (event) => {
					event.preventDefault();
					//fadeLoadingScreen(true);
					event.returnValue = '';
				});
			}
			// 20251228: Cardinal: Multi-tap storage sync
			window.addEventListener('storage', (event) => {
				if (event.key === 'multitrack_snapshot') {
					// NOTE: the listening cannot run a confirm and would skip it.
					memDOM(true);
					showToast("✨ Workspace synced from another tab");
				}
			});

			// 20251226: LRRH: There might need to be a check or a greeting before removing the loading screen.
			memDOM(true);
			memDEV(true);
			fadeLoadingScreen(false);
		}
		function summonFairyQueen() {
			// 20251226: StarTree: This is supposed to handle all clicks on staging areas.
			document.addEventListener('click', async (e) => {
				if (await fairyRemovalCheck(e)) { return; }
				if (await fairyBubblePopping(e)) { return; }
				if (await fairyBlessCheck(e)) { return; }
				if (await fairyActiveCardCheck(e)) { return; }
				/*if (e.target.closest("#tab-card-notes")) {
					e.stopPropagation();
					toggleNodeDetails(e);
					return;
				}*/
				if (e.target.closest("#multitrack")) {
					e.stopPropagation();
					toggleCommandPanel(e);
					toggleTab(e, 'tab-controls');
				}
			});
			// 20251226: StarTree: Double Click
			document.addEventListener('dblclick', (e) => {
				StageQuit(e);
				showSplash(e);
			});
			// 20260110: Sasha: Resizing the main area when the command-panel is shown.
			const cp = document.getElementById('command-panel');
			new ResizeObserver(() => {

				const multitrack = document.getElementById('multitrack');
				const sidebar = document.getElementById('sidebar');
				const panelHeight = cp.offsetHeight;
				const panelWidth = cp.offsetWidth;
				//if (isMobile()) {
				if (panelWidth >= window.innerWidth) {
					if (multitrack) multitrack.style.paddingBottom = `${panelHeight}px`;
					if (sidebar) sidebar.style.paddingBottom = `${panelHeight}px`;
				} else {
					// RESET styles for Desktop so they don't stay shifted
					if (multitrack) multitrack.style.paddingBottom = "0px";
					if (sidebar) sidebar.style.paddingBottom = "0px";
				}
			}).observe(cp);
		}
		function summonQuickCast() {
			String.prototype.between = function (substring1, substring2) {
				return this.rightOf(substring1).leftOf(substring2);
			}
			String.prototype.isOnlyDigits = function () {
				return /^\d+$/.test(this);
			};
			String.prototype.leftOf = function (substring) {
				return this.split(substring)[0];
			}
			String.prototype.rightOf = function (substring, bInsensitive) {
				// 20260125: Evelyn: Returns the remaining string after the first instance of substring.
				const strcc = bInsensitive? this.toUpperCase(): this;
				const substringcc = bInsensitive? substring.toUpperCase():substring
				const index = strcc.indexOf(substringcc);
				if (index === -1) return "";
				return this.substring(index + substring.length);
			}
		}
		function toggleAddTag(bInit) {
			// 20260110: V: Toggle the visibility, but don't hide it if is not blank.
			const addTagInputBox = document.getElementById("assign-tag-input");
			if (bInit) {
				// if the card's tag list is blank, display this so the user can add a tag.
				const cardTagList = document.getElementById("card-tag-list");
				if (cardTagList.innerHTML == "") {
					addTagInputBox.style.display = "block";
				}
				return;
			}
			if (isHidden("assign-tag-input")) {
				addTagInputBox.style.display = "block";
			} else {
				if (addTagInputBox.value.trim() == "") {
					addTagInputBox.style.display = "none";
				}
			}
		}
		function toggleAllBlockByID(e, aID) {
			// 20251227: Black: Consolidating the toggle code.
			e.stopPropagation();
			const blocks = document.querySelectorAll("#" + aID);
			blocks.forEach(block => {
				if (block.style.display == "block") {
					block.style.display = "none";
				} else {
					block.style.display = "block";
				}
			});
		}
		function ToggleByID(elThis,aID){
			// 20260207: StarTree: Toggle the display by element ID.
			const el = document.getElementById(aID);
			el.classList.toggle('active');
			elThis.classList.toggle('on',el.classList.contains('active'));
		}
		function toggleAutoRandom(bTimer = false) {
			// 20260111: Skyle: If Auto Flush is ON, toggle Auto Random mode.			
			const isAutoRandom = document.body.classList.contains("auto-random");
			if (bTimer && !isAutoRandom) { return; }
			if (isAutoRandom && !bTimer) {
				// If auto random mode is ON and this is not called by a timer, then the user has just clicked to disable the mode. 
				document.body.classList.remove("auto-random");
				if (autoRandomTimer) clearTimeout(autoRandomTimer);
				autoRandomTimer = null;
				autoRandomTrack = null;
				return;
			}
			const activeCard = getActiveCard();
			if (!isAutoRandom) {
				document.body.classList.add("auto-random");
				if (activeCard) { autoRandomTrack = activeCard.closest(".track"); }
			}
			// Spawn a card and schedule the next one in 5 seconds.
			createCard();
			if (autoRandomTimer) clearTimeout(autoRandomTimer);
			autoRandomTimer = setTimeout(() => {

				toggleAutoRandom(true);
			}, 5000);
		}
		function toggleBottomMenu(e) {
			if (e) e.stopPropagation(); // Prevents the 'click outside' from firing instantly

			const container = document.getElementById('bottom-nav');
			const panel = document.getElementById('bottom-menu-items');

			const isOpening = !panel.classList.contains('active');

			if (isOpening) {
				panel.classList.add('active');
				container.classList.add('active-state');
			} else {
				// This part handles clicking the semi-circle while it's already open
				panel.classList.remove('active');
				container.classList.remove('active-state');
			}
		}
		function toggleNodeDetails(el) {
			// 20260111: Skyle: Hide the advanced settings in card details.
			const tagSec = document.getElementById('card-tag-section');
			const fTitle = document.getElementById("card-title");
			const details = document.querySelector('.card-details');
			const cta = document.getElementById('card-textareas');

			if (isHidden("card-id")) {
				tagSec.style.display = "block";
				fTitle.style.display = "block";
				details.style.display = "block";
				cta.style.display = "none";
				el.innerHTML = "△";
				el.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
			} else {
				tagSec.style.display = "none";
				fTitle.style.display = "none";
				details.style.display = "none";
				cta.style.display = "flex";
				el.innerHTML = "▽";
			}
		}
		function togglePinActiveCard(e) {
			e.stopPropagation();
			// 1. Find the active card. 
			// This assumes you add an 'active' class when hovering or clicking.
			const activeCard = document.querySelector('.card.is-active');
			if (activeCard) {
				// 2. Toggle the 'pinned' class
				const isPinned = activeCard.classList.toggle('pinned');
				// 3. Optional: Provide haptic/visual feedback or save state				
				// If you use your memDOM function, save the change:
				if (typeof memDOM === "function") {
					memDOM(false, "multitrack");
				}
			} else {
				console.warn("No active card ;found to pin.");
			}
		}
		function toggleRemovalMode(btn) {
			// 20251226: StarTree, Gemini
			isRemovalMode = !isRemovalMode;
			// Toggle visual state of the button
			btn.classList.toggle('removal-active', isRemovalMode);
			// Toggle a class on the body so CSS can change card appearances
			document.body.classList.toggle('removal-mode', isRemovalMode);
			showToast(isRemovalMode ? "REMOVAL MODE: ON" : "REMOVAL MODE: OFF");
		}
		function toggleTab(e, aID) {
			// 20251230: Cardinal: A generic reusable function to show one tab and hide the rest.
			e.stopPropagation();
			const targetTab = document.getElementById(aID);
			if (!targetTab) return;
			const tabFrame = targetTab.parentElement;
			Array.from(tabFrame.children).forEach(child => {
				child.style.display = 'none';
				child.classList.remove('active-tab-content');
			});
			targetTab.style.display = 'block';
			targetTab.classList.add('active-tab-content');
		}
		function Track() {
			const activeCard = getActiveCard();
			return activeCard.closest(".track");
		}
		function TrackFocus(elButton) {
			// 20260114: Albatross: Temporarily override the flex num of other tracks to 0, but use a dataset on the track to remember the track's original flex values.
			// When this button is clicked, check if this track is marked .focus, if it is already in .focus, toggle it off and restore the flex of the other tracks in the multitrack.
			const track = Track();
			if (!track) return;
			const multitrack = track.closest("#multitrack") || track.closest(".multitrack");
			if (!multitrack) return;
			const isAlreadyFocused = track.classList.contains('focus');
			const allTracks = multitrack.querySelectorAll('.track');
			if (isAlreadyFocused) {
				// --- TOGGLE OFF: Restore Everyone ---
				allTracks.forEach(t => {
					const savedFlex = t.dataset.originalFlex || "1";
					t.style.flex = `${savedFlex} ${savedFlex} 0%`;
					t.style.overflow = "";
					t.style.opacity = "1";
					t.classList.remove('focus');
				});
			} else {
				// --- TOGGLE ON: Save & Hide Others ---
				allTracks.forEach(t => {
					// 1. Remember what it was (read from style, default to 1)
					const currentFlex = t.style.flexGrow || "1";
					t.dataset.originalFlex = currentFlex;

					// 2. If it's NOT the chosen track, squash it
					if (t !== track) {
						t.style.flex = "0 0 0%";
						t.style.overflow = "hidden";
						t.style.opacity = "0";
						t.classList.remove('focus');
					} else {
						// The Star of the Show
						t.style.flex = `${currentFlex} ${currentFlex} 0%`;
						t.classList.add('focus');
					}
				});
			}
		}
		function TrackMove(bNext = true) {
			// 1. Get the current context
			const track = activeTrack();
			if (!track) return;

			// 2. Identify the target sibling
			const targetSibling = bNext
				? track.nextElementSibling
				: track.previousElementSibling;

			// 3. Safety Check: Only swap if a sibling exists AND it's actually a track
			// (This prevents swapping with a header or a footer by accident)
			if (targetSibling) {//&& targetSibling.classList.contains('track')) {
				if (bNext) {
					targetSibling.after(track);
				} else {
					targetSibling.before(track);
				}

				// Optional: Visual polish to show the move happened
				//track.classList.add('moving');
				//setTimeout(() => track.classList.remove('moving'), 300);
			}
		}
		function URLHotLink(url){
			// 20260205: LRRH: Converts a google drive link to a hotlink
			// Doesn't work. Use Google Photo instead.
			url = url.trim();
			const idMatch = url.match(/\/d\/([^/]+)/);
			if (idMatch && idMatch[1]) {
				const fileId = idMatch[1];				
				return `https://drive.usercontent.google.com/download?id=${fileId}`;
			}
			return url;
		}
		/* UNSORTED CODE */

		function openChoicePreview(code, text, el) {
			// Show the text + "Choose", "Collapse", "Delete" buttons
			// If chosen:
			// window.currentChoices.add(code);
			// el.remove();
			// ScriptStart(); // Resume the script
		}
		function markDirty(elThis) {
			// 20251230: Cardinal
			const savedValue = elThis.dataset.original || "";
			const currentValue = encodeURIComponent(elThis.value || "");
			if (savedValue !== currentValue) {
				elThis.classList.add('unsaved');
			} else {
				elThis.classList.remove('unsaved');
			}
			elThis.classList.add('active');
		}
		function showConfirm(message) {
			const modal = document.getElementById('custom-confirm');
			const text = modal.querySelector('#confirm-text');
			const btnYes = document.getElementById('btn-yes');
			const btnNo = document.getElementById('btn-no');
			text.innerText = message;
			modal.style.display = 'flex';
			return new Promise((resolve) => {
				resolveConfirm = resolve;
			});
		}
		function confirmChoice(choice) {
			const modal = document.getElementById('custom-confirm');
			if (modal) modal.style.display = 'none';
			// Only resolve if we have a pending promise
			if (resolveConfirm) {
				resolveConfirm(choice);
				resolveConfirm = null; // Reset it so it can't be clicked twice
			}
		}
		// HOW TO USE IT IN YOUR STORAGE LISTENER:
		window.addEventListener('storage', async (event) => {
			if (event.key === 'multitrack_snapshot') {
				const userSaidYes = await showConfirm("Another tab has updated local storage. Sync with those changes?"); // Pauses here for the user!
				if (userSaidYes) {
					memDOM(true, "multitrack");
				}
			}
		});
		function activeTrack() {
			return getActiveCard().closest('.track');
		}
		function activeTrackWidth(delta = 1) {
			// 20260114: Natalie: Expand or Shrink a track
			// 1. Get the track using your helper
			const track = activeTrack();

			// 2. Safety check: if no track is found, stop immediately
			if (!track) return;

			// 3. Initialize flex if it's missing or empty
			// We use getComputedStyle to see what the browser actually calculated
			let currentFlex = parseFloat(window.getComputedStyle(track).flexGrow);
			if (isNaN(currentFlex)) {
				track.style.flex = "1 1 0%";
				currentFlex = 1;
			}
			// 4. Calculate new value
			let flexNum = Math.max(0, currentFlex + delta);
			// 5. Apply the new styles
			track.style.flexGrow = flexNum;
			track.style.flexShrink = flexNum;
			track.style.flexBasis = "0%";
			showToast("Track Size: " + flexNum);
			memDOM();
		}
		function addTrackRelative(e, direction) {
			e.stopPropagation();
			const multitrack = document.getElementById('multitrack');
			const activeCard = document.querySelector('.card.is-active');

			// 1. Identify the reference track
			// If no card is active, we default to the first track or create one if none exist
			let referenceTrack = activeCard ? activeCard.closest('.track') : multitrack.querySelector('.track');

			if (!referenceTrack) {
				// Fallback: If no tracks exist at all, just use babyStep
				babyStepAddTrack();
				return;
			}

			// 2. Create the new track element
			const newTrack = document.createElement('div');
			newTrack.classList.add('track');
			//newTrack.id = 'track'; // Keeping ID consistent with your CSS selectors

			// Add the scroll listener so theater-mode centering works on the new track
			//newTrack.addEventListener('scroll', updateCenteredCard);

			// 3. Insert relative to the reference
			if (direction === -1) {
				// Insert BEFORE (Above in Horizontal / Left in Vertical)
				referenceTrack.insertAdjacentElement('beforebegin', newTrack);
				showToast("Track Added Below/Left");
			} else {
				// Insert AFTER (Below in Horizontal / Right in Vertical)
				referenceTrack.insertAdjacentElement('afterend', newTrack);
				showToast("Track Added Above/Right");
			}

			// 4. Update UI to reflect the new layout
			updateAllCardOverlays();
			memDOM();
		}

		/**
		 * Complementary function for the '-' buttons in your staging panel
		 */
		async function removeTrack(targetTrack) {
			// Keep the last track.
			if (!(targetTrack.closest('#multitrack').querySelectorAll('.track').length > 1)) {
				showToast("The last track cannot be deleted.")
				return;
			}
			if (targetTrack && targetTrack.classList.contains('track')) {
				let cardsCount = targetTrack.querySelectorAll(".card").length;
				if (cardsCount > 0) {
					if (await showConfirm("The target track is not empty. Keep it?")) { return; }
				}
				let starsCount = targetTrack.querySelectorAll(".card.pinned").length;
				if (starsCount == 0 || !await showConfirm("The target track has ⭐ cards. Keep them?")) {
					targetTrack.remove();
					showToast("Track Removed");
					memDOM();
					return;
				}
				targetTrack.querySelectorAll(".card:not(.pinned)").forEach(card => {
					card.remove();
				});
				memDOM();
			} else {
				showToast("No track found in that direction");
			}
		}
		function removeTrackRelative(e, direction) {
			e.stopPropagation();
			const activeCard = document.querySelector('.card.is-active');
			if (!activeCard) {
				showToast("Please select a card first.");
				return;
			}
			const currentTrack = activeCard.closest('.track');
			const multitrack = document.getElementById('multitrack');

			// Logic: direction -1 targets the track ABOVE the current one, 1 targets BELOW.
			// 0 (if you wanted) would target the current track itself.
			const bodyWrap = document.getElementById('body-wrap');
			const isVertical = bodyWrap.classList.contains('max-width');
			let targetTrack;
			if (direction === -1) {
				if (isVertical) {
					targetTrack = currentTrack.nextElementSibling;
				} else {
					targetTrack = currentTrack.previousElementSibling;
				}

			} else if (direction === 1) {
				if (isVertical) {
					targetTrack = currentTrack.previousElementSibling;
				} else {
					targetTrack = currentTrack.nextElementSibling;
				}
			}

			removeTrack(targetTrack);
		}
		function babyStepAddTrack() {
			const multitrack = document.getElementById('multitrack');

			// 1. Create a second track
			const newTrack = document.createElement('div');
			newTrack.classList.add('track');
			newTrack.style.flex = "1"; // This splits the space 50/50
			newTrack.style.border = "2px dashed rgba(255,255,255,0.2)";
			//newTrack.innerHTML = "<div style='color:gray; padding:5px;'>Track 2 Active</div>";

			// 2. Ensure the first track is also flexible
			document.querySelector('.track').style.flex = "1";

			multitrack.appendChild(newTrack);
			showToast("Multi-track split enabled");
		}
		/**
		 * Moves the active card within its track based on mode-restricted directions.
		 * @param {string} direction - 'up', 'down', 'left', or 'right'
		 */
		function moveActiveCard(e, direction) {
			e.stopPropagation();
			const activeCard = document.querySelector('.card.is-active');
			if (!activeCard) return;

			const bodyWrap = document.getElementById('body-wrap');
			const isVerticalMode = bodyWrap.classList.contains('max-width');
			const currentTrack = activeCard.closest('.track');

			// 1. Determine if we are moving WITHIN the track or BETWEEN tracks
			let isCrossTrackMove = false;
			if (isVerticalMode) {
				// In Vertical, Left/Right jumps tracks
				if (direction === 'left' || direction === 'right') isCrossTrackMove = true;
			} else {
				// In Horizontal, Up/Down jumps tracks
				if (direction === 'up' || direction === 'down') isCrossTrackMove = true;
			}

			if (isCrossTrackMove) {
				// --- LOGIC FOR MOVING TO ANOTHER TRACK ---
				// 20251227: Cardinal: If there is no next track, create the track.
				let targetTrack;
				if (direction === 'down' || direction === 'left') {
					targetTrack = currentTrack.previousElementSibling;
					if (!targetTrack || !(targetTrack.classList.contains('track'))) {
						addTrackRelative(e, -1);
					}
					targetTrack = currentTrack.previousElementSibling;
				} else {
					targetTrack = currentTrack.nextElementSibling;
					if (!targetTrack || !(targetTrack.classList.contains('track'))) {
						addTrackRelative(e, +1);
					}
					targetTrack = currentTrack.nextElementSibling;
				}

				if (targetTrack && targetTrack.classList.contains('track')) {
					// Get current coordinates of the active card to determine where it "was"
					const rect = activeCard.getBoundingClientRect();
					const x = rect.left + rect.width / 2;
					const y = rect.top + rect.height / 2;

					// Find visual insertion point in the new track
					const sibling = getInsertionSibling(targetTrack, x, y);

					if (sibling) {
						targetTrack.insertBefore(activeCard, sibling);
					} else {
						targetTrack.appendChild(activeCard);
					}

					// Ensure the new track scrolls the moved card into view
					setTimeout(() => {
						activeCard.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
					}, 50);
				}
			} else {
				// --- LOGIC FOR MOVING WITHIN THE SAME TRACK ---
				if (direction === 'left' || direction === 'up') {
					const prev = activeCard.previousElementSibling;
					if (prev) activeCard.parentNode.insertBefore(activeCard, prev);
				} else {
					const next = activeCard.nextElementSibling;
					if (next) activeCard.parentNode.insertBefore(activeCard, next.nextElementSibling);
				}

				// Keep focus on the card after it moves
				activeCard.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
			}

			// Refresh overlays in case position-based logic (like theater mode) needs to update
			updateAllCardOverlays();
			memDOM();
		}
		function moveCurrentCard(direction) {
			const track = document.querySelector('.track');
			const centeredCard = track.querySelector('.card.is-centered');

			if (!centeredCard) return;

			if (direction === -1) {
				// Move Left/Up: Insert before the previous sibling
				const prev = centeredCard.previousElementSibling;
				if (prev && prev.classList.contains('card')) {
					track.insertBefore(centeredCard, prev);
				}
			} else if (direction === 1) {
				// Move Right/Down: Insert after the next sibling
				const next = centeredCard.nextElementSibling;
				if (next && next.classList.contains('card')) {
					// insertBefore(node, nextNext) effectively moves it after next
					track.insertBefore(next, centeredCard);
				}
			}

			// After moving, re-center the view on the same card immediately
			setTimeout(() => {
				centeredCard.scrollIntoView({
					behavior: 'smooth',
					block: 'center',
					inline: 'center'
				});

				// Refresh UI if you have counters or specific ordering logic
				if (typeof refreshAllUI === "function") refreshAllUI();
			}, 50);
		}
		function persistentWallpaper() {
			const savedWallpaper = localStorage.getItem('gallery_wallpaper');
			const defaultWallpaper = "https://substackcdn.com/image/fetch/$s_!KRIG!,w_720,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc5630f5a-5397-4ad1-b713-9ade6321e486_1536x1024.jpeg";
			const b = document.body;

			// Apply the image logic
			if (savedWallpaper) {
				b.style.backgroundImage = `url("${getFullResURL(savedWallpaper)}")`;
			} else {
				b.style.backgroundImage = `url("${getFullResURL(defaultWallpaper)}")`;
			}
		}
		function setCenteredAsWallpaper(e) {
			e.stopPropagation();
			const body = document.body;
			const activeCard = document.querySelector('.card.is-active img');
			if (!activeCard) {
				body.style.backgroundImage = 'none';
				localStorage.removeItem('gallery_wallpaper'); // Remove from storage
				showToast("Wallpaper Removed");
				return;
			}

			const url = getFullResURL(activeCard.src);

			// Normalize background string for comparison
			const urlComp = url.replace(/url\(["']?/, '').replace(/["']?\)/, '');
			const currentBg = body.style.backgroundImage.replace(/url\(["']?/, '').replace(/["']?\)/, '');

			if (currentBg === urlComp) {
				// Toggle OFF: If already set, remove it
				body.style.backgroundImage = 'none';
				localStorage.removeItem('gallery_wallpaper'); // Remove from storage
				showToast("Wallpaper Removed");
			} else {
				// Toggle ON: Set new wallpaper
				body.style.backgroundImage = `url('${getFullResURL(url)}')`;
				localStorage.setItem('gallery_wallpaper', url); // Save to storage
				showToast("Wallpaper Set");
			}
		}
		function setWallpaper(url) {
			const body = document.body;
			// Normalize the URL for comparison (removing potential browser-added quotes/wrappers)
			const cleanUrl = url.replace(/['"]/g, '');
			const currentBg = body.style.backgroundImage.replace(/url\(["']?/, '').replace(/["']?\)/, '');

			// TOGGLE: If it's already the wallpaper, remove it
			if (currentBg === cleanUrl && cleanUrl !== "") {
				body.style.backgroundImage = 'none';
				localStorage.removeItem('gallery_wallpaper'); // Clear from storage
				showToast("Wallpaper Removed");
				document.querySelectorAll('.sq-btn').forEach(btn => btn.classList.remove('active-gold'));
			} else {
				// SET: Apply and save
				body.style.backgroundImage = `url('${getFullResURL(cleanUrl)}')`;
				localStorage.setItem('gallery_wallpaper', cleanUrl); // Save to storage
				showToast("Wallpaper Set");

				// Update active button state
				document.querySelectorAll('.sq-btn').forEach(btn => btn.classList.remove('active-gold'));
				if (event && event.currentTarget) {
					event.currentTarget.classList.add('active-gold');
				}
			}
		}
		async function smartImport() {

			let clipboardText = "";
			try {
				// 1. Try to read the clipboard
				let rawText = await navigator.clipboard.readText();
				// 2. Trim whitespace AND strip leading/trailing quotes
				clipboardText = rawText ? rawText.trim().replace(/^"|"$/g, '') : "";
			} catch (err) {
				console.warn("Clipboard access denied, defaulting to file picker.");
			}

			// 2. Determine if it's a JSON Collection or a single Asset
			const isJson = clipboardText.toLowerCase().endsWith('.json');
			const isUrl = clipboardText.startsWith('http') || clipboardText.startsWith('data:');
			const isFilePath = clipboardText.includes('/') || clipboardText.includes('\\');

			if (isJson && isUrl) {
				// --- BRANCH A: Existing JSON Collection Logic ---
				//loadCollectionFromUrl(clipboardText);
				showToast("URL detected in clipboard. Importing...");
				importFromURL(clipboardText);
			}
			else if (clipboardText && (isUrl || isFilePath)) {
				// --- BRANCH B: New Single Entry Logic ---
				addNewEntryFromClipboard(clipboardText);
			}
			else {
				// --- BRANCH C: Fallback to File Browser ---
				//openFileBrowserForJson();
				if (isMobile()) {
					const input = document.getElementById('mobile-file-input');
					input.click();
				} else {
					document.getElementById('json-input').click();
				}

			}
		}
		function handlePlusButton() {
			// If on mobile (or just as an alternative)
			const input = document.getElementById('mobile-file-input');

			// Ask user: Paste Link or Upload?
			const choice = confirm("Press OK to Upload from Gallery, Cancel to Paste Link");

			if (choice) {
				input.click();
			} else {
				const link = prompt("Paste image URL:");
				if (link) createCard({ p: link, t: ['unlabeled'], n: 'New Image' });
			}
		}
		function handleSoundCommand(name, assetKey, source = null) {
			// 1. If a source is provided, register/update the asset first
			if (source) {
				if (!assetLibrary[assetKey]) {
					// Check if it's already a full URL or needs the Base64 prefix
					const src = (source.startsWith('data:') || source.startsWith('http') || source.startsWith('./'))
						? source
						: "data:audio/mpeg;base64," + source;

					assetLibrary[assetKey] = new Audio(src);
					//DEBUG(`Asset Created: ${assetKey}`);
				}
			}

			// 2. Create the mapping between the Name and the AssetName
			if (!soundMap[name]) {
				soundMap[name] = new Set();
			}

			// Ensure the asset actually exists before mapping (optional safety check)
			if (assetLibrary[assetKey]) {
				soundMap[name].add(assetKey);
				DEBUG(`Mapped "${name}" to asset "${assetKey}"`);
			} else {
				console.warn(`Cannot map "${name}" to "${assetKey}": Asset not found.`);
			}
		}
		function handleTagKey(e) {
			// Only trigger on Enter
			if (e.key === 'Enter' || e.keyCode === 13) {
				e.preventDefault();
				const input = e.target;
				const tag = input.value.trim().toUpperCase();

				if (tag === "") return;

				// 1. Add to the currently active card if it exists
				const activeCardData = getActiveCardData();
				if (activeCardData) {
					if (!activeCardData.t.includes(tag)) {
						activeCardData.t.push(tag);

						// 2. Ensure the tag exists in the global cloud list too
						if (!ALL_TAGS.includes(tag)) {
							ALL_TAGS.push(tag);
							ALL_TAGS.sort();
						}

						showToast(`Tagged active card: ${tag}`);
					}
				} else {
					showToast("No active card selected to tag.");
				}

				// 3. Clear the input and reset UI mode
				clearAssignmentTag();

				// 4. Update everything
				refreshAllUI();
				renderCardTags(); // Refresh the pill list in the command panel
				memDOM();         // Persist changes
			}
		}
		function updateAssignmentUI() {
			const input = document.getElementById('assign-tag-input');
			if (!input) return;

			const val = input.value.trim().toUpperCase();
			const isActive = val !== "";

			document.body.classList.toggle('tag-assign-active', isActive);

			// Target ONLY files and cards
			const targets = document.querySelectorAll('.file-item, .card');

			targets.forEach(el => {
				const id = el.dataset.id;
				if (!id) return;

				// Look up the item in your master DATA array
				const item = DATA.find(i => i.u === id);

				// If the item exists and its tags array (item.t) contains the input value
				const hasTag = item && item.t.includes(val);

				if (isActive && hasTag) {
					el.classList.add('already-has-tag');
				} else {
					el.classList.remove('already-has-tag');
				}
			});
		}
		function clearAssignmentTag() {
			const input = document.getElementById('assign-tag-input');
			input.value = "";
			updateAssignmentUI();
		}
		// Handle the file selection
		// This should be in your init code or script root
		document.getElementById('mobile-file-input').onchange = async (e) => {
			const file = e.target.files[0];
			if (!file) return;

			// BRANCH 1: User picked a JSON file (Collection)
			if (file.type === "application/json" || file.name.endsWith('.json')) {
				importJSON(e.target);
				// Note: importJSON handles its own reader and resetting input.value
			}

			// BRANCH 2: User picked an Image (Single Entry)
			else if (file.type.startsWith('image/')) {
				// Generate a temporary browser path for the mobile file
				const blobUrl = URL.createObjectURL(file);

				// Pass it to your existing function
				// This will handle tags, Orphans, and UI refresh automatically
				await addNewEntryFromClipboard(blobUrl);

				showToast(`Added: ${file.name}`);
			}

			// Reset the input so the same file can be picked again if deleted
			e.target.value = '';
		};
		async function addNewEntryFromClipboard(path) {
			const tagsToAdd = Array.from(activeTags);
			const searchInput = document.getElementById('master-search');
			const searchTag = searchInput.value.trim().toUpperCase();
			if (searchTag !== "" && !tagsToAdd.includes(searchTag)) {
				tagsToAdd.push(searchTag);
			}
			// Get extension, remove query params, and check if it's not empty
			const extMatch = path.split(/[\\/]/).pop().split('?')[0].split('#')[0].split('.');
			if (extMatch.length > 1) {
				const extTag = "." + extMatch.pop().toLowerCase();
				// Use a safe prefix like "type:" or just the extension name
				const formattedExt = `${extTag}`;
				if (!tagsToAdd.includes(formattedExt)) {
					tagsToAdd.push(formattedExt);
				}
			}

			// Create the new item object
			// This regex /[\\/]/ means "split by \ OR /"
			const filename = path.split(/[\\/]/).pop().split('#')[0].split('?')[0] || "New Entry";
			// 1. Duplicate check against current master DATA
			if (DATA.some(item => item.u === path)) {
				if (!await showConfirm("This item is already in your list. Add it again?")) {
					return;
				}
			}
			let pid = generatePID();
			if (DATA.some(item => item.p === pid)) { pid = path; }
			const newItem = {
				p: pid,
				n: filename,
				t: tagsToAdd,
				u: path,
			};

			// 2. Find or Create the [Orphan Files] collection in savedPaths
			const orphanName = "[Orphan Files]";
			let orphanEntry = savedPaths.find(p => p.path === orphanName);

			if (!orphanEntry) {
				// Create the "Ghost Collection" if it doesn't exist
				orphanEntry = {
					path: orphanName,
					checked: true,
					data: []
				};
				savedPaths.push(orphanEntry);
			} else {
				orphanEntry.checked = true;
				if (!orphanEntry.data) {
					orphanEntry.data = [];
				}
			}
			// 3. Add the file to this ghost collection's data
			// Prevent duplicates within orphans
			if (!orphanEntry.data.some(item => item.p === path)) {
				orphanEntry.data.push(newItem);
			}


			// 4. Update the UI
			renderPathList();        // Refreshes the checkbox list so [Orphan Files] appears
			loadActiveCollections(); // Rebuilds the main DATA array from all checked paths

			// Create card from the version now inside DATA (to ensure references match)
			const finalItem = DATA.find(i => i.p === pid);
			if (finalItem) createCard(finalItem);
		}
		async function importFromURL(url) {
			try {
				const response = await fetch(url);
				if (!response.ok) throw new Error(`HTTP ${response.status}`);
				const importedData = await response.json();

				const pathName = url;
				const existingIndex = savedPaths.findIndex(p => p.path === pathName);

				if (existingIndex === -1) {
					savedPaths.push({ path: pathName, checked: true, data: importedData });
				} else {
					savedPaths[existingIndex].data = importedData;
					savedPaths[existingIndex].checked = true;
				}

				renderPathList();
				loadActiveCollections();
				showToast(`Loaded: ${pathName.split('/').pop()}`);
			} catch (err) {
				showToast("Web Import Failed: " + err.message);
				// If web import fails, maybe the user actually wanted the file picker
				document.getElementById('json-input').click();
			}
		}
		function toggleCommandPanel(e) {
			e.stopPropagation();
			const panel = document.getElementById('command-panel');
			if (!panel) return;
			if (isHidden('command-panel')) {
				panel.style.display = 'block';

			} else {

				setTimeout(() => {
					// Double check it's still supposed to be hidden 
					// (in case the user clicked 'open' again quickly)
					if (panel.classList.contains('hidden')) {
						panel.style.display = 'none';
					}
				}, 150);
			}
			panel.classList.toggle('hidden');

		}
		function toggleImages(e) {
			toggleSidebarUpper(e, 'collapsible-images');

			refreshAllUI();
		}
		function toggleOrientation() {
			const body = document.getElementById('body-wrap');
			const btn = document.getElementById('mode-toggle');
			const isVertical = body.classList.toggle('max-width');
			btn.innerText = isVertical ? 'V' : 'H';

			// No need to clear inline styles anymore, 
			// Flexbox handles the transition between row and column.
			//updateCenteredCard();
		}
		function toggleOverlay(btn) {
			const card = btn.closest('.card');
			const overlay = card.querySelector('.card-tag-overlay');

			// Toggle between none and flex
			if (overlay.style.display === 'flex') {
				overlay.style.display = 'none';
			} else {
				overlay.style.display = 'flex';
				// Ensure the overlay content is up to date
				updateAllCardOverlays();
			}
		}
		function togglePathCheck(index) {
			savedPaths[index].checked = !savedPaths[index].checked;
			renderPathList();
			loadActiveCollections();
		}
		function toggleScrollMode(e) {
			e.stopPropagation();
			const body = document.getElementById('body-wrap');
			const btn = document.getElementById('mode-toggle');
			const iconContainer = btn.querySelector('div'); // Targets the icon-h or icon-v div

			if (body.classList.contains('max-width')) {
				// Switch to Horizontal
				body.classList.remove('max-width');
				iconContainer.className = 'icon-h';
				localStorage.setItem('scrollDirection', 'horizontal'); // Save state
			} else {
				// Switch to Vertical
				body.classList.add('max-width');
				iconContainer.className = 'icon-v';
				localStorage.setItem('scrollDirection', 'vertical'); // Save state
			}

			const activeCard = document.querySelector('.card.is-active');
			if (activeCard) {
				// We use a small timeout to ensure the CSS transition/layout 
				// has started before calculating the new scroll position.
				setTimeout(() => {
					activeCard.scrollIntoView({
						behavior: 'smooth',
						block: 'nearest',    // Centers vertically in vertical mode
						inline: 'nearest'    // Centers horizontally in horizontal mode
					});
				}, 400);
			}

			//updateCenteredCard();

		}
		function removePath(index) {
			savedPaths.splice(index, 1);
			renderPathList();
			loadActiveCollections();
		}
		/** * Reorders the active image within its track.
 * @param {number} direction - -1 for Up/Left, 1 for Down/Right
 * @param {string} modeRequirement - 'horizontal' or 'vertical'
 */
		function reorderImage(direction, modeRequirement) {
			const activeCard = document.querySelector('.card.is-active');
			if (!activeCard) return;

			const bodyWrap = document.getElementById('body-wrap');
			const isMaxHeight = bodyWrap.classList.contains('max-height'); // Vertical Mode
			const isMaxWidth = bodyWrap.classList.contains('max-width');   // Horizontal Mode

			// Validation: Only allow movement if the mode matches the button
			if (modeRequirement === 'horizontal' && isMaxHeight) return;
			if (modeRequirement === 'vertical' && isMaxWidth) return;

			if (direction === -1) {
				const prev = activeCard.previousElementSibling;
				if (prev) activeCard.parentNode.insertBefore(activeCard, prev);
			} else {
				const next = activeCard.nextElementSibling;
				if (next) activeCard.parentNode.insertBefore(next, activeCard);
			}

			// Ensure the moved card stays centered in the view
			activeCard.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
		}
		function loadActiveCollections() {
			let combined = [];
			savedPaths.forEach(item => {
				if (item.checked && item.data) {
					combined = combined.concat(Array.isArray(item.data) ? item.data : [item.data]);
				}
			});

			// Fast duplicate removal using a Map
			const uniqueMap = new Map();
			combined.forEach(item => uniqueMap.set(item.p, item));
			DATA = Array.from(uniqueMap.values());

			const tags = new Set();
			DATA.forEach(item => {
				if (item.t && Array.isArray(item.t)) {
					item.t.forEach(tag => tags.add(tag));
				}
			});
			ALL_TAGS = Array.from(tags).sort(); // Update the cloud source

			// URLParam
			if(firstLoad){
				urlParams = new URLSearchParams(window.location.search);
				const rawId = urlParams.get('id');
				if (rawId) {
					ScriptRunID(rawId);					
				}
				firstLoad = false;
			}
			

			refreshAllUI();
		}

		function initScrollDirection() {
			const savedDirection = localStorage.getItem('scrollDirection');
			const body = document.getElementById('body-wrap');
			const btn = document.getElementById('mode-toggle');
			const iconContainer = btn?.querySelector('div');

			if (savedDirection === 'vertical') {
				body.classList.add('max-width');
				if (iconContainer) iconContainer.className = 'icon-v';
			} else {
				// Default to horizontal
				body.classList.remove('max-width');
				if (iconContainer) iconContainer.className = 'icon-h';
			}
		}

		function importJSON(input) {
			const file = input.files[0];
			if (!file) return;
			const reader = new FileReader();
			reader.onload = (e) => {
				try {
					const importedData = JSON.parse(e.target.result);

					// Use webkitRelativePath if available, otherwise fallback to name
					const pathName = file.webkitRelativePath || file.name;
					const existingIndex = savedPaths.findIndex(p => p.path === pathName);
					if (existingIndex === -1) {
						savedPaths.push({ path: pathName, checked: true, data: importedData });
					} else {
						savedPaths[existingIndex].data = importedData;
						savedPaths[existingIndex].checked = true;
					}
					renderPathList();
					loadActiveCollections();
					showToast(`Imported: ${pathName}`);
				} catch (err) {
					showToast("Error: Invalid JSON");
				}
				input.value = "";
			};
			reader.readAsText(file);
		}

		function renderPathList() {
			const container = document.getElementById('path-list-container');
			if (!container) return;
			container.innerHTML = '';

			// Calculate the counts for the header display
			const greenCount = savedPaths.filter(p => p.data !== null).length;
			const totalCount = savedPaths.length;

			// Update the UI with the "Green / Total" format
			document.getElementById('collection-count').innerText = `${greenCount}/${totalCount}`;

			savedPaths.forEach((item, index) => {
				const isLoaded = item.data !== null;
				const div = document.createElement('div');
				// Apply 'loaded' class if data exists (green), 'stale' if checked but no data (yellow)
				div.className = `path-entry ${isLoaded ? 'loaded' : (item.checked ? 'stale' : '')}`;

				div.innerHTML = `
            <input type="checkbox" ${item.checked ? 'checked' : ''} onchange="togglePathCheck(${index})">
            <div class="path-text" onclick="handlePathClick(${index})">${item.path}</div>
            <button class="inline-toggle action-btn" onclick="removePath(${index})">✕</button>
        `;
				container.appendChild(div);
			});

			// Save metadata to local storage
			const metadata = savedPaths.map(p => ({ path: p.path, checked: p.checked }));
			localStorage.setItem('gallery_paths', JSON.stringify(metadata));
		}

		async function handlePathClick(index) {
			const path = savedPaths[index].path;
			const isURL = path.startsWith('http://') || path.startsWith('https://');

			if (isURL) {
				showToast("Fetching data from URL...");
				await importFromURL(path);
			} else {
				try {
					await navigator.clipboard.writeText(path);
					showToast("Path copied. Paste into file picker.");
					document.getElementById('json-input').click();
				} catch (err) {
					showToast("Clipboard failed. Opening picker...");
					document.getElementById('json-input').click();
				}
			}
		}



		function showSplash(e) {
			// 20251226: StarTree: If the e target is not an image, return
			if (!e || !e.target) return false;
			const image = e.target.closest('img');
			if (!image) return;

			const splash = document.getElementById('splash-screen');
			const splashImg = document.getElementById('splash-img');

			// 1. Reset values so it starts maximized and centered
			scale = 1;
			pointX = 0;
			pointY = 0;

			// 2. Set image and update transform BEFORE showing
			splashImg.src = getFullResURL(image.src);
			updateTransform();

			// 3. Show the screen
			splash.style.display = 'flex';
			document.body.style.overflow = 'hidden';
		}

		function hideSplash() {
			const splash = document.getElementById('splash-screen');
			splash.style.display = 'none';
			document.body.style.overflow = '';

			// Clear image to save memory
			document.getElementById('splash-img').src = '';
		}

		function updateTransform() {
			const img = document.getElementById('splash-img');
			// Using translate3d is more performant for panning
			img.style.transform = `translate3d(${pointX}px, ${pointY}px, 0) scale(${scale})`;
		}

		// Panning Logic
		const sImg = document.getElementById('splash-img');
		sImg.onmousedown = (e) => {
			if (scale === 1) return;
			isPanning = true;
			startX = e.clientX - pointX;
			startY = e.clientY - pointY;
		};
		window.onmousemove = (e) => {
			if (!isPanning) return;
			pointX = e.clientX - startX;
			pointY = e.clientY - startY;
			updateTransform();
		};
		window.onmouseup = () => isPanning = false;

		// Zoom Logic
		document.getElementById('splash-screen').onwheel = (e) => {
			e.preventDefault();
			scale = e.deltaY > 0 ? Math.max(1, scale - 0.2) : Math.min(5, scale + 0.2);
			if (scale === 1) { pointX = 0; pointY = 0; }
			updateTransform();
		};



		document.getElementById('splash-screen').addEventListener('touchstart', (e) => {
			if (e.touches.length === 2) {
				// Prepare for pinch-zoom
				initialDist = Math.hypot(
					e.touches[0].pageX - e.touches[1].pageX,
					e.touches[0].pageY - e.touches[1].pageY
				);
			} else if (e.touches.length === 1) {
				// Prepare for panning
				startX = e.touches[0].pageX - pointX;
				startY = e.touches[0].pageY - pointY;
			}
		}, { passive: false });

		document.getElementById('splash-screen').addEventListener('touchmove', (e) => {
			e.preventDefault(); // Stop the page from bouncing/scrolling

			if (e.touches.length === 2 && initialDist > 0) {
				// Handle Pinch Zoom
				const currentDist = Math.hypot(
					e.touches[0].pageX - e.touches[1].pageX,
					e.touches[0].pageY - e.touches[1].pageY
				);
				const zoomFactor = currentDist / initialDist;
				scale *= zoomFactor;
				initialDist = currentDist; // Update for next move
			} else if (e.touches.length === 1) {
				// Handle Panning
				pointX = e.touches[0].pageX - startX;
				pointY = e.touches[0].pageY - startY;
			}

			updateTransform(); // Your existing function to apply scale/translate
		}, { passive: false });


		function showToast(msg) {
			const t = document.getElementById('toast');
			t.innerText = msg;
			t.classList.add('show');
			setTimeout(() => t.classList.remove('show'), 2500);
		}
		function updateCenteredCard(e) {
			// 20251226: StarTree: If the user is scrolling on a track in single track mode, automatically set the center card as the active card.
			return;
			let track = document.querySelector('.track');
			if (e && e.target) {
				if (typeof e.target.closest === "function") {
					track = e.target.closest('.track');

				}
			}
			if (!track) return;
			const tracks = document.querySelectorAll('.track');
			if (tracks.length > 1) { return; }
			const cards = track.querySelectorAll('.card');
			const bodyWrap = document.getElementById('body-wrap');
			const isVertical = bodyWrap.classList.contains('max-width');

			// Find the center point of the viewport
			const viewportCenterX = window.innerWidth / 2;
			const viewportCenterY = window.innerHeight / 2;

			let closestCard = null;
			let minDistance = Infinity;

			cards.forEach((card, index) => {
				const rect = card.getBoundingClientRect();
				const cardCenterX = rect.left + rect.width / 2;
				const cardCenterY = rect.top + rect.height / 2;

				// Calculate distance from viewport center based on orientation
				const distance = isVertical
					? Math.abs(viewportCenterY - cardCenterY)
					: Math.abs(viewportCenterX - cardCenterX);

				if (distance < minDistance) {
					minDistance = distance;
					closestCard = { card, index };
				}
			});

			if (closestCard) {
				// 1. Clear previous centered/active states
				closestCard.card.classList.add('is-centered');
				if (autoRandomTrack && !isHidden('tab-card-notes')) { return; }
				cards.forEach(c => {
					c.classList.remove('is-centered');
					c.classList.remove('is-active'); // This triggers the white border
				});

				// 2. Highlight the new center card
				closestCard.card.classList.add('is-active');
			}
		}
		function updateStageCount() {
			const count = document.querySelectorAll('.card').length;
			document.getElementById('stage-count').innerText = count;
		}
		function syncSidebarHighlights() {
			const activePaths = Array.from(document.querySelectorAll('.card')).map(c => c.dataset.id);
			document.querySelectorAll('.file-item').forEach(item => {
				const itemPath = item.dataset.id;
				item.classList.toggle('active-item', activePaths.includes(itemPath));
			});
			updateStageCount();
		}

		async function createCard(item, makeNewCard = false) {
			// 20260118: Ivy: if makeNewCard, make a blank new card.
			if (makeNewCard) {
				// Create a YYYYMMDDhhmmss timestamp ID and push it to DATA after confirming that it is not already there.
				const pid = generatePID();
				if (DATA.some(item => item.p === pid)) {
					showToast("A card with ID " + pid + " already exists.")
					return;
				}
				const newItem = {
					p: pid,
					n: "P" + pid,
					t: ["NEW"],
				};
				DATA.push(newItem);
				item = DATA.find(i => i.p === pid);
				
			}
			// If the item is null, choose a random one from the file list.			
			if (!item) {
				/*const choices = document.querySelectorAll(".file-item:not(.active-item)");
				const numChoices = choices.length;
				if (choices.length < 1) { return; }
				const file = choices[Math.floor(Math.random() * choices.length)];
				const id = file.dataset.id;
				item = DATA.find(i => i.p === id);*/
				item = FilterDraw();
				if (!item) { return; }
			}

			// 1. Change: Target the active track or the default track
			const multitrack = document.getElementById('multitrack');
			let activeCard = document.querySelector('.card.is-active');
			let activeTrack = activeCard ? activeCard.parentElement : document.querySelector('.track');
			if (autoRandomTrack) {
				activeTrack = autoRandomTrack;
			}
			if (document.body.classList.contains("auto-random")) { autoRandomTrack = activeTrack; }
			const isVertical = document.getElementById('body-wrap').classList.contains('max-width');

			// Duplicate check
			const existing = Array.from(document.querySelectorAll('.card')).find(c => c.dataset.id === item.p);
			if (existing) {
				const bSameTrack = (activeTrack == existing.closest('.track'));
				if (existing.classList.contains('pinned')) {
					existing.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
					if (autoRandomTrack && !isHidden('tab-card-notes')) { return; }
					setActiveCard(existing);
					return;
				} else {
					existing.remove();
					if (bSameTrack) {
						syncSidebarHighlights();
						return;
					}
				}
			}

			if (autoFlush) {
				// 20251227: Cardinal: First count the number of cards in the track.
				const cardsInTrack = activeTrack.querySelectorAll('.card:not(.pinned)');
				if (cardsInTrack.length > 0) {
					if (cardsInTrack.length > 1) {
						if (!await showConfirm("This track has more than one unstarred cards. Keep them?")) {
							cardsInTrack.forEach(c => {
								if (!c.classList.contains('pinned')) c.remove();
							});
						}
					} else {
						cardsInTrack.forEach(c => {
							if (!c.classList.contains('pinned')) c.remove();
						});
					}
				}
				activeCard = document.querySelector('.card.is-active');
			}




			const c = document.createElement('div');
			c.className = 'card';
			c.dataset.id = item.p;
			updateStarButtonState();

			// 20250103: Lei: using iFrame to show PDF
			const isPDF = item.p.toLowerCase().endsWith('.pdf');

			if (isPDF) {
				const pdfUrl = `${item.p}#view=FitH&zoom=100`;
				c.innerHTML = `
        <div class="card-selection-hitbox" style="position:absolute; top:0; left:0; width:100%; height:20px; z-index:20; cursor:cell;"></div>
				<div class="card-tag-overlay"></div>
        <embed 
            src="${pdfUrl}" 
            type="application/pdf" 
            style="min-width: 100%;"
				/>`;
			} else {
				c.innerHTML = `<a href="${getURL(item)}" target="_blank" class="file-link" onclick="return false;"><img src="${getImageURL(item)}" referrerpolicy="no-referrer" loading="lazy"></a>`;
			}

			// 20251229: Sasha: In Multitrack vertical mode insert after the active card.
			const isMultitrack = multitrack.querySelectorAll(".track").length > 1;
			if (isMultitrack && activeCard && !autoRandomTrack) {
				if (isVertical) {
					activeCard.after(c);
				} else {
					if (currentDock === 'left') {
						activeCard.before(c);

					} else {
						activeCard.after(c);

					}
				}
			} else {
				// 3. Change: Insertion logic targets activeTrack
				const cards = Array.from(activeTrack.querySelectorAll('.card'));

				if (cards.length === 0) {
					activeTrack.appendChild(c);
				} else {
					const centerX = activeTrack.scrollLeft + (activeTrack.clientWidth / 2);
					const centerY = activeTrack.scrollTop + (activeTrack.clientHeight / 2);

					let closestCard = cards[0];
					let minDistance = Infinity;

					cards.forEach(card => {
						const midX = card.offsetLeft + (card.offsetWidth / 2);
						const midY = card.offsetTop + (card.offsetHeight / 2);
						const dist = isVertical ? Math.abs(centerY - midY) : Math.abs(centerX - midX);

						if (dist < minDistance) {
							minDistance = dist;
							closestCard = card;
						}
					});

					if (currentDock === 'left') {
						closestCard.insertAdjacentElement('beforebegin', c);

					} else {
						closestCard.insertAdjacentElement('afterend', c);

					}
				}

				// --- NEW LOGIC FOR MULTI-TRACK AUTO-ACTIVE ---			
				if (multitrack && multitrack.children.length > 1) {
					// 1. Clear existing active state from all other cards


					// 2. Make this new card active
					if (!autoRandomTrack || isHidden('tab-card-notes')) {
						document.querySelectorAll('.card.is-active').forEach(c => c.classList.remove('is-active'));
						c.classList.add('is-active');
					}

					updateStarButtonState();


				}

			}
			setTimeout(() => {
				//if (multitrack.children.length > 1) {
				c.scrollIntoView({
					behavior: 'smooth',
					block: 'center',
					inline: 'center'
				});

				updateAllCardOverlays();
				syncSidebarHighlights();
				memDOM();
			}, 50);
			if (autoRandomTrack && !isHidden('tab-card-notes')) { return; }
			setActiveCard(c);
			saveCardNotes();
		}
		function updateStarButtonState() {
			const activeCard = document.querySelector('.card.is-active');
			const starBtn = document.querySelector('.star-btn'); // or .pin-btn

			/*if (activeCard && activeCard.classList.contains('pinned')) {
				starBtn.classList.add('active-gold');
			} else {
				starBtn.classList.remove('active-gold');
			}*/
		}
		function updateAllCardOverlays() {
			// 20251226: StarTree: To be changed to so the tags don't show on the card itself.
			return;
			document.querySelectorAll('.card').forEach(card => {
				const id = card.dataset.id;
				const item = DATA.find(i => i.p === id);
				if (!item) return;

				const overlay = card.querySelector('.card-tag-overlay');
				overlay.innerHTML = "";
				[...item.t].sort().forEach(t => {
					const p = document.createElement('div');
					p.className = 'tag-pill';
					if (activeTags.has(t)) p.classList.add('active');
					p.dataset.tag = t;
					p.innerText = t;
					p.onclick = (e) => { e.stopPropagation(); toggleTag(t); };
					overlay.appendChild(p);
				});
			});
			memDOM();
		}
		function generatePID() {
			const now = new Date();

			// Extract parts and pad with a leading zero if they are single digits
			const year = now.getFullYear();
			const month = String(now.getMonth() + 1).padStart(2, '0'); // Months are 0-indexed
			const day = String(now.getDate()).padStart(2, '0');
			const hour = String(now.getHours()).padStart(2, '0');
			const min = String(now.getMinutes()).padStart(2, '0');
			const sec = String(now.getSeconds()).padStart(2, '0');

			return `${year}${month}${day}${hour}${min}${sec}`;
		}
		function getActiveCard() {
			const card = document.querySelector(".card.is-active");
			if (!card) { return null; }
			return card;
		}
		function getActiveCardData() {
			const card = getActiveCard();
			if (!card) { return null; }
			const id = card.dataset.id;
			let item = DATA.find(i => i.p === id);
			// 20260120: Natalie: If the ID is not found, try to match the path instead.
			// .. This is for fixing a data migration issue where originally the assets used the path as their ID.
			if (!item) { item = DATA.find(i => i.u === id); } // Try matching the path
			if (!item) { item = DATA.find(i => i.i === id); } // Try matching the image
			return item;
		}
		function getCardByPath(path) {
			const item = DATA.find(i => i.p === path);
			return item;
		}
		function toggleAutoFlush(e) {
			e.stopPropagation();
			autoFlush = !autoFlush;
			localStorage.setItem('gallery_flush', autoFlush);
			if (autoFlush) {
				document.body.classList.add("auto-flush");
			} else {
				document.body.classList.remove("auto-flush");
			}
			updateAutoFlushUI();
			showToast(autoFlush ? "Auto-Flush Enabled" : "Auto-Flush Disabled");
		}

		function updateAutoFlushUI() {
			const btn = document.getElementById('auto-flush-btn');
			btn.classList.toggle('active-gold', autoFlush); // Solid yellow when active
			btn.classList.toggle('action-btn', !autoFlush); // Semi-transparent when inactive
		}

		function toggleTagSort() {
			// 1. Switch the underlying mode
			tagSortMode = (tagSortMode === 'alpha') ? 'freq' : 'alpha';
			localStorage.setItem('gallery_tag_sort', tagSortMode);

			const btn = document.getElementById('tag-sort-btn');

			// 2. Show the FUTURE state (the opposite of current mode)
			// If current is alpha, show '1-9' (the frequency option)
			// If current is freq, show 'A-Z' (the alphabetical option)
			btn.innerText = (tagSortMode === 'alpha') ? '1-9' : 'A-Z';

			// 3. Keep it semi-transparent by ensuring only 'action-btn' is used
			btn.className = 'inline-toggle action-btn';

			refreshAllUI();
		}
		function updateTagSortUI() {
			document.getElementById('tag-sort-btn').innerText = tagSortMode === 'alpha' ? 'A-Z' : '1-9';
		}
		function getFilteredData() {
			const q = document.getElementById('master-search').value.toLowerCase().trim();

			return DATA.filter(i => {
				// 1. Must have EVERY active tag
				const matchesActive = Array.from(activeTags).every(at => i.t.includes(at));

				// 2. Must match the text search (against tags)
				const matchesSearch = q === "" || i.t.some(it => it.toLowerCase().includes(q));

				return matchesActive && matchesSearch;
			});
		}
		function refreshAllUI() {
			const q = document.getElementById('master-search').value.toLowerCase();
			const list = document.getElementById('file-list');
			list.innerHTML = "";
			list.className = "file-list" + (sidebarIsGrid ? " grid-view" : "");

			const filtered = DATA.filter(i => {
				const matchesActive = Array.from(activeTags).every(at => i.t.includes(at));
				const matchesSearch = q === "" || i.t.some(it => it.toLowerCase().includes(q));
				return matchesActive && matchesSearch;
			});

			renderCardTags();

			// 1. Calculate tag frequencies in the current filtered set
			const tagFreq = {};
			filtered.forEach(i => {
				i.t.forEach(t => {
					if (t && t.trim() !== "") {
						tagFreq[t] = (tagFreq[t] || 0) + 1;
					}
				});
			});

			// 2. Sort the cloud based on the active mode (Alpha vs Frequency)
			let sortedTags = ALL_TAGS.filter(t => {
				const matchesSearch = t.toLowerCase().includes(q);
				const isNotEmpty = t && t.trim() !== ""; // <--- ADD THIS CHECK
				return matchesSearch && isNotEmpty;
			});

			if (tagSortMode === 'freq') {
				sortedTags.sort((a, b) => (tagFreq[b] || 0) - (tagFreq[a] || 0) || a.localeCompare(b));
			} else {
				sortedTags.sort((a, b) => a.localeCompare(b));
			}

			const cloud = document.getElementById('tag-cloud');
			cloud.innerHTML = "";

			sortedTags.forEach(t => {
				const count = tagFreq[t] || 0;
				if (count === 0 && activeTags.size > 0 && !activeTags.has(t)) return; // Hide empty tags if filtering

				const p = document.createElement('div');
				p.className = 'tag-pill' + (activeTags.has(t) ? ' active' : '');
				p.dataset.tag = t;
				// Optional: Add a small count indicator next to the tag name
				p.innerHTML = `${t} <span class="tag-count-small">${count}</span>`;
				cloud.appendChild(p);
			});

			document.getElementById('tag-count').innerText = cloud.children.length;
			document.getElementById('img-count').innerText = filtered.length;

			// ... rest of function (file-item generation) remains same
			filtered.forEach((item, idx) => {
				const d = document.createElement('div');
				d.className = 'file-item';
				d.dataset.id = item.p;
				d.id = 'f-' + idx;
				if (sidebarIsGrid) {
					// Wrap the thumbnail in a link pointing to the real source
					d.innerHTML = `
      <a href="${getURL(item)}" target="_blank" class="file-link" onclick="return false;">
        <img src="${getThumbnailURL(getImageURL(item))}" loading="lazy" alt="${getURL(item)}">
      </a>`;
				} else {
					d.innerHTML = `<a href="${getURL(item)}" target="_blank" class="file-link" onclick="return false;" title="${item.p}">${item.n}</a>`;
				}
				list.appendChild(d);
			});
			updateAllCardOverlays();
			syncSidebarHighlights();
			updateStageCount();
			memDOM();
			updateAssignmentUI();
		}

		async function clearWorkspace(e) {
			e.stopPropagation();
			// 20260105: Sasha: If the multitrack area has pinned cards, but not all of them are pinned, remove only the unpinned cards.

			const multitrack = document.querySelector("#multitrack");
			const numCards = document.querySelectorAll(".card").length;
			const numPinned = document.querySelectorAll(".card.pinned").length;

			let msg = "This will wipe the multitrack area. Keep it?"
			if (numCards != numPinned && numPinned > 0) {
				msg = "This will remove " + (numCards - numPinned) + " card(s) without ⭐. Keep them?";
				if (await showConfirm(msg)) { return; }
				document.querySelectorAll('.card').forEach(c => {
					if (!c.classList.contains('pinned')) c.remove();
				});
				return;
			} else if (numCards == numPinned && numCards > 0) {
				msg = "The multitrack only has ⭐ card(s). Keep them?"
				if (await showConfirm(msg)) { return; }
			}
			multitrack.innerHTML = "<div class='track'></div>";
			syncSidebarHighlights();
		}
		async function exportFilteredData(mode = 'path') {
			const q = document.getElementById('master-search').value.toLowerCase();
			const filtered = DATA.filter(i => {
				const matchesActive = Array.from(activeTags).every(at => i.t.includes(at));
				return matchesActive && (q === "" || i.t.some(it => it.toLowerCase().includes(q)));
			});

			showToast(`Preparing ${filtered.length} items for export...`);
			document.body.style.cursor = 'wait';
			let dataToExport = [];
			let failCount = 0; // Track failures

			if (mode === 'base64') {
				showToast("Starting Base64 conversion...");
				// Transform the paths into Base64 strings
				dataToExport = await Promise.all(filtered.map(async (item) => {
					try {
						const base64String = await getBase64FromUrl(item.p);
						return { ...item, p: base64String }; // Replace path with base64
					} catch (err) {
						console.error(`@@Failed to convert ${item.p}:`, err);
						failCount++; // Increment failure count
						return item; // Fallback to path if conversion fails
					}
				}));
			} else {
				dataToExport = filtered;
			}

			// standard Download Logic
			const blob = new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json' });
			const a = document.createElement('a');
			a.href = URL.createObjectURL(blob);
			a.download = `${mode.toUpperCase()}_Export_${new Date().toISOString().slice(0, 10)}.json`;
			a.click();

			// 5. Cleanup
			document.body.style.cursor = 'default';
			setTimeout(() => URL.revokeObjectURL(a.href), 1000);

			let finalMsg = `Exported ${filtered.length} items.`;
			if (failCount > 0) {
				finalMsg += ` (${failCount} images kept as URLs due to CORS)`;
			}

			showToast(finalMsg);
		}

		// Helper function to handle the conversion
		async function getBase64FromUrl(url) {
			const response = await fetch(url);
			const blob = await response.blob();
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				reader.onloadend = () => resolve(reader.result);
				reader.onerror = reject;
				reader.readAsDataURL(blob);
			});
		}

		function exportGallery() {
			let docClone = document.documentElement.cloneNode(true);
			let bodyWrap = docClone.querySelector('#body-wrap');
			if (bodyWrap) bodyWrap.classList.add('collapsed');

			// Ensure Meta Charset is present
			let head = docClone.querySelector('head');
			if (!head.querySelector('meta[charset]')) {
				let meta = document.createElement('meta');
				meta.setAttribute('charset', 'UTF-8');
				head.prepend(meta);
			}

			let html = docClone.outerHTML;

			// 3. Inject current data and tags
			html = html.replace(/let DATA = \[.*?\];/, `let DATA = ${JSON.stringify(DATA)};`);
			html = html.replace(/let ALL_TAGS = \[.*?\];/, `let ALL_TAGS = ${JSON.stringify(ALL_TAGS)};`);

			const blob = new Blob(['<!DOCTYPE html>\n' + html], { type: 'text/html' });
			const a = document.createElement('a');
			a.href = URL.createObjectURL(blob);
			a.download = 'Gallery_Export.html';
			a.click();
		}
		/**
		 * Finds the existing card in a track that the new card should be inserted BEFORE.
		 * @param {HTMLElement} track - The target track container.
		 * @param {number} x - The horizontal coordinate (for Horizontal mode).
		 * @param {number} y - The vertical coordinate (for Vertical mode).
		 * @returns {HTMLElement|null} - The sibling to insert before, or null to append at the end.
		 */
		function getInsertionSibling(track, x, y) {
			const isVertical = document.getElementById('body-wrap').classList.contains('max-width');
			const siblings = Array.from(track.querySelectorAll('.card:not(.is-dragging)'));

			return siblings.find(sibling => {
				const box = sibling.getBoundingClientRect();
				if (isVertical) {
					// In Vertical mode, compare Y coordinates (Vertical mid-point)
					return y < box.top + box.height / 2;
				} else {
					// In Horizontal mode, compare X coordinates (Horizontal mid-point)
					return x < box.left + box.width / 2;
				}
			});
		}
		function updateStageCount() {
			return;
			document.getElementById('stage-count').innerText = document.querySelectorAll('.card').length;
		}
		// New function to handle the side-specific click
		function restoreAndDock(side) {
			updateDock(side);      // Move the sidebar to clicked side
			toggleSidebar(true);   // Show the sidebar
		}
		function handleCornerClick(clickedSide) {
			const bodyWrap = document.getElementById('body-wrap');
			const isCollapsed = bodyWrap.classList.contains('collapsed');
			if (currentDock !== clickedSide) {
				// Instant side swap and show
				updateDock(clickedSide);
				toggleSidebar(true);
			} else {
				// Toggle fade in/out
				toggleSidebar(isCollapsed);
			}
		}
		function toggleSidebar(show) {
			const splash = document.getElementById('splash-screen');

			// 1. Check if the splash screen is currently visible
			if (window.getComputedStyle(splash).display !== 'none') {
				// If splash is open, the button acts as a CLOSE button
				hideSplash();
				return; // Exit the function so the sidebar doesn't open
			}

			const bodyWrap = document.getElementById('body-wrap');
			bodyWrap.classList.toggle('collapsed', !show);
		}
		function updateDock(side) {
			currentDock = side;
			// Add/Remove class to handle the layout direction
			document.body.classList.toggle('dock-left', side === 'left');


			// Save preference
			localStorage.setItem('gallery_dock', side);
		}
		function handleLinkAction(e) { e.preventDefault(); const filtered = Array.from(activeTags).filter(t => !t.match(/^\[.*\]$/)); navigator.clipboard.writeText((document.getElementById('user-note').value + " " + filtered.join(' ')).trim()); const btn = document.getElementById('add-btn'); btn.innerText = '✓'; setTimeout(() => btn.innerText = '+', 1000); }


		function toggleFocus(card) {
			cycleViewMode(); setTimeout(() => {
				card.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
			}, 150);
		}
		function handleMissingImage(img, path) {
			// 20260110: Sasha: Don't need to remove the image.
			const card = img.closest('.card');
			DATA = DATA.filter(i => i.p !== path);
			card.remove();
			refreshAllUI();
		}
		function toggleTag(t) {
			if (activeTags.has(t)) activeTags.delete(t); else activeTags.add(t); refreshAllUI();
		}
		function saveNotes(v) { localStorage.setItem('gallery_notes', v); }

		let pointX = 0;
		let pointY = 0;
		let isPanning = false;

		const splashImg = document.getElementById('splash-img');
		const splashScreen = document.getElementById('splash-screen');

		// ZOOM LOGIC (Mouse Wheel)
		splashScreen.onwheel = function (e) {
			e.preventDefault();
			const delta = e.deltaY;
			const zoomSpeed = 0.2;

			if (delta > 0) {
				scale = Math.max(1, scale - zoomSpeed); // Min zoom is 1x
			} else {
				scale = Math.min(5, scale + zoomSpeed); // Max zoom is 5x
			}

			// If we zoom back to 1, reset position
			if (scale === 1) {
				pointX = 0;
				pointY = 0;
			}

			updateTransform();
		};

		// PAN LOGIC (Click and Drag)
		splashImg.onmousedown = function (e) {
			if (scale === 1) return; // Only pan if zoomed in
			e.preventDefault();
			isPanning = true;
			startX = e.clientX - pointX;
			startY = e.clientY - pointY;
		};

		window.onmousemove = function (e) {
			if (!isPanning) return;
			pointX = e.clientX - startX;
			pointY = e.clientY - startY;
			updateTransform();
		};

		window.onmouseup = function () {
			isPanning = false;
		};

		function updateTransform() {
			splashImg.style.transform = `translate(${pointX}px, ${pointY}px) scale(${scale})`;
		}

		// Update your hideSplash to reset these values
		function hideSplash() {
			const splash = document.getElementById('splash-screen');
			splash.style.display = 'none';
			document.body.style.overflow = '';

			// Reset state for next time
			scale = 1;
			pointX = 0;
			pointY = 0;
			updateTransform();
		}
		function toggleStageTools(e) {
			e.stopPropagation();
			const s = document.getElementById('button-palatte');
			// Check for empty string (initial state)
			s.style.display = (s.style.display === 'none' || s.style.display === '') ? 'block' : 'none';
		}
		function toggleSidebarUpper(e, aID) {
			e.stopPropagation();
			const c = document.getElementById(aID);
			if (c.checkVisibility()) {
				c.style.display = "none";
				c.classList.remove("sidebar-upper");
			} else {
				c.style.display = "flex";
				c.classList.add("sidebar-upper");
			}
		}

		function toggleCollections(e) {
			toggleSidebarUpper(e, 'collapsible-collections');
		}
		function toggleTagCloud(e) {
			e.stopPropagation();
			const c = document.getElementById('collapsible-tags');
			if (c.checkVisibility()) {
				c.style.display = "none";
				c.classList.remove("sidebar-upper");
			} else {
				c.style.display = "block";
				c.classList.add("sidebar-upper");
			}
		}
		function cycleViewMode() {
			const bodyWrap = document.getElementById('body-wrap');
			const btn = document.getElementById('mode-toggle');
			const isMax = bodyWrap.classList.toggle('max-width');

			localStorage.setItem('gallery_is_max_width', isMax);

			// Set character based on current mode
			// icon-v is used for Max Height mode, icon-h for Max Width mode
			btn.innerHTML = isMax ? '<div class="icon-v"></div>' : '<div class="icon-h"></div>';
			// Trigger highlight update immediately after switching modes
			//setTimeout(updateCenteredCard, 100);
		}

		function toggleSidebarView() {
			sidebarIsGrid = !sidebarIsGrid;
			const icon = document.getElementById('toggle-icon');
			const container = document.getElementById('grid-slider-container'); // Get the slider container

			if (sidebarIsGrid) {
				icon.className = 'css-list';
				icon.innerHTML = '<div></div><div></div><div></div>';
				if (container) container.style.display = 'flex'; // Show slider
			} else {
				icon.className = 'css-grid';
				icon.innerHTML = '<div></div><div></div><div></div><div></div>';
				if (container) container.style.display = 'none'; // Hide slider
			}

			refreshAllUI();
		}
		function applyRandomStyle() {
			const bubble = document.querySelector('.speech-bubble');

			// Randomize corners (between 20px and 70px)
			bubble.style.setProperty('--br-tl', `${Math.random() * 50 + 20}px`);
			bubble.style.setProperty('--br-tr', `${Math.random() * 50 + 20}px`);
			bubble.style.setProperty('--br-br', `${Math.random() * 50 + 20}px`);
			bubble.style.setProperty('--br-bl', `${Math.random() * 50 + 20}px`);

			// Randomize rotation (between -2 and +2 degrees)
			bubble.style.setProperty('--bubble-rot', `${(Math.random() - 0.5) * 4}deg`);

			// Randomize the "blob" shape behind it
			const r = () => Math.floor(Math.random() * 30 + 30);
			bubble.style.setProperty('--blob-radius', `${r()}% ${r()}% ${r()}% ${r()}%`);
		}

		// Call this inside your showSpeech() function
		function updateGridCols(v) {
			document.documentElement.style.setProperty('--grid-cols', v);
			// document.getElementById('col-val').innerText = v; // REMOVE OR COMMENT OUT THIS LINE
			localStorage.setItem('gallery_cols', v);
		}

		document.addEventListener('wheel', (e) => {
			// 20260110: Sasha: Also for the button pad.
			const buttonPad = e.target.closest('.button-pad');
			if (buttonPad) {
				e.preventDefault();
				if (buttonPad.classList.contains("left")) {
					buttonPad.scrollLeft -= e.deltaY;
				} else {
					buttonPad.scrollLeft += e.deltaY;
				}

				return; // Stop here so we don't trigger the track logic below
			}

			// Horizontal scrolling for horizontal tracks
			const isHorizontalMode = !document.getElementById('body-wrap').classList.contains('max-width');
			if (isHorizontalMode) {
				const targetTrack = e.target.closest('.track');
				if (targetTrack) {
					e.preventDefault();
					targetTrack.scrollLeft += e.deltaY;
				}
			}
		}, { passive: false });
		if ('serviceWorker' in navigator) {
			window.addEventListener('load', () => {
				navigator.serviceWorker.register('/sw.js')
					.then((reg) => console.log('Service Worker Registered!', reg))
					.catch((err) => console.log('Registration Failed:', err));
			});
		}
	</script>
</body>

</html>