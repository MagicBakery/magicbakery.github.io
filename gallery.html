<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Magic Theater</title>
	<link rel="icon" type="image/png" href="https://raw.githubusercontent.com/MagicBakery/Icons/refs/heads/main/Star.png">
	<style>
		:root {
			--bg: #000;
			--panel: rgba(15, 15, 15, 0.5);
			--border: rgba(255, 255, 255, 0.1);
			--accent: #fff;
			--text: #fff;
			--text-dim: #CCC;
			--grid-cols: 3;
			--sidebar-w: 300px;
			--gold: #ffd700;
			--h-dir: row;
			--green: #4CAF50;
		}

		* {
			box-sizing: border-box;
		}

		html,
		body {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
		}

		#sidebar *,
		#tag-cloud,
		.file-list,
		#track {
			-ms-overflow-style: none;
			scrollbar-width: none;
			
		}

		#sidebar *::-webkit-scrollbar,
		#track::-webkit-scrollbar {
			display: none;
		}

		body {
			background: var(--bg);
			/* This is #000, so it fades from black */
			color: var(--text);
			font-family: monospace;
			margin: 0;
			display: flex;
			height: 100vh;
			width: 100vw;
			overflow: hidden;
			background-size: cover;
			background-position: center;
			background-attachment: fixed;
			transition: background-image 0.5s ease-in-out;
		}

		body::before {
			content: "";
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.2);
			z-index: -1;
			pointer-events: none;
		}

		#splash-screen {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			background-color: #000;
			display: none;
			justify-content: center;
			align-items: center;
			z-index: 9999;
			overflow: hidden;
			/* Hide scrollbars during panning */
			touch-action: none;
			/* Prevents browser interference on mobile */
		}

		#splash-img {
			max-width: 100%;
			max-height: 100%;
			width: 100vw;
			height: 100vh;
			object-fit: contain;
			transition: transform 0.1s ease-out;
			/* Smooths out the zoom/pan */
			cursor: grab;
			user-select: none;
			display: block;
			margin: 0;
		}

		#splash-img:active {
			cursor: grabbing;
		}

		/* Your existing trigger/corner buttons */
		.hover-trigger,
		#ghost-restore {
			z-index: 10000 !important;
			/* Always on top */
		}

		@keyframes zoomIn {
			from {
				transform: scale(0.5);
				opacity: 0;
			}

			to {
				transform: scale(1);
				opacity: 1;
			}
		}

		/* Update the CSS for your menu toggle buttons */
		#menu-toggle,
		.corner-button-id {
			z-index: 10000;
			/* One level higher than the splash screen */
			position: fixed;
			/* Ensures they stay pinned to the corner */
		}

		#multitrack {
			flex: 1;
			display: flex;
			overflow: hidden;
			order: 1;
			gap: 0px;
			padding:5px;
		}

		/* HORIZONTAL: Tracks are stacked vertically as Rows */
		#body-wrap:not(.max-width) #multitrack {
			flex-direction: column-reverse;
		}

		#body-wrap:not(.max-width) #track {
			flex-direction: row;
			height: 100%;
			/* Becomes 50% automatically if a second track is added */
			width: 100%;
			display: flex;
			align-items: center;
			overflow-x: auto;
			overflow-y: hidden;
			padding-left: 5px;
			padding-right: 5px;
		}

		/* VERTICAL: Tracks are placed side-by-side as Columns */
		#body-wrap.max-width #multitrack {
			flex-direction: row;
		}

		#body-wrap.max-width #track {
			flex-direction: column;
			width: 100%;
			/* Becomes 50% automatically if a second track is added */
			height: 100%;
			display: flex;
			align-items: center;
			overflow-y: auto;
			overflow-x: hidden;
			padding-bottom: 40vh;
		}

		/* Push the main content over when sidebar is visible */
		body:not(.collapsed) #multitrack {
			/*margin-left: var(--sidebar-w);*/
			transition: margin-left 0.3s ease;
		}

		body.collapsed #multitrack {
			margin-left: 0;
		}

		#sidebar {
			position: fixed;
			border-radius:15px;
			bottom: 0;
			top: auto;
			width: var(--sidebar-w);
			max-height: 100vh;
			height: auto;
			background: var(--panel);
			backdrop-filter: blur(20px);
			border-right: 1px solid var(--border);

			z-index: 9998;
			/* Below Splash, as requested earlier */

			/* New Flex Logic */
			display: flex;
			flex-direction: column;
			justify-content: flex-end;
			/* Pushes content to the bottom */

			overflow-y: auto;
			/* Keeps it scrollable if content overflows */
		}

		/* Ensure children don't stretch awkwardly */
		#sidebar>* {
			flex-shrink: 0;
		}

		/* Default Right Docked */
		body:not(.dock-left) #sidebar {
			right: 0;
			left: auto;
			order: 2;
			border-left: 1px solid var(--border);
		}

		/* Left Docked */
		body.dock-left #sidebar {
			left: 0;
			right: auto;
			order: 0;
			border-right: 1px solid var(--border);
		}

		/* Hidden States: Force the sidebar to the literal edges */
		body.collapsed:not(.dock-left) #sidebar {
			position: fixed;
			right: 0;
			top: 0;
			height: 100%;
			transform: translateX(100%);
		}

		body.collapsed.dock-left #sidebar {
			position: fixed;
			left: 0;
			top: 0;
			height: 100%;
			transform: translateX(-100%);
			/* Slides completely off-screen to the left */
		}

		/* Hidden States: No sliding, just fade out */
		body.collapsed #sidebar {
			opacity: 0;
			visibility: hidden;
			pointer-events: none;
			position: absolute;
			/* Take out of flow so #track expands instantly */
		}

		/* Visible States: Fade in */
		body:not(.collapsed) #sidebar {
			opacity: 1;
			visibility: visible;
			pointer-events: auto;
			position: fixed;
			/* Changed from relative */
			bottom: 0;
		}

		.control-panel-grid {
			display: grid;
			grid-template-columns: repeat(3, 1fr);
			gap: 8px;
			padding: 15px;
			border-top: 1px solid var(--border);
		}

		.sq-btn {
			aspect-ratio: 1 / 1;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 1.2rem;

			/* Normal state: semi-transparent */
			background: rgba(255, 255, 255, 0.5);
			border: 1px solid rgba(255, 255, 255, 0.1);
			color: rgba(255, 255, 255, 0.4);
			/* Dimmed text/icon */

			cursor: pointer;
			border-radius: 4px;
			transition: all 0.2s ease;
			/* Smooth fade effect */
		}


		.sq-btn:hover:not(.dim) {
			background: rgba(255, 255, 255, 0.15);
			border-color: rgba(255, 255, 255, 0.8);
			color: rgba(255, 255, 255, 1);
			/* Full white text/icon */
			box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
		}

		/* Special styling for the active mode toggle button */
		.sq-btn.active-gold {
			color: var(--gold);
			border-color: rgba(255, 215, 0, 0.3);
		}

		.sq-btn.active-gold:hover {
			border-color: var(--gold);
			color: var(--gold);
		}

		#toast {
			position: fixed;
			bottom: 20px;
			left: 50%;
			transform: translateX(-50%);
			background: rgba(255, 215, 0, 0.6);
			backdrop-filter: blur(8px);
			color: #000;
			padding: 10px 20px;
			border-radius: 8px;
			font-weight: bold;
			font-size: 14px;
			z-index: 9999;
			opacity: 0;
			transition: opacity 0.3s ease;
			pointer-events: none;
			border: 1px solid rgba(255, 255, 255, 0.2);
		}

		#toast.show {
			opacity: 1;
		}

		/* Hide the old ghost restore button */
		#ghost-restore {
			display: none !important;
		}

		/* New Hover-to-Show zones: Always on top */
		.hover-trigger {
			position: fixed;
			bottom: 0;
			/* Changed from top: 0 */
			width: 60px;
			height: 60px;
			z-index: 10001;
			display: flex;
			align-items: center;
			justify-content: center;
			background: rgba(255, 255, 255, 0.05);
			backdrop-filter: blur(5px);
			cursor: pointer;
			font-size: 20px;
			color: #fff;
			opacity: 0;
			transition: opacity 0.3s ease, background 0.2s;
			border: 1px solid var(--border);
		}

		.hover-trigger:hover {
			opacity: 1;
			background: rgba(255, 255, 255, 0.15);
		}

		#trigger-left {
			left: 0;
			border-radius: 0 15px 0 0;
			/* Adjusted for bottom left */
		}

		#trigger-right {
			right: 0;
			border-radius: 15px 0 0 0;
			/* Adjusted for bottom right */
		}

		/* Ensure triggers only appear when collapsed */
		body.collapsed .hover-trigger {
			display: flex;
		}

		body.dock-left #ghost-restore {
			right: auto;
			left: 15px;
		}

		body.collapsed #ghost-restore {
			display: flex;
		}

		#track {
			flex: 1;
			padding: 0px;
			display: flex;
			gap: 10px;
			/* Wider gap for cleaner storyboard look */
			transition: width 0.3s ease;
			height: 100vh;
			order: 1;
			flex-direction: var(--h-dir);
			
			/* align-items: center;
			justify-content:flex-start;*/
			
			justify-content: safe center; /* Test */
			width:100%; /* Test */

			align-items: center;
			overflow-x: auto;
			overflow-y: hidden;
			flex-wrap: nowrap;

			/* Horizontal Centering Padding */
			padding-left: calc(50vw - (var(--sidebar-w) / 2) - 150px);
			padding-right: 50vw;

			scroll-behavior: smooth;
			/* Ensure the container transitions smoothly if padding changes */
			transition: padding 0.5s ease;
		}

		/* Ensure vertical mode keeps its original padding */
		body.max-width #track {
			padding: 5px;
			padding-top: 5px;
			padding-bottom: 5px;
			/* Adds empty space at the bottom so the last card can scroll up to the middle */
			flex-direction: column;
			align-items: center;
			overflow-y: auto;
			overflow-x: hidden;
		}


		/* Add this to your <style> section */
		.settings-close {
			width: 24px !important;
			height: 24px !important;
			font-size: 14px !important;
			background: rgba(255, 255, 255, 0.05) !important;
			border-color: var(--border) !important;
		}

		.settings-close:hover {
			background: rgba(255, 50, 50, 0.2) !important;
			/* Subtle red hover for "close" */
			border-color: rgba(255, 50, 50, 0.5) !important;
		}

		.card {
			position: relative;
			border: 3px solid rgba(255, 255, 255, 0.2);
			border-radius: 14px;
			flex-shrink: 0;
			/* CHANGE: Uses 98% of the parent track's height instead of a fixed 98vh */
			height: 98%;
			overflow: hidden;
			background: transparent;
			transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
			animation: cardEntrance 0.6s cubic-bezier(0.23, 1, 0.32, 1) both;
			box-shadow: 0 1px 1px rgba(0, 0, 0, 0.7);
			display: inline-block;
		}

		.card img {
			height: 100%;
			width: auto;
			object-fit: contain;
			display: block;
		}

		body.max-width .card {
			width: 95%;
			/* Fits column width in Vertical */
			height: auto;
		}

		/* The active/centered card style */
		.card.is-active {
			border-color: rgba(255, 255, 255, 0.6);
			box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
			transform: scale(1.02);
			z-index: 10;
		}

		/* Keyframes for the new card appearing */
		@keyframes cardEntrance {
			0% {
				opacity: 0;
				transform: scale(0.8) translateY(20px);
				filter: blur(10px);
			}

			100% {
				opacity: 1;
				transform: scale(1) translateY(0);
				filter: blur(0);
			}
		}

		body.max-width .card {
			width: 98%;
			height: auto;
			margin-bottom: 20px;
		}

		.card img {
			height: 100%;
			width: auto;
			object-fit: contain;
			display: block;
		}

		body.max-width .card img {
			width: 100%;
			height: auto;
		}

		.card.pinned {
			border-color: var(--gold);
			box-shadow: 0 0 25px rgba(255, 215, 0, 0.4);
		}

		.card-tools {
			position: absolute;
			top: 15px;
			right: 15px;
			display: flex;
			gap: 8px;
			z-index: 100;
		}

		.tool-btn {
			background: rgba(0, 0, 0, 0.1);
			color: rgba(255, 255, 255, 0.1);
			border: 1px solid rgba(255, 255, 255, 0.1);
			width: 36px;
			height: 36px;
			cursor: pointer;
			border-radius: 8px;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 16px;
			text-decoration: none;
		}

		.tool-btn:hover {
			border: 1px solid rgba(255, 255, 255, 0.8);
			color: rgba(255, 255, 255, 0.8);
		}

		.import-btn {
			background: var(--gold);
			color: #000;
			border: none;
			padding: 8px;
			border-radius: 4px;
			cursor: pointer;
			font-family: monospace;
			font-weight: bold;
			width: 100%;
		}

		.css-grid {
			width: 14px;
			height: 14px;
			display: grid;
			grid-template-columns: 1fr 1fr;
			grid-template-rows: 1fr 1fr;
			gap: 2px;
		}

		.css-grid div {
			border: 1.5px solid currentColor;
			border-radius: 1px;
		}

		.css-list {
			width: 14px;
			height: 14px;
			display: flex;
			flex-direction: column;
			justify-content: space-between;
			padding: 1px 0;
		}

		.css-list div {
			height: 2px;
			background: currentColor;
			width: 100%;
			border-radius: 1px;
		}

		.css-mag {
			width: 14px;
			height: 14px;
			border: 2px solid currentColor;
			border-radius: 50%;
			position: relative;
		}

		.css-mag::after {
			content: "";
			position: absolute;
			top: 11px;
			left: 11px;
			width: 6px;
			height: 2px;
			background: currentColor;
			transform: rotate(45deg);
			transform-origin: top left;
		}

		.css-wall {
			width: 12px;
			height: 12px;
			border: 2px solid currentColor;
			border-radius: 50% 50% 50% 0;
			transform: rotate(-45deg);
			position: relative;
			top: -2px;
		}

		.header-bar {
			padding: 5px 15px;
			display: flex;
			flex-direction: column;
			width: 100%;
		}

		.btn-group {
			display: flex;
			gap: 8px;
			/* Slightly wider gap for better touch/click targets */
			justify-content: center;
			/* Centers the buttons horizontally */
			width: 100%;
			/* Ensures the group spans the sidebar width */
		}

		/* Ensure buttons within the group don't stretch */
		.btn-group .sq-btn {
			flex: 0 0 auto;
		}

		.sq-btn {
			background: rgba(255, 255, 255, 0.5);
			border: none;
			width: 40px;
			height: 40px;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 18px;
			color: #000 !important;
			border-radius: 8px;
			flex-shrink: 0;
			transition: all 0.2s;
			text-decoration: none;
		}

		.sq-btn.dim {
			background: rgba(255, 255, 255, 0.1);
			color: var(--text-dim) !important;
		}

		.sq-btn.active-gold {
			background: var(--gold);
			color: #000 !important;
		}

		/* Centers the wallpaper icon inside the sidebar square button */
		.sq-btn .css-wall {
			margin: 0 auto;
			transform: rotate(-45deg) scale(1.2);
			/* Slightly larger for the sidebar */
		}

		#settings-panel {
    position: fixed; /* Changed from absolute */
    bottom: 0px;    /* Distance from bottom of screen */
    left: 50%; 
		transform: translateX(-50%);
    
    width: 100vw;    /* You can now make it wider than the sidebar */
    max-width: 800px;
		min-height: 300px;
    
    background: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(20px);
    border: 2px solid gold;
    border-radius: 15px;
    padding: 20px;
		
    z-index: 9999; /* Keeps it above the sidebar */

    flex-direction: column;
    gap: 15px;
    box-shadow: 0 10px 10px rgba(0, 0, 0, 0.8);
		font-size: 1.5em;
}
/* Custom Scrollbar Styling */
#settings-panel textarea::-webkit-scrollbar {
    width: 6px; /* Very thin */
}

#settings-panel textarea::-webkit-scrollbar-track {
    background: transparent; /* Makes the track invisible */
}

#settings-panel textarea::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2); /* Subtle white thumb */
    border-radius: 10px;
}

#settings-panel textarea::-webkit-scrollbar-thumb:hover {
    background: var(--gold); /* Highlights gold on hover to match your UI */
}

/* For Firefox */
#settings-panel textarea {
    scrollbar-width: thin;
    scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
}


		.unified-width {
			width: 100%;
			background: rgba(255, 255, 255, 0.0);
			color: #fff;
			border: 1px solid var(--border);
			font-family: monospace;
			outline: none;
			border-radius: 6px;
			padding: 8px;
		}

		#tag-cloud {
			display: flex;
			flex-wrap: wrap;
			gap: 4px;
			padding: 5px 15px;
			border-bottom: 1px solid var(--border);
			max-height: 25vh;
			overflow-y: auto;
		}

		.tag-pill {
			background: rgba(0, 0, 0, 0.5);
			color: var(--text-dim);
			padding: 4px 8px;
			border: 1px solid var(--border);
			font-size: 10px;
			cursor: pointer;
			border-radius: 4px;
		}

		.tag-pill.active {
			background: var(--accent);
			color: #000 !important;
		}

		.tag-count-small {
			opacity: 0.5;
			font-size: 9px;
		}

		.action-btn {
			background: rgba(255, 255, 255, 0.1) !important;
			color: var(--text-dim) !important;
			border: 1px solid var(--border) !important;
			opacity: 0.7;
		}

		.action-btn:hover {
			background: rgba(255, 255, 255, 0.2) !important;
			color: #fff !important;
			opacity: 1;
		}

		/* Current State: Solid/Bright */
		.state-active {
			background: var(--accent) !important;
			color: #000 !important;
			opacity: 1 !important;
		}

		.stats-bar {
			display: flex;
			align-items: center;
			justify-content: space-between;
			padding: 8px 15px;
			background: rgba(0, 0, 0, 0.3);
			border-bottom: 1px solid var(--border);
			font-size: 14px;
		}

		.stats-clickable {
			cursor: pointer;
			white-space: nowrap;
			/* Prevents text from wrapping */
			flex-shrink: 0;
			/* Prevents the label from being squashed */
			width: fit-content;
			/* Only takes the space of the words */
		}

		.stats-clickable:hover {
			color: #fff;
		}

		/* Centering logic for Tags Bar */
		.stats-bar.tags-bar {
			display: flex;
			align-items: center;
			gap: 10px;
			padding: 8px 15px;
		}

		.stats-bar-spacer {
			width: 32px;
			flex-shrink: 0;
		}

		.version-code {
			font-size: 9px;
			color: var(--text-dim);
			opacity: 0.6;
			font-family: monospace;
			flex-grow: 1;
			text-align: center;
		}

		.bakery-link {
			color: var(--text-dim);
			text-decoration: none;
			font-size: 14px;
			transition: color 0.2s;
			cursor: help;
			/* Indicates hoverable info */
		}

		.bakery-link:hover {
			color: var(--gold);
		}

		/* Matches Sort button width */
		.tags-bar-center {
			display: flex;
			align-items: center;
			justify-content: center;
			flex-grow: 1;
			gap: 8px;
			overflow: hidden;
		}

		.inline-toggle {
			background: transparent;
			border: 1px solid var(--border);
			color: var(--text-dim);
			cursor: pointer;
			border-radius: 4px;
			padding: 4px 6px;
			display: flex;
			align-items: center;
			transition: all 0.2s;
			font-size: 10px;
			min-width: 32px;
			justify-content: center;
		}

		.inline-toggle:hover {
			border-color: var(--accent);
			color: #fff;
		}

		/* Ensure the image container grows to fill all vertical space */
		#collapsible-images {
			flex: 1;
			display: flex;
			/* Default to flex so it fills space */
			flex-direction: column;
			overflow: hidden;
			min-height: 0;
			background: rgba(0, 0, 0, 0.2);
			/* Matching the stage-tools/collections background */
		}

		#file-list {
			flex: 1;
			overflow-y: auto;
			width: 100%;
		}

		#stage-tools,
		#collapsible-collections {
			display: none;
			padding: 5px 5px;
			gap: 8px;
			flex-direction: column;
			border-bottom: 1px solid var(--border);
			background: rgba(0, 0, 0, 0.2);
		}

		#master-search {
			flex: 1;
			/* This makes the search box grow to fill all available space */
			min-width: 50px;
			/* Prevents it from disappearing on tiny screens */
			text-align: center;
			background: rgba(255, 255, 255, 0.05);
			border: 1px solid var(--border);
			color: #fff;
			border-radius: 6px;
			padding: 6px;
			outline: none;
			transition: border-color 0.2s;
		}

		#master-search:focus {
			border-color: var(--accent);
		}

		/* Ensure the label and button don't shrink */
		.tags-bar .stats-clickable,
		#tag-sort-btn {
			flex-shrink: 0;
		}

		/* Collection Path List Styles */
		#path-list-container {
			display: flex;
			flex-direction: column;
			gap: 4px;
			margin-top: 5px;
			max-height: 150px;
			overflow-y: auto;
			padding-right: 4px;
		}

		.path-entry {
			display: flex;
			align-items: center;
			gap: 6px;
			background: rgba(255, 255, 255, 0.05);
			padding: 4px;
			border-radius: 4px;
		}

		.path-entry input[type="text"] {
			flex: 1;
			background: transparent;
			border: none;
			color: var(--text-dim);
			font-size: 9px;
			pointer-events: none;
		}

		.path-entry input[type="checkbox"] {
			cursor: pointer;
			width: 16px;
			height: 16px;
			accent-color: var(--gold);
		}

		.path-entry.stale input[type="checkbox"] {
			accent-color: var(--gold);
		}

		.path-entry.loaded input[type="checkbox"] {
			accent-color: var(--green);
		}

		.path-text {
			flex: 1;
			background: transparent;
			border: none;
			color: var(--text-dim);
			font-size: 10px;
			cursor: pointer;
			/* Updated for full path visibility */
			word-break: break-all;
			/* Breaks long strings like URLs */
			white-space: normal;
			/* Allows wrapping to new lines */
			line-height: 1.2;
			padding: 2px 0;
		}

		.path-entry {
			display: flex;
			align-items: flex-start;
			/* Align checkbox/trash to the top of wrapped text */
			gap: 6px;
			background: rgba(255, 255, 255, 0.05);
			padding: 6px;
			border-radius: 4px;
			margin-bottom: 2px;
		}

		.path-text:hover {
			color: #fff;
			text-decoration: underline;
		}

		.trash-btn {
			background: transparent;
			border: none;
			color: #ff4444;
			cursor: pointer;
			font-size: 12px;
			padding: 2px 6px;
			opacity: 0.7;
		}

		.trash-btn:hover {
			opacity: 1;
		}

		.file-list {
			flex: 1;
			overflow-y: auto;
		}

		.grid-view {
			display: grid !important;
			grid-template-columns: repeat(var(--grid-cols), 1fr) !important;
			grid-auto-rows: min-content;
			gap: 6px;
			padding: 8px;
		}

		.grid-view .file-item {
			padding: 0;
			border: 1px solid var(--border);
			aspect-ratio: 1/1;
			border-radius: 6px;
			position: relative;
			overflow: hidden;
			display: block;
		}

		.grid-view .file-item img {
			width: 100%;
			height: 100%;
			object-fit: cover;
			position: absolute;
			top: 0;
			left: 0;
		}

		.grid-view .active-item {
			border: 5px solid var(--gold) !important;
			z-index: 10;
			transform: scale(1.02);
		}

		.file-item {
			padding: 10px 15px;
			border-bottom: 1px solid rgba(255, 255, 255, 0.05);
			font-size: 11px;
			cursor: pointer;
			color: var(--text-dim);
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			transition: all 0.2s ease;
		}

		.file-item.active-item {
			color: var(--gold) !important;
			font-weight: bold;
			background: rgba(255, 215, 0, 0.15) !important;
			/* Visible highlight */
		}

		.grid-view .file-item.active-item {
			border: 3px solid var(--gold) !important;
			transform: scale(1.05);
			z-index: 5;
			background: transparent !important;
			/* Hide list bg in grid mode */
		}

		.active-item {
			color: var(--gold) !important;
			font-weight: bold;
			background: rgba(255, 215, 0, 0.1);
		}

		.card-tag-overlay {
			display: none;
			/* Controlled by toggleOverlay */
			position: absolute;
			top: 55px;
			/* Positions it just below the card-tools buttons */
			right: 15px;
			width: 200px;
			/* Constrains the width to a small side frame */
			max-height: 70%;
			flex-wrap: wrap;
			gap: 5px;
			padding: 10px;
			background: rgba(0, 0, 0, 0.85);
			border: 1px solid var(--border);
			border-radius: 8px;
			z-index: 101;
			/* Above the image but below main sidebar */
			overflow-y: auto;
			backdrop-filter: blur(10px);
		}

		#grid-slider-container {
			display: none;
			/* JavaScript toggles this to 'flex' */
			align-items: center;
			margin-left: 15px;
			/* Space after "Images" text */
			margin-right: 15px;
			/* Space before the grid button */
			flex: 1;
			/* Fills the entire gap */
			min-width: 0;
		}

		#col-slider {
			-webkit-appearance: none;
			width: 100%;
			/* Slider stretches to fill the whole container */
			height: 4px;
			background: var(--border);
			border-radius: 2px;
			outline: none;
			cursor: pointer;
			accent-color: var(--accent);
		}

		#grid-toggle-btn {
			flex-shrink: 0;
			/* Keeps the button square and fixed to the right */
		}

		#col-slider::-webkit-slider-thumb {
			-webkit-appearance: none;
			width: 12px;
			height: 12px;
			background: var(--accent);
			border-radius: 50%;
			cursor: pointer;
		}


		/* 1. Base style for the Scroll Direction button */
		#mode-toggle {
			background: rgba(255, 255, 255, 0.1) !important;
			/* Semi-transparent */
			color: #fff !important;
			/* Current direction in White */
			border: 1px solid var(--border) !important;
			transition: all 0.2s ease;
		}

		/* 2. Hover state: Border turns white */
		#mode-toggle:hover {
			border-color: #fff !important;
			background: rgba(255, 255, 255, 0.2) !important;
		}


		/* Center the character containers perfectly */
		.icon-h,
		.icon-v {
			display: flex;
			align-items: center;
			justify-content: center;
			width: 24px;
			/* Fixed width to prevent shifting */
			height: 24px;
			/* Fixed height to prevent shifting */
			font-size: 24px;
			font-weight: bold;
			color: #fff;
			line-height: 0;
			/* Strips font-specific vertical padding */
			pointer-events: none;
			user-select: none;
			margin: 0 auto;
			/* Centers the div within the square button */
		}

		/* Horizontal Dash centering */
		.icon-h::before {
			content: '—';
			transform: translateY(-2px);
			/* Corrects the typical 'sink' of a dash */
		}

		/* Vertical Pipe centering */
		.icon-v::before {
			content: '|';
			transform: translateX(0);
			/* Ensure no horizontal bias */
		}

		/* Hover Preview Logic: Ensure previews use the same offsets as active states */
		#mode-toggle:hover .icon-h::before {

			opacity: 0.7;
			transform: translateY(0);
			/* Remove the dash-specific vertical shift */
		}

		#mode-toggle:hover .icon-v::before {

			opacity: 0.7;
			transform: translateY(-2px);
			/* Apply the dash-specific vertical shift */
		}


		/* CSS Star Icon */
		/* Perfect 5-Point Star using Clip-Path */
		.icon-star {
			width: 20px;
			height: 20px;
			background: currentColor;
			clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
		}

		.icon-star::after {
			content: "";
			position: absolute;
			top: 6px;
			left: -10px;
			border-left: 10px solid transparent;
			border-right: 10px solid transparent;
			border-top: 18px solid currentColor;
		}

		/* When the card is pinned, turn the star button gold and solid */
		.card.pinned .pin-btn {
			color: var(--gold) !important;
			background: rgba(0, 0, 0, 0.4);
			/* Slightly darker background to pop the gold */
			border-color: var(--gold);
		}

		/* Ensure that when NOT pinned, the star stays semi-transparent even on the 'centered' card */
		.pin-btn {
			color: rgba(255, 255, 255, 0.1) !important;
		}

		/* Hovering over the star should still make it visible */
		.pin-btn:hover {
			color: rgba(255, 255, 255, 0.8) !important;
		}



		/* Simple Perfect Circle Icon */
		.icon-circle {
			width: 14px;
			height: 14px;
			border: 2px solid currentColor;
			/* Matches the button's text color */
			border-radius: 50%;
			display: inline-block;
			background: transparent;
			/* Hollow circle */
		}

		/* Optional: Solid circle on hover */
		.action-btn:hover .icon-circle {
			background: currentColor;
		}
	</style>
</head>

<body id="body-wrap" contenteditable="false">
	<div id="trigger-left" class="hover-trigger" onclick="handleCornerClick('left')">☰</div>
	<div id="trigger-right" class="hover-trigger" onclick="handleCornerClick('right')">☰</div>
	<div id="toast"></div>
	<div id="ghost-restore" onclick="toggleSidebar(true)">☰</div>

	<div id="sidebar">

		<div id="collapsible-collections">
			<div class="stats-bar">
				<div class="stats-clickable" onclick="toggleCollections()">Collections (<span id="collection-count">0</span>)
				</div>
				<a href="https://magicbakery.github.io/?id=P202512210026" target="_blank" class="bakery-link"
					id="version-link">ⓘ</a>
			</div>

			<input type="file" id="json-input" style="display:none" accept=".json" onchange="importJSON(this)">
			<div style="display:flex; gap:4px;">
				<button class="import-btn action-btn" style="width: 32px;" onclick="smartImport()">+</button>
				<button class="import-btn action-btn" style="flex: 1;" onclick="exportFilteredData()">EXPORT JSON</button>
				<button class="import-btn action-btn" style="flex: 1;" onclick="exportGallery()">EXPORT HTML</button>
			</div>
			<div id="path-list-container"></div>
		</div>





		<div id="collapsible-tags">
			<div class="stats-bar tags-bar">
				<span class="stats-clickable" onclick="toggleTagCloud()">Tags (<span id="tag-count">0</span>)</span>
				<input type="text" id="master-search" class="unified-width" style="width:100px; text-align:center"
					placeholder="SEARCH..." oninput="refreshAllUI()">
				<button class="inline-toggle" id="tag-sort-btn" onclick="toggleTagSort()">A-Z</button>
			</div>


			<div id="tag-cloud"></div>
		</div>


		<div id="collapsible-images"
			style="flex: 1; display: flex; flex-direction: column; overflow: hidden; background: rgba(0,0,0,0.2);">
			<div class="stats-bar">
				<div class="stats-clickable" onclick="toggleImages()">Images (<span id="img-count">0</span>)</div>
				<div id="grid-slider-container">
					<input type="range" id="col-slider" min="1" max="5" value="3" oninput="updateGridCols(this.value)">
				</div>
				<button class="inline-toggle" id="grid-toggle-btn" onclick="toggleSidebarView()">
					<div class="css-grid" id="toggle-icon">
						<div></div>
						<div></div>
						<div></div>
						<div></div>
					</div>
				</button>
			</div>


			<div id="file-list" class="file-list"></div>
		</div>



		<!--<div class="stats-bar">
			<div class="stats-clickable" onclick="toggleStageTools()">Staging (<span id="stage-count">0</span>)</div>
			<button class="inline-toggle" onclick="clearWorkspace()">✕</button>
		</div>-->
		<div id="stage-tools"><!--@@Stage-->
			<div class="btn-group">
				<button class="sq-btn dim" onclick="toggleCollections()" title="Collections"><svg width="24" height="24"
						viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
						stroke-linejoin="round">
						<rect x="7" y="7" width="14" height="14" rx="2" ry="2"></rect>
						<path d="M3 15v-8c0-1.1.9-2 2-2h8"></path>
					</svg></button>&nbsp;
				<button class="sq-btn dim" onclick="removeTrackRelative(+1)" title="Remove Track">-</button>
				<button class="sq-btn" onclick="moveActiveCard('up')" title="Move Up (Vertical Mode Only)">▲</button>
				<button class="sq-btn dim" onclick="addTrackRelative(+1)" title="Add Track">+</button>
				&nbsp;
				<button class="sq-btn action-btn" id="settings-btn" onclick="toggleSettings()">
					<div class="icon-circle"></div>
				</button>

				<!--<button class="inline-toggle" onclick="clearWorkspace()">✕</button>-->

			</div>
			<div class="btn-group">
				<button class="sq-btn dim" onclick="toggleTagCloud()" title="Tags"><svg width="24" height="24"
						viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
						stroke-linejoin="round">
						<line x1="4" y1="9" x2="20" y2="9"></line>
						<line x1="4" y1="15" x2="20" y2="15"></line>
						<line x1="10" y1="3" x2="8" y2="21"></line>
						<line x1="16" y1="3" x2="14" y2="21"></line>
					</svg></button>&nbsp;
				<button class="sq-btn" onclick="moveActiveCard('left')"
					title="Move Left (Horizontal Mode Only)">&#9664;</button>
				<button id="mode-toggle" class="sq-btn active-gold" onclick="toggleScrollMode()" title="Scroll Wheel Direction">
					<div class="icon-h"></div>
				</button>
				<button class="sq-btn" onclick="moveActiveCard('right')"
					title="Move Right (Horizontal Mode Only)">&#9654;</button>
				&nbsp;
				<button id="auto-flush-btn" class="sq-btn action-btn" onclick="toggleAutoFlush()">↻</button>

			</div>
			<div class="btn-group">
				<button class="sq-btn dim" onclick="toggleImages()" title="Listing"><svg width="20" height="20"
						viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
						<rect x="3" y="3" width="7" height="7"></rect>
						<rect x="14" y="3" width="7" height="7"></rect>
						<rect x="14" y="14" width="7" height="7"></rect>
						<rect x="3" y="14" width="7" height="7"></rect>
					</svg></button>
				&nbsp;
				<button class="sq-btn dim" onclick="addTrackRelative(-1)" title="Add Track">+</button>
				<button class="sq-btn" onclick="moveActiveCard('down')" title="Move Down (Vertical Mode Only)">▼</button>
				<button class="sq-btn dim" onclick="removeTrackRelative(-1)" title="Remove Track">-</button>
				&nbsp;<button class="sq-btn dim" onclick="clearWorkspace()">✕</button>


			</div>

		</div>

		

		<div class="header-bar" style="border-top: 1px solid var(--border); padding-top: 10px;">
			<div class="btn-group " onclick="toggleStageTools()">


				<button class="sq-btn action-btn" onclick="setCenteredAsWallpaper()" title="Set Center as Wallpaper">
					<div class="css-wall"></div>
				</button>
			</div>
		</div>



	</div>
	<div id="multitrack">
		<div id="track"></div>
	</div>
	<div id="settings-panel" style="display: none;">
			<button class="tool-btn settings-close" onclick="toggleSettings()"
				style="position: absolute; top: 10px; right: 10px;">×</button>

			<div style="font-weight: bold; margin-bottom: 5px; color: var(--gold);">SYSTEM SETTINGS</div>
			<div style="display:flex; gap:5px; align-items:center;">
				<a id="add-btn" href="#" target="_blank" class="sq-btn action-btn" onclick="handleLinkAction(event)">+</a>
				<input type="text" id="add-url-input" class="unified-width" placeholder="URL for + button..."
					oninput="updateAddUrl(this.value)">
			</div>
			<textarea id="user-note" class="unified-width" style="resize:none;height:180px; margin-bottom:5px;font-size:1em;overflow-y: auto;" placeholder="NOTES..."
				oninput="saveNotes(this.value)"></textarea>
		</div>
	<div id="splash-screen" onclick="if(event.target === this) hideSplash()">
		<img id="splash-img" src="" alt="Enlarged View">
	</div>
	<script>
		// --- UPDATE VERSION HERE (#Version)---
		const APP_VERSION = "20251225151000";
		// ---------------------------
		let DATA = [];
		let ALL_TAGS = [];
		let activeTags = new Set(), sidebarIsGrid = false, currentDock = 'right', autoFlush = false;
		let tagSortMode = 'alpha', savedPaths = [];

		window.onload = () => {
			// Inject the version code into the info link tooltip
			document.getElementById('version-link').title = "Ver." + APP_VERSION;

			// 1. Tag Sort Initialization (Future State)
			tagSortMode = localStorage.getItem('gallery_tag_sort') || 'alpha';
			const tagBtn = document.getElementById('tag-sort-btn');
			tagBtn.innerText = (tagSortMode === 'alpha') ? '1-9' : 'A-Z';
			tagBtn.className = 'inline-toggle action-btn';

			// 2. View Mode Initialization (Future State / Reversed)
			const savedMax = localStorage.getItem('gallery_is_max_width') === 'true';
			const bodyWrap = document.getElementById('body-wrap');
			const btn = document.getElementById('mode-toggle');

			if (savedMax) {
				bodyWrap.classList.add('max-width');
				if (btn) btn.innerHTML = '<div class="icon-v"></div>';
			} else {
				bodyWrap.classList.remove('max-width');
				if (btn) btn.innerHTML = '<div class="icon-h"></div>';
			}

			persistentWallpaper();
			initScrollDirection();

			// 3. Restore Sidebar Docking
			currentDock = localStorage.getItem('gallery_dock') || 'right';
			updateDock(currentDock);

			// 4. Restore Settings & Notes
			const n = localStorage.getItem('gallery_notes');
			if (n) document.getElementById('user-note').value = n;

			autoFlush = localStorage.getItem('gallery_flush') === 'true';
			updateAutoFlushUI();



			// Restore Grid Columns
			const savedCols = localStorage.getItem('gallery_cols') || 3;
			document.documentElement.style.setProperty('--grid-cols', savedCols);
			document.getElementById('col-slider').value = savedCols;



			// Set initial slider visibility
			const container = document.getElementById('grid-slider-container');
			const icon = document.getElementById('toggle-icon');

			if (sidebarIsGrid) {
				container.style.display = 'flex';
				icon.className = 'css-list';
				icon.innerHTML = '<div></div><div></div><div></div>';
			} else {
				container.style.display = 'none';
				icon.className = 'css-grid';
				icon.innerHTML = '<div></div><div></div><div></div><div></div>';
			}


			const savedAddUrl = localStorage.getItem('gallery_add_url');
			if (savedAddUrl) {
				document.getElementById('add-url-input').value = savedAddUrl;
				document.getElementById('add-btn').href = savedAddUrl;
			}

			// Restore or initialize Collections
			const rawPaths = localStorage.getItem('gallery_paths');
			if (rawPaths) {
				savedPaths = JSON.parse(rawPaths).map(p => ({ ...p, data: null }));
			} else {
				// DEFAULT PATH: Starter Pack
				savedPaths = [{
					path: "https://magicbakery.github.io/starterpack.json",
					checked: true,
					data: null
				}];
			}

			renderPathList();
			// Load data for all checked paths
			savedPaths.forEach((item, index) => {
				if (item.checked && (item.path.startsWith('http'))) {
					importFromURL(item.path);
				}
			});
		};
		function addTrackRelative(direction) {
			const multitrack = document.getElementById('multitrack');
			const activeCard = document.querySelector('.card.is-active');

			// 1. Identify the reference track
			// If no card is active, we default to the first track or create one if none exist
			let referenceTrack = activeCard ? activeCard.closest('#track') : multitrack.querySelector('#track');

			if (!referenceTrack) {
				// Fallback: If no tracks exist at all, just use babyStep
				babyStepAddTrack();
				return;
			}

			// 2. Create the new track element
			const newTrack = document.createElement('div');
			newTrack.id = 'track'; // Keeping ID consistent with your CSS selectors

			// Add the scroll listener so theater-mode centering works on the new track
			newTrack.addEventListener('scroll', updateCenteredCard);

			// 3. Insert relative to the reference
			if (direction === -1) {
				// Insert BEFORE (Above in Horizontal / Left in Vertical)
				referenceTrack.insertAdjacentElement('beforebegin', newTrack);
				showToast("Track Added Above/Left");
			} else {
				// Insert AFTER (Below in Horizontal / Right in Vertical)
				referenceTrack.insertAdjacentElement('afterend', newTrack);
				showToast("Track Added Below/Right");
			}

			// 4. Update UI to reflect the new layout
			updateAllCardOverlays();
		}

		/**
		 * Complementary function for the '-' buttons in your staging panel
		 */
		function removeTrackRelative(direction) {
			const activeCard = document.querySelector('.card.is-active');
			if (!activeCard) {
				showToast("Select a card in the track to remove");
				return;
			}

			const currentTrack = activeCard.closest('#track');
			const multitrack = document.getElementById('multitrack');

			// Logic: direction -1 targets the track ABOVE the current one, 1 targets BELOW.
			// 0 (if you wanted) would target the current track itself.
			const bodyWrap = document.getElementById('body-wrap');
			const isVertical = bodyWrap.classList.contains('max-width');
			let targetTrack;
			if (direction === -1) {
				if (isVertical) {
					targetTrack = currentTrack.nextElementSibling;
				} else {
					targetTrack = currentTrack.previousElementSibling;
				}

			} else if (direction === 1) {
				if (isVertical) {
					targetTrack = currentTrack.previousElementSibling;
				} else {
					targetTrack = currentTrack.nextElementSibling;
				}
			}

			if (targetTrack && targetTrack.id === 'track') {
				targetTrack.remove();
				showToast("Track Removed");
			} else {
				showToast("No track found in that direction");
			}
		}


		function babyStepAddTrack() {
			const multitrack = document.getElementById('multitrack');

			// 1. Create a second track
			const newTrack = document.createElement('div');
			newTrack.id = "track-2";
			newTrack.style.flex = "1"; // This splits the space 50/50
			newTrack.style.border = "2px dashed rgba(255,255,255,0.2)";
			//newTrack.innerHTML = "<div style='color:gray; padding:5px;'>Track 2 Active</div>";

			// 2. Ensure the first track is also flexible
			document.getElementById('track').style.flex = "1";

			multitrack.appendChild(newTrack);
			showToast("Multi-track split enabled");
		}




		/**
		 * Moves the active card within its track based on mode-restricted directions.
		 * @param {string} direction - 'up', 'down', 'left', or 'right'
		 */
		function moveActiveCard(direction) {
			const activeCard = document.querySelector('.card.is-active');
			if (!activeCard) return;

			const bodyWrap = document.getElementById('body-wrap');
			const isVerticalMode = bodyWrap.classList.contains('max-width');
			const currentTrack = activeCard.closest('#track');

			// 1. Determine if we are moving WITHIN the track or BETWEEN tracks
			let isCrossTrackMove = false;
			if (isVerticalMode) {
				// In Vertical, Left/Right jumps tracks
				if (direction === 'left' || direction === 'right') isCrossTrackMove = true;
			} else {
				// In Horizontal, Up/Down jumps tracks
				if (direction === 'up' || direction === 'down') isCrossTrackMove = true;
			}

			if (isCrossTrackMove) {
				// --- LOGIC FOR MOVING TO ANOTHER TRACK ---
				let targetTrack;
				if (direction === 'down' || direction === 'left') {
					targetTrack = currentTrack.previousElementSibling;
				} else {
					targetTrack = currentTrack.nextElementSibling;
				}

				if (targetTrack && targetTrack.id === 'track') {
					// Get current coordinates of the active card to determine where it "was"
					const rect = activeCard.getBoundingClientRect();
					const x = rect.left + rect.width / 2;
					const y = rect.top + rect.height / 2;

					// Find visual insertion point in the new track
					const sibling = getInsertionSibling(targetTrack, x, y);

					if (sibling) {
						targetTrack.insertBefore(activeCard, sibling);
					} else {
						targetTrack.appendChild(activeCard);
					}



					// Ensure the new track scrolls the moved card into view
					setTimeout(() => {
						activeCard.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
					}, 50);
				} else {
					showToast("No track in that direction");
				}
			} else {
				// --- LOGIC FOR MOVING WITHIN THE SAME TRACK ---
				if (direction === 'left' || direction === 'up') {
					const prev = activeCard.previousElementSibling;
					if (prev) activeCard.parentNode.insertBefore(activeCard, prev);
				} else {
					const next = activeCard.nextElementSibling;
					if (next) activeCard.parentNode.insertBefore(activeCard, next.nextElementSibling);
				}

				// Keep focus on the card after it moves
				activeCard.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
			}

			// Refresh overlays in case position-based logic (like theater mode) needs to update
			updateAllCardOverlays();
		}
		function moveCurrentCard(direction) {
			const track = document.getElementById('track');
			const centeredCard = track.querySelector('.card.is-centered');

			if (!centeredCard) return;

			if (direction === -1) {
				// Move Left/Up: Insert before the previous sibling
				const prev = centeredCard.previousElementSibling;
				if (prev && prev.classList.contains('card')) {
					track.insertBefore(centeredCard, prev);
				}
			} else if (direction === 1) {
				// Move Right/Down: Insert after the next sibling
				const next = centeredCard.nextElementSibling;
				if (next && next.classList.contains('card')) {
					// insertBefore(node, nextNext) effectively moves it after next
					track.insertBefore(next, centeredCard);
				}
			}

			// After moving, re-center the view on the same card immediately
			setTimeout(() => {
				centeredCard.scrollIntoView({
					behavior: 'smooth',
					block: 'center',
					inline: 'center'
				});

				// Refresh UI if you have counters or specific ordering logic
				if (typeof refreshAllUI === "function") refreshAllUI();
			}, 50);
		}

		function persistentWallpaper() {
			const savedWallpaper = localStorage.getItem('gallery_wallpaper');
			const defaultWallpaper = "https://substackcdn.com/image/fetch/$s_!KRIG!,w_720,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc5630f5a-5397-4ad1-b713-9ade6321e486_1536x1024.jpeg";
			const b = document.body;

			// Apply the image logic
			if (savedWallpaper) {
				b.style.backgroundImage = `url("${savedWallpaper}")`;
			} else {
				b.style.backgroundImage = `url("${defaultWallpaper}")`;
			}


		}
		function setCenteredAsWallpaper() {
			const activeCard = document.querySelector('.card.is-active img');
			if (!activeCard) {
				showToast("No active image centered");
				return;
			}

			const url = activeCard.src;
			const body = document.body;
			// Normalize background string for comparison
			const currentBg = body.style.backgroundImage.replace(/url\(["']?/, '').replace(/["']?\)/, '');

			if (currentBg === url) {
				// Toggle OFF: If already set, remove it
				body.style.backgroundImage = 'none';
				localStorage.removeItem('gallery_wallpaper'); // Remove from storage
				showToast("Wallpaper Removed");
			} else {
				// Toggle ON: Set new wallpaper
				body.style.backgroundImage = `url('${url}')`;
				localStorage.setItem('gallery_wallpaper', url); // Save to storage
				showToast("Wallpaper Set");
			}
		}
		function setWallpaper(url) {
			const body = document.body;
			// Normalize the URL for comparison (removing potential browser-added quotes/wrappers)
			const cleanUrl = url.replace(/['"]/g, '');
			const currentBg = body.style.backgroundImage.replace(/url\(["']?/, '').replace(/["']?\)/, '');

			// TOGGLE: If it's already the wallpaper, remove it
			if (currentBg === cleanUrl && cleanUrl !== "") {
				body.style.backgroundImage = 'none';
				localStorage.removeItem('gallery_wallpaper'); // Clear from storage
				showToast("Wallpaper Removed");
				document.querySelectorAll('.sq-btn').forEach(btn => btn.classList.remove('active-gold'));
			} else {
				// SET: Apply and save
				body.style.backgroundImage = `url('${cleanUrl}')`;
				localStorage.setItem('gallery_wallpaper', cleanUrl); // Save to storage
				showToast("Wallpaper Set");

				// Update active button state
				document.querySelectorAll('.sq-btn').forEach(btn => btn.classList.remove('active-gold'));
				if (event && event.currentTarget) {
					event.currentTarget.classList.add('active-gold');
				}
			}
		}
		async function smartImport() {
			let clipboardText = "";
			try {
				// 1. Try to read the clipboard
				clipboardText = await navigator.clipboard.readText();
				clipboardText = clipboardText ? clipboardText.trim() : "";
			} catch (err) {
				console.warn("Clipboard access denied, defaulting to file picker.");
			}

			// 2. Decision: Is it a Web URL?
			if (clipboardText.startsWith('http://') || clipboardText.startsWith('https://')) {
				showToast("URL detected in clipboard. Importing...");
				importFromURL(clipboardText);
			} else {
				// 3. Fallback: Open the local file dialog
				document.getElementById('json-input').click();
			}
		}

		async function importFromURL(url) {
			try {
				const response = await fetch(url);
				if (!response.ok) throw new Error(`HTTP ${response.status}`);
				const importedData = await response.json();

				const pathName = url;
				const existingIndex = savedPaths.findIndex(p => p.path === pathName);

				if (existingIndex === -1) {
					savedPaths.push({ path: pathName, checked: true, data: importedData });
				} else {
					savedPaths[existingIndex].data = importedData;
					savedPaths[existingIndex].checked = true;
				}

				renderPathList();
				loadActiveCollections();
				showToast(`Loaded: ${pathName.split('/').pop()}`);
			} catch (err) {
				showToast("Web Import Failed: " + err.message);
				// If web import fails, maybe the user actually wanted the file picker
				document.getElementById('json-input').click();
			}
		}
		function toggleImages() {
			const i = document.getElementById('collapsible-images');
			// Toggle between none and flex so it maintains its space-filling behavior
			i.style.display = (i.style.display === 'none') ? 'flex' : 'none';
			refreshAllUI();
		}
		function toggleOrientation() {
			const body = document.getElementById('body-wrap');
			const btn = document.getElementById('mode-toggle');
			const isVertical = body.classList.toggle('max-width');
			btn.innerText = isVertical ? 'V' : 'H';

			// No need to clear inline styles anymore, 
			// Flexbox handles the transition between row and column.
			updateCenteredCard();
		}
		function toggleOverlay(btn) {
			const card = btn.closest('.card');
			const overlay = card.querySelector('.card-tag-overlay');

			// Toggle between none and flex
			if (overlay.style.display === 'flex') {
				overlay.style.display = 'none';
			} else {
				overlay.style.display = 'flex';
				// Ensure the overlay content is up to date
				updateAllCardOverlays();
			}
		}
		function togglePathCheck(index) {
			savedPaths[index].checked = !savedPaths[index].checked;
			renderPathList();
			loadActiveCollections();
		}
function toggleSettings() {
    const panel = document.getElementById('settings-panel');
    // Check computed style to see if it's currently hidden
    const isHidden = window.getComputedStyle(panel).display === 'none';
    
    if (isHidden) {
        panel.style.display = 'block';
        // Optional: add your existing entrance animation
        panel.style.animation = 'cardEntrance 0.3s ease-out';
    } else {
        panel.style.display = 'none';
    }
}
		function toggleScrollMode() {
			const body = document.getElementById('body-wrap');
			const btn = document.getElementById('mode-toggle');
			const iconContainer = btn.querySelector('div'); // Targets the icon-h or icon-v div

			if (body.classList.contains('max-width')) {
				// Switch to Horizontal
				body.classList.remove('max-width');
				iconContainer.className = 'icon-h';
				localStorage.setItem('scrollDirection', 'horizontal'); // Save state
			} else {
				// Switch to Vertical
				body.classList.add('max-width');
				iconContainer.className = 'icon-v';
				localStorage.setItem('scrollDirection', 'vertical'); // Save state
			}

			const activeCard = document.querySelector('.card.is-active');
			if (activeCard) {
				// We use a small timeout to ensure the CSS transition/layout 
				// has started before calculating the new scroll position.
				setTimeout(() => {
					activeCard.scrollIntoView({
						behavior: 'smooth',
						block: 'nearest',    // Centers vertically in vertical mode
						inline: 'nearest'    // Centers horizontally in horizontal mode
					});
				}, 400);
			}

			updateCenteredCard();

		}
		function removePath(index) {
			savedPaths.splice(index, 1);
			renderPathList();
			loadActiveCollections();
		}
		/** * Reorders the active image within its track.
 * @param {number} direction - -1 for Up/Left, 1 for Down/Right
 * @param {string} modeRequirement - 'horizontal' or 'vertical'
 */
		function reorderImage(direction, modeRequirement) {
			const activeCard = document.querySelector('.card.is-active');
			if (!activeCard) return;

			const bodyWrap = document.getElementById('body-wrap');
			const isMaxHeight = bodyWrap.classList.contains('max-height'); // Vertical Mode
			const isMaxWidth = bodyWrap.classList.contains('max-width');   // Horizontal Mode

			// Validation: Only allow movement if the mode matches the button
			if (modeRequirement === 'horizontal' && isMaxHeight) return;
			if (modeRequirement === 'vertical' && isMaxWidth) return;

			if (direction === -1) {
				const prev = activeCard.previousElementSibling;
				if (prev) activeCard.parentNode.insertBefore(activeCard, prev);
			} else {
				const next = activeCard.nextElementSibling;
				if (next) activeCard.parentNode.insertBefore(next, activeCard);
			}

			// Ensure the moved card stays centered in the view
			activeCard.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
		}
		function loadActiveCollections() {
			let combined = [];
			savedPaths.forEach(item => {
				if (item.checked && item.data) {
					combined = combined.concat(Array.isArray(item.data) ? item.data : [item.data]);
				}
			});

			// Fast duplicate removal using a Map
			const uniqueMap = new Map();
			combined.forEach(item => uniqueMap.set(item.p, item));
			DATA = Array.from(uniqueMap.values());

			// ADD THIS SECTION: Update the global tag list
			const tags = new Set();
			DATA.forEach(item => {
				if (item.t && Array.isArray(item.t)) {
					item.t.forEach(tag => tags.add(tag));
				}
			});
			ALL_TAGS = Array.from(tags).sort(); // Update the cloud source

			refreshAllUI();
		}

		function initScrollDirection() {
			const savedDirection = localStorage.getItem('scrollDirection');
			const body = document.getElementById('body-wrap');
			const btn = document.getElementById('mode-toggle');
			const iconContainer = btn?.querySelector('div');

			if (savedDirection === 'vertical') {
				body.classList.add('max-width');
				if (iconContainer) iconContainer.className = 'icon-v';
			} else {
				// Default to horizontal
				body.classList.remove('max-width');
				if (iconContainer) iconContainer.className = 'icon-h';
			}
		}


		function importJSON(input) {
			const file = input.files[0];
			if (!file) return;
			const reader = new FileReader();
			reader.onload = (e) => {
				try {
					const importedData = JSON.parse(e.target.result);

					// Use webkitRelativePath if available, otherwise fallback to name
					const pathName = file.webkitRelativePath || file.name;

					const existingIndex = savedPaths.findIndex(p => p.path === pathName);
					if (existingIndex === -1) {
						savedPaths.push({ path: pathName, checked: true, data: importedData });
					} else {
						savedPaths[existingIndex].data = importedData;
						savedPaths[existingIndex].checked = true;
					}

					renderPathList();
					loadActiveCollections();
					showToast(`Imported: ${pathName}`);
				} catch (err) {
					showToast("Error: Invalid JSON");
				}
				input.value = "";
			};
			reader.readAsText(file);
		}

		function renderPathList() {
			const container = document.getElementById('path-list-container');
			if (!container) return;
			container.innerHTML = '';

			// Calculate the counts for the header display
			const greenCount = savedPaths.filter(p => p.data !== null).length;
			const totalCount = savedPaths.length;

			// Update the UI with the "Green / Total" format
			document.getElementById('collection-count').innerText = `${greenCount}/${totalCount}`;

			savedPaths.forEach((item, index) => {
				const isLoaded = item.data !== null;
				const div = document.createElement('div');
				// Apply 'loaded' class if data exists (green), 'stale' if checked but no data (yellow)
				div.className = `path-entry ${isLoaded ? 'loaded' : (item.checked ? 'stale' : '')}`;

				div.innerHTML = `
            <input type="checkbox" ${item.checked ? 'checked' : ''} onchange="togglePathCheck(${index})">
            <div class="path-text" onclick="handlePathClick(${index})">${item.path}</div>
            <button class="inline-toggle action-btn" onclick="removePath(${index})">✕</button>
        `;
				container.appendChild(div);
			});

			// Save metadata to local storage
			const metadata = savedPaths.map(p => ({ path: p.path, checked: p.checked }));
			localStorage.setItem('gallery_paths', JSON.stringify(metadata));
		}

		async function handlePathClick(index) {
			const path = savedPaths[index].path;
			const isURL = path.startsWith('http://') || path.startsWith('https://');

			if (isURL) {
				showToast("Fetching data from URL...");
				await importFromURL(path);
			} else {
				try {
					await navigator.clipboard.writeText(path);
					showToast("Path copied. Paste into file picker.");
					document.getElementById('json-input').click();
				} catch (err) {
					showToast("Clipboard failed. Opening picker...");
					document.getElementById('json-input').click();
				}
			}
		}



		function showSplash(src) {
			const splash = document.getElementById('splash-screen');
			const splashImg = document.getElementById('splash-img');

			// 1. Reset values so it starts maximized and centered
			scale = 1;
			pointX = 0;
			pointY = 0;

			// 2. Set image and update transform BEFORE showing
			splashImg.src = src;
			updateTransform();

			// 3. Show the screen
			splash.style.display = 'flex';
			document.body.style.overflow = 'hidden';
		}

		function hideSplash() {
			const splash = document.getElementById('splash-screen');
			splash.style.display = 'none';
			document.body.style.overflow = '';

			// Clear image to save memory
			document.getElementById('splash-img').src = '';
		}

		function updateTransform() {
			const img = document.getElementById('splash-img');
			// Using translate3d is more performant for panning
			img.style.transform = `translate3d(${pointX}px, ${pointY}px, 0) scale(${scale})`;
		}

		// Panning Logic
		const sImg = document.getElementById('splash-img');
		sImg.onmousedown = (e) => {
			if (scale === 1) return;
			isPanning = true;
			startX = e.clientX - pointX;
			startY = e.clientY - pointY;
		};
		window.onmousemove = (e) => {
			if (!isPanning) return;
			pointX = e.clientX - startX;
			pointY = e.clientY - startY;
			updateTransform();
		};
		window.onmouseup = () => isPanning = false;

		// Zoom Logic
		document.getElementById('splash-screen').onwheel = (e) => {
			e.preventDefault();
			scale = e.deltaY > 0 ? Math.max(1, scale - 0.2) : Math.min(5, scale + 0.2);
			if (scale === 1) { pointX = 0; pointY = 0; }
			updateTransform();
		};

		function showToast(msg) {
			const t = document.getElementById('toast');
			t.innerText = msg;
			t.classList.add('show');
			setTimeout(() => t.classList.remove('show'), 2500);
		}
		function updateCenteredCard() {
			// 1. Check if more than one track exists
			const multitrack = document.getElementById('multitrack');
			if (multitrack && multitrack.children.length > 1) {
				// If there's more than one track, just exit

				return;
			}
			const track = document.getElementById('track');
			const cards = track.querySelectorAll('.card');
			const bodyWrap = document.getElementById('body-wrap');
			const isVertical = bodyWrap.classList.contains('max-width');

			// Find the center point of the viewport
			const viewportCenterX = window.innerWidth / 2;
			const viewportCenterY = window.innerHeight / 2;

			let closestCard = null;
			let minDistance = Infinity;

			cards.forEach((card, index) => {
				const rect = card.getBoundingClientRect();
				const cardCenterX = rect.left + rect.width / 2;
				const cardCenterY = rect.top + rect.height / 2;

				// Calculate distance from viewport center based on orientation
				const distance = isVertical
					? Math.abs(viewportCenterY - cardCenterY)
					: Math.abs(viewportCenterX - cardCenterX);

				if (distance < minDistance) {
					minDistance = distance;
					closestCard = { card, index };
				}
			});

			if (closestCard) {
				// 1. Clear previous centered/active states
				cards.forEach(c => {
					c.classList.remove('is-centered');
					c.classList.remove('is-active'); // This triggers the white border
				});

				// 2. Highlight the new center card
				closestCard.card.classList.add('is-centered');
				closestCard.card.classList.add('is-active');
				console.log("@@EEE1");

			}
		}
		function updateStageCount() {
			const count = document.querySelectorAll('.card').length;
			document.getElementById('stage-count').innerText = count;
		}
		function syncSidebarHighlights() {
			const activePaths = Array.from(document.querySelectorAll('.card')).map(c => c.dataset.path);
			document.querySelectorAll('.file-item').forEach(item => {
				const itemPath = item.dataset.path;
				item.classList.toggle('active-item', activePaths.includes(itemPath));
			});
			updateStageCount();
		}

		function createCard(item) {
			// 1. Change: Target the active track or the default track
			const multitrack = document.getElementById('multitrack');
			const activeCard = document.querySelector('.card.is-active');
			const activeTrack = activeCard ? activeCard.parentElement : document.querySelector('#track');
			const isVertical = document.getElementById('body-wrap').classList.contains('max-width');

			// Duplicate check
			const existing = Array.from(document.querySelectorAll('.card')).find(c => c.dataset.path === item.p);
			if (existing) {
				if (existing.classList.contains('pinned')) {
					existing.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
				} else {
					existing.remove();
					syncSidebarHighlights();
				}
				return;
			}

			if (autoFlush) {
				document.querySelectorAll('.card').forEach(c => {
					if (!c.classList.contains('pinned')) c.remove();
				});
			}

			const c = document.createElement('div');
			c.className = 'card';
			c.dataset.path = item.p;
			c.classList.add('is-active');

			// 2. Change: Card Click Logic
			c.onclick = function (e) {
				// Prevent background click-to-hide sidebar
				e.stopPropagation();

				// In Multi-track, we manually set active because center-detection is off
				if (multitrack.children.length > 1) {
					document.querySelectorAll('.card').forEach(card => card.classList.remove('is-active'));
					c.classList.add('is-active');

				}

			};
			c.addEventListener('dblclick', function () {
				showSplash(item.p);
			});

			c.innerHTML = `
    <div class="card-tools">
      <button class="tool-btn pin-btn" title="Star"><div class="icon-star"></div></button>
      <button class="tool-btn" onclick="toggleOverlay(this)">#</button>
      <button class="tool-btn" onclick="event.stopPropagation(); this.closest('.card').remove(); syncSidebarHighlights();" title="Close">✕</button>
    </div>
    <div class="card-tag-overlay"></div>
    <img src="${item.p}" onerror="handleMissingImage(this, '${item.p}')">`;

			c.querySelector('.pin-btn').onclick = function (e) {
				e.stopPropagation(); // Prevent card focus when just pinning
				this.style.color = c.classList.toggle('pinned') ? 'var(--gold)' : 'white';
			};

			// 3. Change: Insertion logic targets activeTrack
			const cards = Array.from(activeTrack.querySelectorAll('.card'));

			if (cards.length === 0) {
				activeTrack.appendChild(c);
			} else {
				const centerX = activeTrack.scrollLeft + (activeTrack.clientWidth / 2);
				const centerY = activeTrack.scrollTop + (activeTrack.clientHeight / 2);

				let closestCard = cards[0];
				let minDistance = Infinity;

				cards.forEach(card => {
					const midX = card.offsetLeft + (card.offsetWidth / 2);
					const midY = card.offsetTop + (card.offsetHeight / 2);
					const dist = isVertical ? Math.abs(centerY - midY) : Math.abs(centerX - midX);

					if (dist < minDistance) {
						minDistance = dist;
						closestCard = card;
					}
				});

				if (currentDock === 'left') {
					closestCard.insertAdjacentElement('beforebegin', c);

				} else {
					closestCard.insertAdjacentElement('afterend', c);

				}
			}

			// --- NEW LOGIC FOR MULTI-TRACK AUTO-ACTIVE ---			
			if (multitrack && multitrack.children.length > 1) {
				// 1. Clear existing active state from all other cards
				document.querySelectorAll('.card.is-active').forEach(c => c.classList.remove('is-active'));

				// 2. Make this new card active
				c.classList.add('is-active');


			}

			setTimeout(() => {
				//if (multitrack.children.length > 1) {
				c.scrollIntoView({
					behavior: 'smooth',
					block: 'center',
					inline: 'center'
				});
				//}else{
				//c.scrollIntoView({behavior: 'smooth',block: 'nearest',inline: 'nearest'});
				//}
				updateAllCardOverlays();
				syncSidebarHighlights();

				// This function will now check if (multitrack.children.length > 1) 
				// and skip logic if multi-track is active.
				updateCenteredCard();
			}, 50);
		}

		function updateAllCardOverlays() {
			document.querySelectorAll('.card').forEach(card => {
				const path = card.dataset.path;
				const item = DATA.find(i => i.p === path);
				if (!item) return;

				const overlay = card.querySelector('.card-tag-overlay');
				overlay.innerHTML = "";
				[...item.t].sort().forEach(t => {
					const p = document.createElement('div');
					p.className = 'tag-pill';
					if (activeTags.has(t)) p.classList.add('active');
					p.innerText = t;
					p.onclick = (e) => { e.stopPropagation(); toggleTag(t); };
					overlay.appendChild(p);
				});
			});
		}

		function toggleAutoFlush() {
			autoFlush = !autoFlush;
			localStorage.setItem('gallery_flush', autoFlush);
			updateAutoFlushUI();
			showToast(autoFlush ? "Auto-Flush Enabled" : "Auto-Flush Disabled");
		}

		function updateAutoFlushUI() {
			const btn = document.getElementById('auto-flush-btn');
			btn.classList.toggle('active-gold', autoFlush); // Solid yellow when active
			btn.classList.toggle('action-btn', !autoFlush); // Semi-transparent when inactive
		}

		function toggleTagSort() {
			// 1. Switch the underlying mode
			tagSortMode = (tagSortMode === 'alpha') ? 'freq' : 'alpha';
			localStorage.setItem('gallery_tag_sort', tagSortMode);

			const btn = document.getElementById('tag-sort-btn');

			// 2. Show the FUTURE state (the opposite of current mode)
			// If current is alpha, show '1-9' (the frequency option)
			// If current is freq, show 'A-Z' (the alphabetical option)
			btn.innerText = (tagSortMode === 'alpha') ? '1-9' : 'A-Z';

			// 3. Keep it semi-transparent by ensuring only 'action-btn' is used
			btn.className = 'inline-toggle action-btn';

			refreshAllUI();
		}
		function updateTagSortUI() {
			document.getElementById('tag-sort-btn').innerText = tagSortMode === 'alpha' ? 'A-Z' : '1-9';
		}

		function refreshAllUI() {
			const q = document.getElementById('master-search').value.toLowerCase();
			const list = document.getElementById('file-list');
			list.innerHTML = "";
			list.className = "file-list" + (sidebarIsGrid ? " grid-view" : "");

			const filtered = DATA.filter(i => {
				const matchesActive = Array.from(activeTags).every(at => i.t.includes(at));
				const matchesSearch = q === "" || i.t.some(it => it.toLowerCase().includes(q));
				return matchesActive && matchesSearch;
			});

			// 1. Calculate tag frequencies in the current filtered set
			const tagFreq = {};
			filtered.forEach(i => i.t.forEach(t => tagFreq[t] = (tagFreq[t] || 0) + 1));

			// 2. Sort the cloud based on the active mode (Alpha vs Frequency)
			let sortedTags = ALL_TAGS.filter(t => t.toLowerCase().includes(q));

			if (tagSortMode === 'freq') {
				sortedTags.sort((a, b) => (tagFreq[b] || 0) - (tagFreq[a] || 0) || a.localeCompare(b));
			} else {
				sortedTags.sort((a, b) => a.localeCompare(b));
			}

			const cloud = document.getElementById('tag-cloud');
			cloud.innerHTML = "";

			sortedTags.forEach(t => {
				const count = tagFreq[t] || 0;
				if (count === 0 && activeTags.size > 0 && !activeTags.has(t)) return; // Hide empty tags if filtering

				const p = document.createElement('div');
				p.className = 'tag-pill' + (activeTags.has(t) ? ' active' : '');
				// Optional: Add a small count indicator next to the tag name
				p.innerHTML = `${t} <span class="tag-count-small">${count}</span>`;
				p.onclick = () => {
					if (activeTags.has(t)) activeTags.delete(t);
					else activeTags.add(t);
					refreshAllUI();
				};
				cloud.appendChild(p);
			});

			document.getElementById('tag-count').innerText = cloud.children.length;
			document.getElementById('img-count').innerText = filtered.length;

			// ... rest of function (file-item generation) remains same
			filtered.forEach((item, idx) => {
				const d = document.createElement('div');
				d.className = 'file-item';
				d.dataset.path = item.p;
				d.id = 'f-' + idx;
				d.innerHTML = sidebarIsGrid ? `<img src="${item.p}" loading="lazy">` : item.n;
				d.onclick = () => createCard(item);
				list.appendChild(d);
			});
			updateAllCardOverlays();
			syncSidebarHighlights();
			updateStageCount();
		}

		function clearWorkspace() {
			document.querySelectorAll('.card').forEach(c => {
				if (!c.classList.contains('pinned')) c.remove();
			});
			syncSidebarHighlights();
		}

		function exportFilteredData() {
			const q = document.getElementById('master-search').value.toLowerCase();
			const filtered = DATA.filter(i => {
				const matchesActive = Array.from(activeTags).every(at => i.t.includes(at));
				return matchesActive && (q === "" || i.t.some(it => it.toLowerCase().includes(q)));
			});
			const blob = new Blob([JSON.stringify(filtered, null, 2)], { type: 'application/json' });
			const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
			a.download = `Filtered_Data_${new Date().toISOString().slice(0, 10)}.json`; a.click();
			showToast(`Exported ${filtered.length} items.`);
		}
		function exportGallery() {
			let docClone = document.documentElement.cloneNode(true);
			let bodyWrap = docClone.querySelector('#body-wrap');
			if (bodyWrap) bodyWrap.classList.add('collapsed');

			// Ensure Meta Charset is present
			let head = docClone.querySelector('head');
			if (!head.querySelector('meta[charset]')) {
				let meta = document.createElement('meta');
				meta.setAttribute('charset', 'UTF-8');
				head.prepend(meta);
			}

			let html = docClone.outerHTML;

			// 3. Inject current data and tags
			html = html.replace(/let DATA = \[.*?\];/, `let DATA = ${JSON.stringify(DATA)};`);
			html = html.replace(/let ALL_TAGS = \[.*?\];/, `let ALL_TAGS = ${JSON.stringify(ALL_TAGS)};`);

			const blob = new Blob(['<!DOCTYPE html>\n' + html], { type: 'text/html' });
			const a = document.createElement('a');
			a.href = URL.createObjectURL(blob);
			a.download = 'Gallery_Export.html';
			a.click();
		}
		/**
		 * Finds the existing card in a track that the new card should be inserted BEFORE.
		 * @param {HTMLElement} track - The target track container.
		 * @param {number} x - The horizontal coordinate (for Horizontal mode).
		 * @param {number} y - The vertical coordinate (for Vertical mode).
		 * @returns {HTMLElement|null} - The sibling to insert before, or null to append at the end.
		 */
		function getInsertionSibling(track, x, y) {
			const isVertical = document.getElementById('body-wrap').classList.contains('max-width');
			const siblings = Array.from(track.querySelectorAll('.card:not(.is-dragging)'));

			return siblings.find(sibling => {
				const box = sibling.getBoundingClientRect();
				if (isVertical) {
					// In Vertical mode, compare Y coordinates (Vertical mid-point)
					return y < box.top + box.height / 2;
				} else {
					// In Horizontal mode, compare X coordinates (Horizontal mid-point)
					return x < box.left + box.width / 2;
				}
			});
		}
		function updateStageCount() { 
			return;
			document.getElementById('stage-count').innerText = document.querySelectorAll('.card').length; }
		// New function to handle the side-specific click
		function restoreAndDock(side) {
			updateDock(side);      // Move the sidebar to clicked side
			toggleSidebar(true);   // Show the sidebar
		}
		function handleCornerClick(clickedSide) {
			const bodyWrap = document.getElementById('body-wrap');
			const isCollapsed = bodyWrap.classList.contains('collapsed');
			console.log("@@BeforeBegin" + currentDock);
			if (currentDock !== clickedSide) {
				// Instant side swap and show
				console.log("@@EREWR");
				updateDock(clickedSide);
				toggleSidebar(true);
			} else {
				// Toggle fade in/out
				toggleSidebar(isCollapsed);
			}
		}
		function toggleSidebar(show) {
			const splash = document.getElementById('splash-screen');

			// 1. Check if the splash screen is currently visible
			if (window.getComputedStyle(splash).display !== 'none') {
				// If splash is open, the button acts as a CLOSE button
				hideSplash();
				return; // Exit the function so the sidebar doesn't open
			}

			const bodyWrap = document.getElementById('body-wrap');
			bodyWrap.classList.toggle('collapsed', !show);
		}
		function updateDock(side) {
			currentDock = side;
			// Add/Remove class to handle the layout direction
			document.body.classList.toggle('dock-left', side === 'left');


			// Save preference
			localStorage.setItem('gallery_dock', side);
		}
		function handleLinkAction(e) { e.preventDefault(); const filtered = Array.from(activeTags).filter(t => !t.match(/^\[.*\]$/)); navigator.clipboard.writeText((document.getElementById('user-note').value + " " + filtered.join(' ')).trim()); const btn = document.getElementById('add-btn'); btn.innerText = '✓'; setTimeout(() => btn.innerText = '+', 1000); }


		function toggleFocus(card) { cycleViewMode(); setTimeout(() => { card.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' }); }, 150); }
		function handleMissingImage(img, path) { const card = img.closest('.card'); DATA = DATA.filter(i => i.p !== path); card.remove(); refreshAllUI(); }
		function toggleTag(t) { if (activeTags.has(t)) activeTags.delete(t); else activeTags.add(t); refreshAllUI(); }
		function saveNotes(v) { localStorage.setItem('gallery_notes', v); }
		let scale = 1;
		let pointX = 0;
		let pointY = 0;
		let startX = 0;
		let startY = 0;
		let isPanning = false;

		const splashImg = document.getElementById('splash-img');
		const splashScreen = document.getElementById('splash-screen');

		// ZOOM LOGIC (Mouse Wheel)
		splashScreen.onwheel = function (e) {
			e.preventDefault();
			const delta = e.deltaY;
			const zoomSpeed = 0.2;

			if (delta > 0) {
				scale = Math.max(1, scale - zoomSpeed); // Min zoom is 1x
			} else {
				scale = Math.min(5, scale + zoomSpeed); // Max zoom is 5x
			}

			// If we zoom back to 1, reset position
			if (scale === 1) {
				pointX = 0;
				pointY = 0;
			}

			updateTransform();
		};

		// PAN LOGIC (Click and Drag)
		splashImg.onmousedown = function (e) {
			if (scale === 1) return; // Only pan if zoomed in
			e.preventDefault();
			isPanning = true;
			startX = e.clientX - pointX;
			startY = e.clientY - pointY;
		};

		window.onmousemove = function (e) {
			if (!isPanning) return;
			pointX = e.clientX - startX;
			pointY = e.clientY - startY;
			updateTransform();
		};

		window.onmouseup = function () {
			isPanning = false;
		};

		function updateTransform() {
			splashImg.style.transform = `translate(${pointX}px, ${pointY}px) scale(${scale})`;
		}

		// Update your hideSplash to reset these values
		function hideSplash() {
			const splash = document.getElementById('splash-screen');
			splash.style.display = 'none';
			document.body.style.overflow = '';

			// Reset state for next time
			scale = 1;
			pointX = 0;
			pointY = 0;
			updateTransform();
		}
		function toggleStageTools() {
			const s = document.getElementById('stage-tools');
			// Check for empty string (initial state)
			s.style.display = (s.style.display === 'none' || s.style.display === '') ? 'flex' : 'none';
		}
		function toggleCollections() {
			const c = document.getElementById('collapsible-collections');
			c.style.display = (c.style.display === 'none' || c.style.display === '') ? 'flex' : 'none';
		}
		function toggleTagCloud() {
			const h = document.getElementById('collapsible-tags');
			h.style.display = (h.style.display === 'none') ? 'block' : 'none';
		}
		function cycleViewMode() {
			const bodyWrap = document.getElementById('body-wrap');
			const btn = document.getElementById('mode-toggle');
			const isMax = bodyWrap.classList.toggle('max-width');

			localStorage.setItem('gallery_is_max_width', isMax);

			// Set character based on current mode
			// icon-v is used for Max Height mode, icon-h for Max Width mode
			btn.innerHTML = isMax ? '<div class="icon-v"></div>' : '<div class="icon-h"></div>';
			// Trigger highlight update immediately after switching modes
			setTimeout(updateCenteredCard, 100);
		}

		function toggleSidebarView() {
			sidebarIsGrid = !sidebarIsGrid;
			const icon = document.getElementById('toggle-icon');
			const container = document.getElementById('grid-slider-container'); // Get the slider container

			if (sidebarIsGrid) {
				icon.className = 'css-list';
				icon.innerHTML = '<div></div><div></div><div></div>';
				if (container) container.style.display = 'flex'; // Show slider
			} else {
				icon.className = 'css-grid';
				icon.innerHTML = '<div></div><div></div><div></div><div></div>';
				if (container) container.style.display = 'none'; // Hide slider
			}

			refreshAllUI();
		}
		function updateGridCols(v) {
			document.documentElement.style.setProperty('--grid-cols', v);
			// document.getElementById('col-val').innerText = v; // REMOVE OR COMMENT OUT THIS LINE
			localStorage.setItem('gallery_cols', v);
		}

		document.addEventListener('wheel', (e) => {
			// Only intercept if we are in Horizontal Mode
			if (!document.getElementById('body-wrap').classList.contains('max-width')) {
				const targetTrack = e.target.closest('#track');

				if (targetTrack) {
					e.preventDefault();
					// Scroll the specific track the mouse is hovering over
					targetTrack.scrollLeft += e.deltaY;
				}
			}
		}, { passive: false });
		// Click outside to hide sidebar
		// Refined Click-to-Hide Logic
		document.addEventListener('mousedown', (e) => {
			const sidebar = document.getElementById('sidebar');
			const bodyWrap = document.getElementById('body-wrap');
			const isSidebarOpen = !bodyWrap.classList.contains('collapsed');

			// If sidebar is closed, do nothing
			if (!isSidebarOpen) return;

			// Check if the click was on the main background or an image, but NOT a button
			const clickedMain = document.getElementById('track').contains(e.target);

			const clickedButton =
				e.target.closest('.tool-btn') ||
				e.target.closest('.sq-btn') ||
				e.target.closest('.card') ||
				e.target.closest('.card-tag-overlay') ||
				e.target.closest('.tag-btn'); // Assuming your tags have this class

			// Hide only if clicking main area/image AND not clicking a functional button
			if (clickedMain && !clickedButton) {
				toggleSidebar(false);
			}
		});
		// Add this to your initialization logic
		document.getElementById('track').addEventListener('scroll', updateCenteredCard);
		document.addEventListener('mousedown', (e) => {
			const track = e.target.closest('#track');
			if (track) {
				// Remove active class from all tracks
				document.querySelectorAll('#track').forEach(t => t.classList.remove('active-track'));
				// Add to the one we just clicked
				track.classList.add('active-track');
			}
		});
		// Also run it once on load to highlight the first card
		window.addEventListener('load', updateCenteredCard);
	</script>


</body>

</html>