<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
	<title>Magic Theater</title>
	<link rel="icon" type="image/png" href="https://magicbakery.github.io/images/Star.png">
	<script>
		const APP_VERSION = "20260110201916"; //#Version
		const APP_ANNOUNCEMENT = "20260110: Command Panel Upgrades."
	</script>
	<style>
		:root {
			--bg: #000;
			--panel: rgba(15, 15, 15, 0.5);
			--border: rgba(255, 255, 255, 0.1);
			--accent: #fff;
			--text: #fff;
			--text-dim: #CCC;
			--grid-cols: 3;
			--sidebar-w: 300px;
			--gold: #ffd700;
			--h-dir: row;
			--green: #4CAF50;
		}

		* {
			box-sizing: border-box;
		}

		/* Target normal, visited, and active states */
		a,
		a:active,
		a:hover,
		a:visited {
			color: inherit;
			text-decoration: none;
		}

		/* Only triggers when running as an installed Windows app */
		@media (display-mode: standalone) {
			body {
				/* Adds a little breathing room at the top for the window controls */
				padding-top: env(safe-area-inset-top);
			}
		}


		html,
		body {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
		}

		/* Ensure the tagging mode is clear but doesn't break pill visibility */
		body.tag-assign-active {
			/* Optional: subtle cursor change for the whole app */
			cursor: crosshair;
		}

		input {
			padding: 8px;
			border-radius: 4px;
			border: 1px solid #444;
			background: #2222;
			color: #fff;
			width: 100%;
			font-family: monospace;
		}

		/* The Green Tint Highlight */
		.already-has-tag {
			background-color: rgba(0, 255, 0, 0.2) !important;
			/* Green tint */
			outline: 2px solid var(--green) !important;
			box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
			transition: background-color 0.2s;
		}

		/* Visual indicator for "Already Tagged" items */
		.already-has-tag::before {
			content: "✅";
			position: absolute;
			top: 2px;
			right: 5px;
			color: var(--green);
			font-weight: bold;
			z-index: 10;
		}

		.modal-overlay {
			position: fixed;
			inset: 0;
			background: rgba(0, 0, 0, 0.7);
			backdrop-filter: blur(10px);
			display: flex;
			align-items: center;
			justify-content: center;
			z-index: var(--z-Notifications);
		}

		.modal-content {
			background: #222;
			padding: 20px;
			border-radius: 15px;
			border: 1px solid var(--gold);
			text-align: center;
		}

		.modal-btns button {
			padding: 10px 25px;
			border-radius: 8px;
			border: none !important;
			cursor: pointer;
			font-weight: bold;
			transition: all 0.3s ease;
			/* Smooth color switching */
			filter: grayscale(0);
			opacity: 1;
		}

		.confirm-yes {
			background-color: var(--green);
			color: white;
		}

		.confirm-no {
			background-color: #444;
			color: #ccc;
		}

		.confirm-no:hover {
			background-color: #cc0000;
			color: white;
		}

		#custom-confirm:has(.confirm-no:hover) .confirm-yes {
			background-color: #444;
			color: #888;
			filter: grayscale(1);
			opacity: 0.6;
		}


		/* Container for the Tab Buttons */
		.panel-tabs {
			display: flex;
			gap: 10px;
			margin-bottom: 5px;
			padding-bottom: 0px;
		}

		.tab-btn {
			background: none;
			border: none;
			color: var(--text-dim);
			cursor: pointer;
			font-size: 0.9rem;
			padding: 5px 5px;
			transition: color 0.3s;
		}

		.tab-btn.active {
			color: var(--gold);
			font-weight: bold;
		}

		#tab-card-notes {
			display: block;
			/* Hidden by default */
			flex-direction: column;
			gap: 10px;
			height: 100%;
		}

		/* If the input has text, change the cursor across the app */
		#assign-tag-input:not(:placeholder-shown)~#main-content {
			cursor: copy;
		}

		/* The Highlight State */
		.file-item .card.already-has-tag {
			background-color: rgba(46, 204, 113, 0.25) !important;
			/* Green tint */
			outline: 2px solid #2ecc71 !important;
			transition: background-color 0.2s, outline 0.2s;
			position: relative;
		}

		/* Optional: Add a small green indicator dot or checkmark */
		.file-item.already-has-tag::after,
		.card.already-has-tag::after {
			content: '●';
			position: absolute;
			top: 5px;
			right: 8px;
			color: #2ecc71;
			font-size: 12px;
			text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
		}

		/* Highlight items on hover when a tag is ready to be assigned */
		.tag-assign-active .card:hover,
		.tag-assign-active .file-item:hover {
			outline: 2px solid #00ff00;
		}

		#card-notes {
			width: 100%;
			height: 200px;
			/* Adjust based on sidebar height */
			background: rgba(255, 255, 255, 0.05);
			border: 1px solid var(--border);
			color: var(--text);
			padding: 10px;
			border-radius: 8px;
			resize: none;
			font-family: inherit;
			line-height: 1.5;
			outline: none;
		}

		#command-panel:has(.is-dirty) #card-notes:focus {
			border-color: var(--gold);
		}

		/* The Save Button Styling */
		.save-notes-btn {
			align-self: flex-end;
			background: transparent;
			border: 1px solid #888;
			color: #888;
			/* Grayed out by default */
			padding: 0px;
			border-radius: 5px;
			cursor: default;
			/* Not clickable when clean */
			transition: all 0.3s ease;
			display: flex;
			align-items: center;
			gap: 8px;
			/*filter: grayscale(1);*/
			/*opacity: 0.5;*/
		}

		/* The "Dirty" State: When user has typed but not saved */
		#command-panel:has(.is-dirty) .save-notes-btn {
			color: var(--gold);
			border: 3px solid gold;

			cursor: pointer;
			filter: grayscale(0);
			opacity: 1;
			box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
		}

		#command-panel:has(.is-dirty) .save-notes-btn:hover {
			background: rgba(255, 215, 0, 0.1);
		}

		.bottom-menu-container {
			position: fixed;
			bottom: 0;
			left: 50%;
			transform: translateX(-50%);
			z-index: var(--z-TransparentControls);
			display: flex;
			flex-direction: row;
			align-items: center;
			padding-bottom: 0;

		}


		.semi-circle-btn {
			width: 100px;
			height: 50px;
			background: rgba(255, 255, 255, 0.0);
			border: 1px solid rgba(255, 255, 255, 0.0);
			border-bottom: none;
			border-radius: 50px 50px 0 0;
			cursor: pointer;
			display: flex;
			justify-content: center;
			align-items: center;

			/* Layering & Transparency */
			z-index: 2;
			/* Higher than the panel */
			opacity: 0;
			/* Completely transparent */
			transition: opacity 0.3s ease;

			/* Backdrop blur looks great even when semi-transparent */
			backdrop-filter: blur(5px);
		}

		.bottom-menu-container:hover .semi-circle-btn {
			opacity: 1;
			/* Reveals on hover */
		}


		/* Graphic inside (matching your existing corner button style) */
		.menu-icon-graphic {
			display: flex;
			flex-direction: column;
			gap: 3px;
			margin-top: 5px;
			/* Adjusting for the half-shape visual center */
		}

		.menu-icon-graphic span {
			display: block;
			width: 20px;
			height: 2px;
			background: grey;
		}

		/* The Panel that pops up */
		.bottom-menu-panel {
			display: none;
			/* Hidden by default */
			width: auto;
			max-width: 800px;
			position: fixed;
			bottom: 0px;
			left: 50%;
			transform: translateX(-50%);
			background: rgba(0, 0, 0, 0.05);
			border: 1px solid var(--border);
			backdrop-filter: blur(10px);
			border-radius: 20px 20px 0 0;
			padding: 10px;
			margin: 0px;
			flex-direction: row;
			gap: 8px;
			text-align: center;
			justify-content: center;
			/* Sits above the button */
			z-index: var(--z-TransparentControls);
		}

		.bottom-menu-panel.active {
			display: flex;
		}


		#loading-screen {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: #000;
			z-index: var(--z-LoadingScreen, 1000);
			display: flex;
			justify-content: center;
			align-items: center;
			transition: opacity 0.8s ease-in-out, visibility 0.8s;
		}

		#sidebar *,
		.tag-cloud,
		.file-list,
		#track {
			-ms-overflow-style: none;
			scrollbar-width: none;

		}

		#sidebar *::-webkit-scrollbar,
		#track::-webkit-scrollbar {
			display: none;
		}

		/* Mobile-specific override */
		@media (max-width: 768px) {
			#sidebar, #collapsible-collections, #collapsible-tags, #collapsible-images, #header-bar {
				opacity: 1 !important;
				/* Optional: If you have a semi-transparent background, 
           you might want to force it to solid as well */
				background-color: rgba(26, 26, 26, 1) !important;

				/* Ensures any transitions don't fight with the opacity */
				transition: none !important;
			}
		}

		body {
			background: var(--bg);
			/* This is #000, so it fades from black */
			color: var(--text);
			font-family: monospace;
			margin: 0;
			display: flex;
			height: 100vh;
			height: 100dvh;
			width: 100vw;
			overflow: hidden;
			background-size: cover;
			background-position: center;
			background-attachment: fixed;
			transition: background-image 0.5s ease-in-out;
		}

		body::before {
			content: "";
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.2);
			z-index: -1;
			pointer-events: none;
		}

		#splash-screen {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			height: 100dvh;
			background-color: #000;
			display: none;
			justify-content: center;
			align-items: center;
			z-index: var(--z-ExamineScreen);
			overflow: hidden;
			/* Hide scrollbars during panning */
			touch-action: none;
			/* Prevents browser interference on mobile */
		}

		#splash-img {
			max-width: 100%;
			max-height: 100%;
			width: 100vw;
			height: 100vh;
			height: 100dvh;
			object-fit: contain;
			transition: transform 0.1s ease-out;
			/* Smooths out the zoom/pan */
			cursor: grab;
			user-select: none;
			display: block;
			margin: 0;
		}

		#splash-img:active {
			cursor: grabbing;
		}

		/* Your existing trigger/corner buttons */
		.hover-trigger,
		#ghost-restore {
			z-index: var(--z-TransparentControls);
			!important;
			/* Always on top */
		}

		@keyframes zoomIn {
			from {
				transform: scale(0.5);
				opacity: 0;
			}

			to {
				transform: scale(1);
				opacity: 1;
			}
		}

		/* Update the CSS for your menu toggle buttons */
		#menu-toggle,
		.corner-button-id {
			z-index: var(--z-TransparentControls);
			/* One level higher than the splash screen */
			position: fixed;
			/* Ensures they stay pinned to the corner */
		}

		body:has(.card.is-active.pinned) .star-btn,
		body:has(.card.is-active.pinned) .pin-btn {
			color: var(--gold) !important;
			background: rgba(255, 215, 0, 0.1) !important;
			border-color: var(--gold) !important;
		}

		#multitrack {
			flex: 1;
			display: flex;
			overflow: hidden;
			order: 1;
			gap: 0px;

		}

		/* HORIZONTAL: Tracks are stacked vertically as Rows */
		#body-wrap:not(.max-width) #multitrack {
			flex-direction: column-reverse;
		}

		#body-wrap:not(.max-width) #track {
			flex-direction: row;
			height: 100%;
			/* Becomes 50% automatically if a second track is added */
			width: 100%;
			display: flex;
			align-items: center;
			overflow-x: auto;
			overflow-y: hidden;

		}

		/* VERTICAL: Tracks are placed side-by-side as Columns */
		#body-wrap.max-width #multitrack {
			flex-direction: row;
		}

		#body-wrap.max-width #track {
			flex-direction: column;
			width: 100%;
			/* Becomes 50% automatically if a second track is added */
			height: 100%;
			display: flex;
			align-items: center;
			overflow-y: auto;
			overflow-x: hidden;

		}

		/* Push the main content over when sidebar is visible */
		body:not(.collapsed) #multitrack {
			/*margin-left: var(--sidebar-w);*/
			transition: margin-left 0.3s ease;
		}

		body.collapsed #multitrack {
			margin-left: 0;
		}



		/* Optional: Make cards look "dangerous" or fragile when in removal mode */
		body.removal-mode .card:hover,
		body.removal-mode .file-item:hover {
			border-color: #ff4444;
			filter: sepia(1) saturate(2) hue-rotate(-50deg);
			outline: 3px solid #ff4444;
			cursor: pointer;
		}

		body.removal-mode #track:hover:not(:has(.card:hover)) {
			background: rgba(128, 0, 0, 0.5) !important;
			cursor: pointer;
		}



		.sidebar-inner {
			container-type: inline-size;
			container-name: sidebar-container;
			border-radius: 30px 30px 0px 0px;
			max-height: calc(100vh - 128px);
			max-height: calc(100dvh - 128px);
			min-height: 0;
			backdrop-filter: blur(10px);

			height: auto;
			/* New Flex Logic */
			display: flex;
			flex-direction: column;
			justify-content: flex-start;
			/* Pushes content to the bottom */

			overflow-y: hidden;
			/* Keeps it scrollable if content overflows */
			-webkit-overflow-scrolling: touch;
			/* Adds smooth momentum scrolling for mobile */
			opacity: 0;
			transition: opacity 0.5s ease 10s;
		}



		#sidebar {
			position: fixed;
			border-radius: 30px;
			bottom: 0;
			top: auto;
			width: var(--sidebar-w);
			max-height: 100vh;
			max-height: 100dvh;
			height: auto;
			background: transparent;
			backdrop-filter: none;


			z-index: var(--z-GUIControls);
			/* Below Splash, as requested earlier */

			/* New Flex Logic */
			display: flex;
			flex-direction: column;
			justify-content: flex-start;
			/* Pushes content to the bottom */

			overflow-y: auto;
			/* Keeps it scrollable if content overflows */
			-webkit-overflow-scrolling: touch;
			/* Adds smooth momentum scrolling for mobile */

			transition: background 0.5s ease 10s, backdrop-filter 0.5s ease 10s;
		}

		#sidebar:hover {
			/* When hovered, the background and blur return INSTANTLY */
			background: rgba(0, 0, 0, 0.0);
			backdrop-filter: none;
			transition: background 0.2s ease, backdrop-filter 0.2s ease;
		}

		/* 20251228: Tanya: Don't hide the upper panel, it blocks clicks. */
		#sidebar:hover:has(.sidebar-upper) {
			/*#sidebar:has(.sidebar-upper) {*/
			/* When hovered, the background and blur return INSTANTLY */
			background: var(--panel);
			backdrop-filter: blur(20px);
			transition: background 0.2s ease, backdrop-filter 0.2s ease;
		}


		#sidebar>*:not(.header-bar) {
			opacity: 1;
			/* Fade out after 3 seconds */
		}

		/* 20251228: Tanya: Don't hide the upper panel, it blocks clicks.*/
		#sidebar:not(:hover)>*:not(.header-bar) {
			opacity: 0.1;
			pointer-events: none;
			transition: opacity 0.5s ease 10s;
		}

		/* Ensure children don't stretch awkwardly */
		#sidebar>* {
			flex-shrink: 0;
		}

		/* Default Right Docked */
		body:not(.dock-left) #sidebar {
			right: 0;
			left: auto;
			order: 2;

		}

		/* Left Docked */
		body.dock-left #sidebar {
			left: 0;
			right: auto;
			order: 0;

		}

		/* Hidden States: Force the sidebar to the literal edges */
		body.collapsed:not(.dock-left) #sidebar {
			position: fixed;
			right: 0;
			top: 0;
			height: 100%;
			transform: translateX(100%);
		}

		body.collapsed.dock-left #sidebar {
			position: fixed;
			left: 0;
			top: 0;
			height: 100%;
			transform: translateX(-100%);
			/* Slides completely off-screen to the left */
		}

		/* Hidden States: No sliding, just fade out */
		body.collapsed #sidebar {
			opacity: 0;
			visibility: hidden;
			pointer-events: none;
			position: absolute;
			/* Take out of flow so #track expands instantly */
		}

		/* Visible States: Fade in */
		body:not(.collapsed) #sidebar {
			opacity: 1;
			visibility: visible;
			pointer-events: auto;
			position: fixed;
			/* Changed from relative */
			bottom: 0;
		}

		.control-panel-grid {
			display: grid;
			grid-template-columns: repeat(3, 1fr);
			gap: 8px;
			padding: 15px;
			border-top: 1px solid var(--border);
		}

		.sq-btn {
			aspect-ratio: 1 / 1;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 1.2rem;

			/* Normal state: semi-transparent */
			background: rgba(255, 255, 255, 0.5);
			border: 1px solid rgba(255, 255, 255, 0.1);
			color: rgba(255, 255, 255, 0.4);
			/* Dimmed text/icon */

			cursor: pointer;
			border-radius: 4px;
			transition: all 0.2s ease;
			/* Smooth fade effect */
		}


		.sq-btn:hover:not(.dim) {
			background: rgba(255, 255, 255, 0.15);
			border-color: rgba(255, 255, 255, 0.8);
			color: rgba(255, 255, 255, 1);
			/* Full white text/icon */
			box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
		}

		/* Special styling for the active mode toggle button */
		.sq-btn.active-gold {
			color: var(--gold);
			border-color: rgba(255, 215, 0, 0.3);
		}

		.sq-btn.active-gold:hover {
			border-color: var(--gold);
			color: var(--gold);
		}

		#toast {
			position: fixed;
			top: 20%;
			left: 50%;
			transform: translateX(-50%);
			background: rgba(255, 215, 0, 0.6);
			backdrop-filter: blur(8px);
			color: #000;
			padding: 10px 20px;
			border-radius: 8px;
			font-weight: bold;
			font-size: 16px;
			z-index: var(--z-Notifications);
			opacity: 0;
			transition: opacity 0.3s ease;
			pointer-events: none;
			border: 1px solid rgba(255, 255, 255, 0.2);
			text-align: center;
		}

		#toast.show {
			opacity: 1;
		}

		/* Hide the old ghost restore button */
		#ghost-restore {
			display: none !important;
		}

		/* New Hover-to-Show zones: Always on top */
		.hover-trigger {
			position: fixed;
			bottom: 0;
			/* Changed from top: 0 */
			width: 50px;
			height: 50px;
			z-index: var(--z-TransparentControls);
			display: flex;
			align-items: center;
			justify-content: center;
			background: rgba(255, 255, 255, 0.05);
			backdrop-filter: blur(5px);
			cursor: pointer;
			font-size: 20px;
			color: #fff;
			opacity: 0;
			transition: opacity 0.3s ease, background 0.2s;
			border: 1px solid var(--border);
		}

		.hover-trigger:hover {
			opacity: 1;
			background: rgba(255, 255, 255, 0.15);
		}

		#trigger-left {
			left: 0;
			border-radius: 0 15px 0 0;
			/* Adjusted for bottom left */
		}

		#trigger-right {
			right: 0;
			border-radius: 15px 0 0 0;
			/* Adjusted for bottom right */
		}

		/* Ensure triggers only appear when collapsed */
		body.collapsed .hover-trigger {
			display: flex;
		}

		body.dock-left #ghost-restore {
			right: auto;
			left: 15px;
		}

		body.collapsed #ghost-restore {
			display: flex;
		}

		#track {
			flex: 1;
			padding: 0px;
			display: flex;
			gap: 0px;
			/* Wider gap for cleaner storyboard look */
			transition: width 0.3s ease;
			height: 100vh;
			height: 100dvh;
			order: 1;
			flex-direction: var(--h-dir);

			/* align-items: center;
			justify-content:flex-start;*/

			justify-content: safe center;
			/* Test */
			width: 100%;
			/* Test */

			align-items: center;
			overflow-x: auto;
			overflow-y: hidden;
			flex-wrap: nowrap;


			scroll-behavior: smooth;
			/* Ensure the container transitions smoothly if padding changes */
			transition: padding 0.5s ease;
		}

		/* Ensure vertical mode keeps its original padding */
		body.max-width #track {

			padding-top: 5px;
			padding-bottom: 5px;
			/* Adds empty space at the bottom so the last card can scroll up to the middle */
			flex-direction: column;
			align-items: center;
			overflow-y: auto;
			overflow-x: hidden;
		}


		/* Add this to your <style> section */
		.settings-close {
			width: 24px !important;
			height: 24px !important;
			font-size: 14px !important;
			background: rgba(255, 255, 255, 0.05) !important;
			border-color: var(--border) !important;
		}

		.settings-close:hover {
			background: rgba(255, 50, 50, 0.2) !important;
			/* Subtle red hover for "close" */
			border-color: rgba(255, 50, 50, 0.5) !important;
		}

		.card {
			position: relative;
			border: 3px solid rgba(255, 255, 255, 0.2);
			border-radius: 14px;
			flex-shrink: 0;
			/* CHANGE: Uses 98% of the parent track's height instead of a fixed 98vh */
			height: 100%;
			overflow: hidden;
			background: transparent;
			transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
			animation: cardEntrance 0.6s cubic-bezier(0.23, 1, 0.32, 1) both;
			box-shadow: 0 1px 1px rgba(0, 0, 0, 0.5);
			display: inline-block;
		}

		.card img {
			height: 100%;
			width: auto;
			object-fit: contain;
			display: block;
		}


		/* The active/centered card style */
		.card.is-active {
			border-color: rgba(255, 215, 0, 0.6);
			/*Gold Color */
			box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
			transform: scale(1.02);
			z-index: var(--z-Gallery);
		}

		/* Keyframes for the new card appearing */
		@keyframes cardEntrance {
			0% {
				opacity: 0;
				transform: scale(0.8) translateY(20px);
				filter: blur(10px);
			}

			100% {
				opacity: 1;
				transform: scale(1) translateY(0);
				filter: blur(0);
			}
		}

		body.max-width .card {
			width: 98%;
			height: auto;
		}

		.card img {
			height: 100%;
			width: auto;
			object-fit: contain;
			display: block;
		}

		body.max-width .card img {
			width: 100%;
			height: auto;
		}



		.card.pinned::after {
			content: "";
			/* Empty content because we are using a background image */
			position: absolute;
			top: -4px;
			left: -4px;
			width: 36px;
			height: 36px;
			/* Using a data URI SVG so you don't need an external file */
			background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='-4 -4 30 30' fill='%23FFC700' stroke='rgba(255,255,255,0.5)' stroke-width='2' stroke-linejoin='round'%3E%3Cpath d='M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z'/%3E%3C/svg%3E");
			/*background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23FFD700'%3E%3Cpath d='M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z'/%3E%3C/svg%3E");*/
			background-size: contain;
			background-repeat: no-repeat;
			/* Optional: Add a subtle drop shadow to make it pop against card art */
			filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.5));
			pointer-events: none;
			/* Let clicks pass through the icon to the card */
			z-index: calc(var(--z-Gallery)+1);
			opacity: 0;
			transition: opacity 0.3s ease 10s;
		}

		/* Ensure the card is wide enough for a document */
		.card:has(embed),
		.card:has(iframe) {
			width: 100vw;
			/* Or 90vw for mobile responsiveness */
			height: 100%;
			display: flex;
			justify-content: center;
			align-items: stretch;
		}

		/* Force the embed to take all available space */
		embed {
			display: block;
			width: 100% !important;
			height: 100% !important;
		}

		/* When the track is vertical, ensure the PDF card spans more height */
		.max-width #track .card:has(embed),
		.max-width #track .card:has(iframe) {
			height: 100vh !important;
			/* Spans 80% of the screen height */
			width: 100%;
			/* Takes full width of the vertical track */
			max-width: none;
			min-height: none;
			/* Ensures it's never too 'flat' to read */
		}

		/* Ensure the embed fills the newly sized card */
		.card embed,
		.card iframe {
			width: 100%;
			height: 100%;
			object-fit: contain;
		}

		body:has(#sidebar:hover) .card.pinned::after {
			opacity: 1;
			transition: opacity 0.3s ease;
		}

		.tool-btn {
			background: rgba(0, 0, 0, 0.1);
			color: rgba(255, 255, 255, 0.1);
			border: 1px solid rgba(255, 255, 255, 0.1);
			width: 36px;
			height: 36px;
			cursor: pointer;
			border-radius: 8px;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 16px;
			text-decoration: none;
		}

		.tool-btn.half {
			width: 54px;
			height: 54px;
		}

		.tool-btn.large {
			width: 72px;
			height: 72px;
		}

		.tool-btn.full {
			width: 108px;
			height: 108px;
		}

		.tool-btn:hover {
			border: 1px solid rgba(255, 255, 255, 0.8);
			color: rgba(255, 255, 255, 0.8);
		}

		.import-btn {
			background: var(--gold);
			color: #000;
			border: none;
			padding: 8px;
			border-radius: 4px;
			cursor: pointer;
			font-family: monospace;
			font-weight: bold;
			width: 100%;
		}

		.css-grid {
			width: 14px;
			height: 14px;
			display: grid;
			grid-template-columns: 1fr 1fr;
			grid-template-rows: 1fr 1fr;
			gap: 2px;
		}

		.css-grid div {
			border: 1.5px solid currentColor;
			border-radius: 1px;
		}

		.css-list {
			width: 14px;
			height: 14px;
			display: flex;
			flex-direction: column;
			justify-content: space-between;
			padding: 1px 0;
		}

		.css-list div {
			height: 2px;
			background: currentColor;
			width: 100%;
			border-radius: 1px;
		}

		.css-mag {
			width: 14px;
			height: 14px;
			border: 2px solid currentColor;
			border-radius: 50%;
			position: relative;
		}

		.css-mag::after {
			content: "";
			position: absolute;
			top: 11px;
			left: 11px;
			width: 6px;
			height: 2px;
			background: currentColor;
			transform: rotate(45deg);
			transform-origin: top left;
		}

		.css-wall {
			width: 12px;
			height: 12px;
			border: 2px solid currentColor;
			border-radius: 50% 50% 50% 0;
			transform: rotate(-45deg);
			position: relative;
			top: -2px;
		}

		.header-bar {
			background-color: transparent;
			padding: 0px;
			transition: background-color 0.3s ease;
			flex-shrink: 0;
			/* Smooth fade effect */
		}

		.header-bar:hover {
			backdrop-filter: none;
		}


		.btn-group {
			display: flex;
			gap: 8px;
			/* Slightly wider gap for better touch/click targets */
			justify-content: center;
			/* Centers the buttons horizontally */
			width: 100%;
		}

		/* Ensure buttons within the group don't stretch */
		.btn-group .sq-btn {
			flex: 0 0 auto;
		}

		.grid-container {
			display: grid;
			/* This tells the grid: "Make as many columns as fit, 
       with a minimum width of 100px and a maximum of 1fr" */
			grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
			gap: 10px;
			padding: 10px;
			width: 100%;
		}

		.sq-btn {
			background: rgba(255, 255, 255, 0.5);
			border: none;
			width: 40px;
			height: 40px;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 18px;
			color: #000 !important;
			border-radius: 8px;
			flex-shrink: 0;
			transition: all 0.2s;
			text-decoration: none;
		}

		.sq-btn.dim {
			background: rgba(255, 255, 255, 0.25);
			color: rgba(0, 0, 0, 0) !important;
			transition: background 0.5s ease 10s, color 0.5s ease 10s;
		}

		#sidebar:hover .sq-btn.dim {
			background: rgba(255, 255, 255, 0.5);
			color: rgba(0, 0, 0, 0.75) !important;
			transition: background 0.5s ease, color 0.5s ease;
		}




		.sq-btn.active-gold {
			background: var(--gold);
			color: #000 !important;
		}

		/* Centers the wallpaper icon inside the sidebar square button */
		.sq-btn .css-wall {
			margin: 0 auto;
			transform: rotate(-45deg) scale(1.2);
			/* Slightly larger for the sidebar */
		}

		.active-preview-container {
			display: flex;
			align-items: center;
			gap: 0px;
			padding: 0px;
			/*background: rgba(255, 255, 255, 0.05);*/
			border-radius: 8px;
			border: 1px solid rgba(255, 255, 255, 0.1);
		}

		#active-preview-thumb {
			width: 32px;
			height: 32px;
			object-fit: cover;
			border-radius: 4px;
			/*border: 1px solid #ffd700;*/
			/* A little gold border to match the star theme */
			box-shadow: 0 0 5px rgba(255, 215, 0, 0.3);
		}

		#active-preview-label {
			font-size: 0.8rem;
			color: #ccc;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			max-width: 120px;
		}

		.tabs-contents {
			display: block;
			/* Ensure it's a block container */
			max-height: 30vh;
			/* The limit */
			overflow-y: auto;
			/* Enable vertical scroll */
			overflow-x: hidden;
			/* Prevent horizontal shifting */
			box-sizing: border-box;
			/* CRITICAL: Includes padding in the 30vh calculation */
			padding-bottom: 10px;
			/* Gives the inputs some breathing room at the bottom */
		}

		/* Width of the scrollbar */
		.tabs-contents::-webkit-scrollbar {
			width: 6px;
		}

		/* The background track */
		.tabs-contents::-webkit-scrollbar-track {
			background: transparent;
		}

		/* The actual draggable handle */
		.tabs-contents::-webkit-scrollbar-thumb {
			background-color: rgba(155, 155, 155, 0.5);
			/* Semi-transparent grey */
			border-radius: 10px;
			/* Rounded edges */
		}

		/* Handle on hover */
		.tabs-contents::-webkit-scrollbar-thumb:hover {
			background-color: rgba(155, 155, 155, 0.8);
		}

		/* For Firefox support */
		.tabs-contents {
			scrollbar-width: thin;
			scrollbar-color: rgba(155, 155, 155, 0.5) transparent;
		}

		#command-panel {
			position: fixed;
			/* Changed from absolute */
			bottom: 0px;
			/* Distance from bottom of screen */
			left: 50%;
			transform: translateX(-50%);

			width: 100vw;
			/* You can now make it wider than the sidebar */
			max-height: 40vh;
			max-width: 792px;


			background: rgba(0, 0, 0, 0.4);
			backdrop-filter: blur(20px);
			border: 2px solid rgba(255, 255, 255, 0.4);
			border-radius: 15px;
			padding: 10px;

			z-index: var(--z-GUIControls);
			/* Keeps it above the sidebar */

			flex-direction: column;
			gap: 15px;
			box-shadow: 0 10px 10px rgba(0, 0, 0, 0.8);
			font-size: 1.5em;
		}

		/* Custom Scrollbar Styling */
		#command-panel textarea::-webkit-scrollbar {
			width: 6px;
			/* Very thin */
		}

		#command-panel textarea::-webkit-scrollbar-track {
			background: transparent;
			/* Makes the track invisible */
		}

		#command-panel textarea::-webkit-scrollbar-thumb {
			background: rgba(255, 255, 255, 0.2);
			/* Subtle white thumb */
			border-radius: 10px;
		}

		#command-panel textarea::-webkit-scrollbar-thumb:hover {
			background: var(--gold);
			/* Highlights gold on hover to match your UI */
		}

		/* For Firefox */
		#command-panel textarea {
			scrollbar-width: thin;
			scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
		}


		.unified-width {
			width: 100%;
			background: rgba(255, 255, 255, 0.0);
			color: #fff;
			border: 1px solid var(--border);
			font-family: monospace;
			outline: none;
			border-radius: 6px;
			padding: 8px;
		}

		.tag-cloud {
			display: flex;
			flex-wrap: wrap;
			gap: 4px;
			padding: 5px 15px;
			max-height: 25vh;
			overflow-y: auto;
		}

		.tag-pill {
			background: rgba(0, 0, 0, 0.5);
			color: var(--text-dim);
			padding: 4px 8px;
			border: 1px solid var(--border);
			font-size: 10px;
			cursor: pointer;
			border-radius: 4px;
		}

		.tag-pill.active {
			background: var(--accent);
			color: #000 !important;
		}

		.tag-count-small {
			opacity: 0.5;
			font-size: 9px;
		}

		.action-btn {
			background: rgba(255, 255, 255, 0.1) !important;
			color: var(--text-dim) !important;
			border: 1px solid var(--border) !important;
			opacity: 0.7;
		}

		.action-btn:hover {
			background: rgba(255, 255, 255, 0.2) !important;
			color: #fff !important;
			opacity: 1;
		}

		/* Current State: Solid/Bright */
		.state-active {
			background: var(--accent) !important;
			color: #000 !important;
			opacity: 1 !important;
		}

		.stats-bar {
			display: flex;
			align-items: center;
			justify-content: space-between;
			padding: 8px 15px;
			background: rgba(0, 0, 0, 0.3);
			border-bottom: 1px solid var(--border);
			font-size: 14px;
		}

		.stats-clickable {
			cursor: pointer;
			white-space: nowrap;
			/* Prevents text from wrapping */
			flex-shrink: 0;
			/* Prevents the label from being squashed */
			width: fit-content;
			/* Only takes the space of the words */
		}

		.stats-clickable:hover {
			color: #fff;
		}

		/* Centering logic for Tags Bar */
		.stats-bar.tags-bar {
			display: flex;
			align-items: center;
			gap: 10px;
			padding: 8px 15px;
		}

		.stats-bar-spacer {
			width: 32px;
			flex-shrink: 0;
		}

		.version-code {
			font-size: 9px;
			color: var(--text-dim);
			opacity: 0.6;
			font-family: monospace;
			flex-grow: 1;
			text-align: center;
		}




		/* Matches Sort button width */
		.tags-bar-center {
			display: flex;
			align-items: center;
			justify-content: center;
			flex-grow: 1;
			gap: 8px;
			overflow: hidden;
		}

		.inline-toggle {
			background: transparent;
			border: 1px solid var(--border);
			color: var(--text-dim);
			cursor: pointer;
			border-radius: 4px;
			padding: 4px 6px;
			display: flex;
			align-items: center;
			transition: all 0.2s;
			font-size: 10px;
			min-width: 32px;
			justify-content: center;
		}

		.inline-toggle:hover {
			border-color: var(--accent);
			color: #fff;
		}


		/* Ensure the image container grows to fill all vertical space */
		#collapsible-images {
			flex: 1;
			display: flex;
			/* Default to flex so it fills space */
			flex-direction: column;
			overflow: hidden;
			min-height: 0;
			background: rgba(0, 0, 0, 0.2);
		}

		#file-list {
			flex: 1;
			overflow-y: auto;
			width: 100%;
			min-height: 0;
		}


		.button-grid {
			/* Optional: visual separator */
			display: grid !important;
			gap: 2px;
			grid-template-columns: repeat(7, 1fr);
			/* 6 buttons per row */
			height: auto;
			padding: 2px 2px;
			width: 100%;
		}

		#collapsible-collections {
			display: flex;

			gap: 8px;
			flex-direction: column;
			border-bottom: 1px solid var(--border);
			background: rgba(0, 0, 0, 0.2);
		}

		#master-search {
			flex: 1;
			/* This makes the search box grow to fill all available space */
			min-width: 50px;
			/* Prevents it from disappearing on tiny screens */
			text-align: center;
			background: rgba(255, 255, 255, 0.05);
			border: 1px solid var(--border);
			color: #fff;
			border-radius: 6px;
			padding: 6px;
			outline: none;
			transition: border-color 0.2s;
		}

		#master-search:focus {
			border-color: var(--accent);
		}

		/* Ensure the label and button don't shrink */
		.tags-bar .stats-clickable,
		#tag-sort-btn {
			flex-shrink: 0;
		}

		/* Collection Path List Styles */
		#path-list-container {
			display: flex;
			flex-direction: column;
			gap: 4px;
			margin-top: 5px;
			max-height: 150px;
			overflow-y: auto;
			padding-right: 4px;
		}

		.path-entry {
			display: flex;
			align-items: center;
			gap: 6px;
			background: rgba(255, 255, 255, 0.05);
			padding: 4px;
			border-radius: 4px;
		}

		.path-entry input[type="text"] {
			flex: 1;
			background: transparent;
			border: none;
			color: var(--text-dim);
			font-size: 9px;
			pointer-events: none;
		}

		.path-entry input[type="checkbox"] {
			cursor: pointer;
			width: 16px;
			height: 16px;
			accent-color: var(--gold);
		}

		.path-entry.stale input[type="checkbox"] {
			accent-color: var(--gold);
		}

		.path-entry.loaded input[type="checkbox"] {
			accent-color: var(--green);
		}

		.path-text {
			flex: 1;
			background: transparent;
			border: none;
			color: var(--text-dim);
			font-size: 10px;
			cursor: pointer;
			/* Updated for full path visibility */
			word-break: break-all;
			/* Breaks long strings like URLs */
			white-space: normal;
			/* Allows wrapping to new lines */
			line-height: 1.2;
			padding: 2px 0;
		}

		.path-entry {
			display: flex;
			align-items: flex-start;
			/* Align checkbox/trash to the top of wrapped text */
			gap: 6px;
			background: rgba(255, 255, 255, 0.05);
			padding: 6px;
			border-radius: 4px;
			margin-bottom: 2px;
		}

		.path-text:hover {
			color: #fff;
			text-decoration: underline;
		}

		.trash-btn {
			background: transparent;
			border: none;
			color: #ff4444;
			cursor: pointer;
			font-size: 12px;
			padding: 2px 6px;
			opacity: 0.7;
		}

		.trash-btn:hover {
			opacity: 1;
		}

		.file-list {
			flex: 1;
			overflow-y: auto;
		}

		.grid-view {
			display: grid !important;
			grid-template-columns: repeat(var(--grid-cols), 1fr) !important;
			grid-auto-rows: min-content;
			gap: 6px;
			padding: 8px;
		}

		.grid-view .file-item {
			padding: 0;
			border: 1px solid var(--border);
			aspect-ratio: 1/1;
			border-radius: 6px;
			position: relative;
			overflow: hidden;
			display: block;
		}

		.grid-view .file-item img {
			width: 100%;
			height: 100%;
			object-fit: cover;
			position: absolute;
			top: 0;
			left: 0;
		}

		.grid-view .active-item {
			border: 5px solid var(--gold) !important;
			z-index: var(--z-Listings);
			transform: scale(1.02);
		}

		.file-item {
			padding: 10px 15px;
			border-bottom: 1px solid rgba(255, 255, 255, 0.05);
			font-size: 11px;
			cursor: pointer;
			color: var(--text-dim);
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
			transition: all 0.2s ease;
		}

		.file-item.active-item {
			color: var(--gold) !important;
			font-weight: bold;
			background: rgba(255, 215, 0, 0.15) !important;
			/* Visible highlight */
		}

		.grid-view .file-item.active-item {
			border: 3px solid var(--gold) !important;
			transform: scale(1.05);
			z-index: var(--z-Listings);
			background: transparent !important;
			/* Hide list bg in grid mode */
		}

		.active-item {
			color: var(--gold) !important;
			font-weight: bold;
			background: rgba(255, 215, 0, 0.1);
		}

		.card-tag-overlay {
			display: none;
			/* Controlled by toggleOverlay */
			position: absolute;
			top: 55px;
			/* Positions it just below the card-tools buttons */
			right: 15px;
			width: 200px;
			/* Constrains the width to a small side frame */
			max-height: 70%;
			flex-wrap: wrap;
			gap: 5px;
			padding: 10px;
			background: rgba(0, 0, 0, 0.85);
			border: 1px solid var(--border);
			border-radius: 8px;
			z-index: var(--z-Gallery);
			/* Above the image but below main sidebar */
			overflow-y: auto;
			backdrop-filter: blur(10px);

		}

		#grid-slider-container {
			display: none;
			/* JavaScript toggles this to 'flex' */
			align-items: center;
			margin-left: 15px;
			/* Space after "Images" text */
			margin-right: 15px;
			/* Space before the grid button */
			flex: 1;
			/* Fills the entire gap */
			min-width: 0;
		}

		#col-slider {
			-webkit-appearance: none;
			width: 100%;
			/* Slider stretches to fill the whole container */
			height: 4px;
			background: var(--border);
			border-radius: 2px;
			outline: none;
			cursor: pointer;
			accent-color: var(--accent);
			padding: 0px;
		}

		#grid-toggle-btn {
			flex-shrink: 0;
			/* Keeps the button square and fixed to the right */
		}

		#col-slider::-webkit-slider-thumb {
			-webkit-appearance: none;
			width: 12px;
			height: 12px;
			background: var(--accent);
			border-radius: 50%;
			cursor: pointer;
		}


		#remove-mode-btn,
		#auto-flush-btn,
		.dimmer {
			opacity: 0;
			transition: opacity 0.3s ease 10s;
		}

		#remove-mode-btn:hover,
		#auto-flush-btn:hover,
		#sidebar:hover .active-gold,
		.dimmer:hover {
			opacity: 1;
			transition: opacity 0.5s ease;
		}

		#remove-mode-btn.removal-active {
			opacity: 1;
			background: darkred !important;
			color: white !important;
			border-color: darkred !important;
			box-shadow: 0 0 15px rgba(255, 0, 0, 0.4);
		}

		.sq-btn.dimmer {
			background: rgba(0, 0, 0, 0.0);
			color: var(--text-dim) !important;
		}



		/* The main container for the icon */
		.floppy-icon {
			position: relative;
			width: 20px;
			height: 20px;
			background-color: currentColor;
			/* Matches the text color of the button */
			border-radius: 2px 4px 2px 2px;
			/* The top-right is slightly more rounded/clipped */
			display: inline-block;
			vertical-align: middle;
		}

		/* The Metal Shutter (Top part) */
		.floppy-icon::before {
			content: '';
			position: absolute;
			top: 2px;
			left: 4px;
			width: 10px;
			height: 6px;
			background-color: var(--bg, #000);
			/* Uses your app's background color */
			border-radius: 1px;
		}

		/* The Label (Bottom part) */
		.floppy-icon::after {
			content: '';
			position: absolute;
			bottom: 2px;
			left: 3px;
			right: 3px;
			height: 8px;
			background-color: rgba(255, 255, 255, 0.8);
			border-radius: 1px;
		}

		/* Center the character containers perfectly */
		.icon-h,
		.icon-v {
			display: flex;
			align-items: center;
			justify-content: center;
			width: 24px;
			/* Fixed width to prevent shifting */
			height: 24px;
			/* Fixed height to prevent shifting */
			font-size: 24px;
			font-weight: bold;
			color: #fff;
			line-height: 0;
			/* Strips font-specific vertical padding */
			pointer-events: none;
			user-select: none;
			margin: 0 auto;
			/* Centers the div within the square button */
		}

		/* Horizontal Dash centering */
		.icon-h::before {
			content: '—';
			transform: translateY(-2px);
			/* Corrects the typical 'sink' of a dash */
		}

		/* Vertical Pipe centering */
		.icon-v::before {
			content: '|';
			transform: translateX(0);
			/* Ensure no horizontal bias */
		}

		/* Hover Preview Logic: Ensure previews use the same offsets as active states */
		#mode-toggle:hover .icon-h::before {

			opacity: 0.7;
			transform: translateY(0);
			/* Remove the dash-specific vertical shift */
		}

		#mode-toggle:hover .icon-v::before {

			opacity: 0.7;
			transform: translateY(-2px);
			/* Apply the dash-specific vertical shift */
		}


		/* CSS Star Icon */
		/* Perfect 5-Point Star using Clip-Path */
		.icon-star {
			width: 20px;
			height: 20px;
			background: currentColor;
			clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
		}

		.icon-star::after {
			content: "";
			position: absolute;
			top: 6px;
			left: -10px;
			border-left: 10px solid transparent;
			border-right: 10px solid transparent;
			border-top: 18px solid currentColor;
		}

		/* When the card is pinned, turn the star button gold and solid */
		.card.pinned .pin-btn {
			color: var(--gold) !important;
			background: rgba(0, 0, 0, 0.4);
			/* Slightly darker background to pop the gold */
			border-color: var(--gold);
		}

		/* Ensure that when NOT pinned, the star stays semi-transparent even on the 'centered' card */
		.pin-btn {
			color: rgba(255, 255, 255, 0.1) !important;
		}

		/* Hovering over the star should still make it visible */
		.pin-btn:hover {
			color: rgba(255, 255, 255, 0.8) !important;
		}



		/* Simple Perfect Circle Icon */
		.icon-circle {
			width: 14px;
			height: 14px;
			border: 2px solid currentColor;
			/* Matches the button's text color */
			border-radius: 50%;
			display: inline-block;
			background: transparent;
			/* Hollow circle */
		}

		/* Optional: Solid circle on hover */
		.action-btn:hover .icon-circle {
			background: currentColor;
		}
	</style>
</head>

<body id="body-wrap" contenteditable="false">
	<div id="multitrack">
		<div id="track"></div>
	</div>


	<div id="sidebar">
		<div id="collapsible-collections">
			<div class="stats-bar">
				<div class="stats-clickable" onclick="toggleCollections(event)">Collections (<span
						id="collection-count">0</span>)
				</div>
				<a href="https://magicbakery.github.io/?id=P202512210026" target="_blank" rel="noopener noreferrer"
					class="bakery-link" id="version-link">ⓘ</a>
			</div>
			<div style="padding:0px 5px">
				<input type="file" id="json-input" style="display:none" accept=".json" onchange="importJSON(this)">
				<div style="display:flex; gap:4px;">
					<input type="file" id="mobile-file-input" style="display:none" accept="image/*">
					<button class="import-btn action-btn" style="width: 32px;" onclick="smartImport()">+</button>
					<button class="import-btn action-btn" style="flex: 1;" onclick="exportFilteredData('path')"
						title="Export Path">PATH</button>
					<button class="import-btn action-btn" style="flex: 1;" onclick="exportFilteredData('base64')"
						title="Export Base64">BASE64</button>
					<button class="import-btn action-btn" style="flex: 1;" onclick="exportMultiTrack()"
						title="Export or Import Multitrack DOM">DOM</button>
					<button class="import-btn action-btn" style="flex: 1;" onclick="exportGallery()"
						title="Export HTML">HTML</button>
				</div>
				<div id="path-list-container"></div>
			</div>
		</div>
		<div id="collapsible-tags" class="sidebar-upper">
			<div class="stats-bar tags-bar">
				<span class="stats-clickable" onclick="toggleTagCloud(event)">Tags (<span id="tag-count">0</span>)</span>
				<input type="text" id="master-search" class="unified-width" style="width:100px; text-align:center"
					placeholder="SEARCH..." oninput="refreshAllUI()">
				<button class="inline-toggle" id="tag-sort-btn" onclick="toggleTagSort()">A-Z</button>
			</div>


			<div id="tag-cloud" class="tag-cloud"></div>
		</div>
		<div id="collapsible-images" class="sidebar-upper"
			style="flex: 1; display: flex; flex-direction: column; overflow: hidden; background: rgba(0,0,0,0.2);">
			<div class="stats-bar">
				<div class="stats-clickable" onclick="toggleImages(event)">Images (<span id="img-count">0</span>)</div>
				<div id="grid-slider-container">
					<input type="range" id="col-slider" min="1" max="5" value="3" oninput="updateGridCols(this.value)">
				</div>
				<button class="inline-toggle" id="grid-toggle-btn" onclick="toggleSidebarView()">
					<div class="css-grid" id="toggle-icon">
						<div></div>
						<div></div>
						<div></div>
						<div></div>
					</div>
				</button>
			</div>
			<div id="file-list" class="file-list"></div>
		</div>
		<div class="header-bar">
			<div id="button-palette" style="display:block;"><!--@@Stage-->
				<div class="button-grid">
					<button class="sq-btn dimmer star-btn" onclick="togglePinActiveCard(event)" title="Star Active Card">
						<svg viewBox="0 0 24 24" width="36" height="36" fill="currentColor" stroke="currentColor" stroke-width="2"
							stroke-linejoin="round">
							<path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z" />
						</svg>
					</button>
					<!--Collections Button-->
					<button class="sq-btn dimmer" onclick="toggleCollections(event)" title="Collections">
						<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
							stroke-linecap="round" stroke-linejoin="round">
							<rect x="7" y="7" width="14" height="14" rx="2" ry="2"></rect>
							<path d="M3 15v-8c0-1.1.9-2 2-2h8"></path>
						</svg>
					</button>

					<!--Save button-->
					<!--
					<button class="sq-btn dim" onclick="memDOM()" title="Save Changes">
						<svg viewBox="0 0 100 100" style="width:90%; height:90%;">
							<path d="M20,15 H70 L85,30 V85 H20 Z" fill="none" stroke="currentColor" stroke-width="6" />

							<rect x="35" y="15" width="30" height="25" fill="none" stroke="currentColor" stroke-width="4" />

							<rect x="30" y="55" width="40" height="30" fill="none" stroke="currentColor" stroke-width="4" />
							<rect x="55" y="60" width="10" height="20" fill="currentColor" />
						</svg>

					</button>-->
					<!--Remove Track Button ◸-->
					<button class="sq-btn dimmer" onclick="removeTrackRelative(event,+1)" title="Remove Track Above/Left">
						<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
							<path d="M100,50 L50,50 L50,100 Z" fill="none" stroke="currentColor" stroke-width="6" />
						</svg>
					</button>
					<!--UP BUTTON-->
					<button class="sq-btn dim" onclick="moveActiveCard(event, 'up')" title="Move Up">
						<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
							<polygon points="10,80 50,10 90,80" fill="currentColor" />
						</svg>
					</button>
					<!--Add Track Button ◥-->
					<button class="sq-btn dimmer" onclick="addTrackRelative(event,+1)" title="Add Track Above/Right">
						<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
							<polygon points="50,100 50,50 0,50" fill="currentColor" />
						</svg>
					</button>



					<button class="sq-btn dimmer"></button>
					<button class="sq-btn dimmer" onclick="createCard()" title="Random Draw">
						<svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
							<path d="M12 3L19 7L12 11L5 7L12 3Z" fill="currentColor" fill-opacity="0.3" stroke="currentColor"
								stroke-width="1.5" stroke-linejoin="round" />
							<path d="M12 11L19 7V15L12 19V11Z" fill="currentColor" fill-opacity="0.1" stroke="currentColor"
								stroke-width="1.5" stroke-linejoin="round" />
							<path d="M5 7L12 11V19L5 15V7Z" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round" />
							<circle cx="12" cy="7" r="1" fill="currentColor" />
							<circle cx="7" cy="11" r="1" fill="currentColor" />
							<circle cx="10" cy="15" r="1" fill="currentColor" />
							<circle cx="14" cy="15" r="1" fill="currentColor" />
							<circle cx="15.5" cy="13" r="1" fill="currentColor" />
							<circle cx="17" cy="11" r="1" fill="currentColor" />
						</svg>
					</button>

					<!--Auto Flush Mode Button ↻-->
					<button id="auto-flush-btn" class="sq-btn action-btn" onclick="toggleAutoFlush(event)">
						<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
							<path d="M75,30 C65,15 35,15 25,30 M25,70 C35,85 65,85 75,70" fill="none" stroke="currentColor"
								stroke-width="8" stroke-linecap="round" />
							<polygon points="70,12 88,28 68,40" fill="currentColor" />
							<polygon points="30,88 12,72 32,60" fill="currentColor" />
						</svg>
					</button>
					<!--Tags Button-->
					<button class="sq-btn dimmer " onclick="toggleTagCloud(event)" title="Tags">
						<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
							stroke-linecap="round" stroke-linejoin="round">
							<line x1="4" y1="9" x2="20" y2="9"></line>
							<line x1="4" y1="15" x2="20" y2="15"></line>
							<line x1="10" y1="3" x2="8" y2="21"></line>
							<line x1="16" y1="3" x2="14" y2="21"></line>
						</svg>
					</button>


					<!--LEFT BUTTON-->
					<button class="sq-btn dim" onclick="moveActiveCard(event,'left')" title="Move Left">
						<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
							<polygon points="80,10 10,50 80,90" fill="currentColor" />
						</svg>
					</button>
					<!--Scroll Orientation Button-->
					<button id="mode-toggle" class="sq-btn dimmer" onclick="toggleScrollMode(event)" title="Scroll Direction">
						<div class="icon-h"></div>
					</button>
					<!--RIGHT BUTTON-->
					<button class="sq-btn dim" onclick="moveActiveCard(event,'right')" title="Move Right">
						<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
							<polygon points="20,10 90,50 20,90" fill="currentColor" />
						</svg>
					</button>
					<!--Set Wallpaper Button-->
					<button class="sq-btn dimmer" onclick="setCenteredAsWallpaper(event)" title="Set Active Card as Wallpaper">
						<svg viewBox="0 0 100 100" class="icon-svg">

							<rect x="15" y="20" width="70" height="60" rx="5" fill="none" stroke="currentColor" stroke-width="6" />
							<path d="M15,70 L35,45 L55,70 L70,55 L85,75" stroke="currentColor" stroke-width="6" stroke-linecap="round"
								fill="none" stroke-linejoin="round" />
							<circle cx="65" cy="40" r="6" fill="currentColor" />
						</svg>
						<!--<div class="css-wall"></div>-->
					</button>
					<!--Remove Mode Button-->
					<button id="remove-mode-btn" class="sq-btn action-btn" onclick="toggleRemovalMode(this)"
						ondblclick="clearWorkspace(event)" title="Toggle Removal Mode">
						<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
							<path d="M20,20 L80,80 M80,20 L20,80" fill="none" stroke="currentColor" stroke-width="8" />
						</svg>
					</button>
					<!--Clear Workspace-->
					<!--<button class="sq-btn dim" onclick="clearWorkspace(event)">CW</button>-->
					<!--Show/Hide Custom Buttons-->
					<button class="sq-btn dimmer" onclick="toggleAllBlockByID(event,'custom-buttons')"
						title="Toggle custom buttons"></button>
					<!--Listing Button-->
					<button class="sq-btn dimmer" onclick="toggleImages(event)" title="Listing">
						<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<rect x="3" y="3" width="7" height="7"></rect>
							<rect x="14" y="3" width="7" height="7"></rect>
							<rect x="14" y="14" width="7" height="7"></rect>
							<rect x="3" y="14" width="7" height="7"></rect>
						</svg>
					</button>
					<!--Add Track Button ◣-->
					<button class="sq-btn dimmer" onclick="addTrackRelative(event,-1)" title="Add Track Below/Left">
						<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
							<polygon points="50,0 50,50 100,50" fill="currentColor" />
						</svg>
					</button>
					<!--DOWN BUTTON-->
					<button class="sq-btn dim" onclick="moveActiveCard(event,'down')" title="Move Down">
						<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
							<polygon points="10,20 50,90 90,20" fill="currentColor" />
						</svg>
					</button>
					<!--Remove Track Button ◿-->
					<button class="sq-btn dimmer" onclick="removeTrackRelative(event,-1)" title="Add Track Below/Right">
						<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
							<path d="M50,0 L50,50 L0,50 Z" fill="none" stroke="currentColor" stroke-width="6" />
						</svg>
					</button>
					<!--NOTES BUTTON-->
					<button class="sq-btn dimmer" id="settings-btn" onclick="toggleCommandPanel(event)">
						<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
							<rect x="20" y="15" width="60" height="70" rx="5" fill="none" stroke="currentColor" stroke-width="6" />

							<line x1="35" y1="35" x2="65" y2="35" stroke="currentColor" stroke-width="6" stroke-linecap="round" />
							<line x1="35" y1="50" x2="65" y2="50" stroke="currentColor" stroke-width="6" stroke-linecap="round" />
							<line x1="35" y1="65" x2="55" y2="65" stroke="currentColor" stroke-width="6" stroke-linecap="round" />
						</svg>
					</button>

					<!--Show/Hide Custom Buttons-->
					<button class="sq-btn dimmer" onclick="toggleAllBlockByID(event,'custom-buttons')"
						title="Toggle custom buttons"></button>
				</div>
			</div>
			<div id="custom-buttons" style="display:none;">
				<div class="button-grid">
					<button class="sq-btn dimmer" onclick="toggleAllBlockByID(event,'button-palette')"
						title="Toggle Button Grid"></button>
					<button class="sq-btn dimmer">A</button>
					<button class="sq-btn dimmer">B</button>
					<button class="sq-btn dimmer">C</button>
					<button class="sq-btn dimmer">D</button>
					<button class="sq-btn dimmer">E</button>
					<button class="sq-btn dimmer" onclick="toggleAllBlockByID(event,'button-palette')"
						title="Toggle Button Pallete"></button>
				</div>
			</div>
		</div>
	</div>
	<div id="command-panel" style="display: none;">
		<!--Float Right Elements-->
		<button class="tool-btn settings-close" onclick="toggleCommandPanel(event)" style="float:right">×</button>
		<a class="tool-btn" target="_blank" title="Log Bugs" style="float: right;height:24px;width:24px;margin-right:5px"
			href="https://docs.google.com/forms/d/e/1FAIpQLSeOpcxl7lS3R84J0P3cYZEbkRapkrcpTrRAtWA8HCiOTl6nTw/viewform">
			<svg viewBox="-3 -3 30 30" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
				stroke-linejoin="round">
				<path d="M4 4h16c1.1 0 2 0.9 2 2v12c0 1.1-0.9 2-2 2H4c-1.1 0-2-0.9-2-2V6c0-1.1 0.9-2 2-2z"></path>
				<polyline points="22,6 12,13 2,6"></polyline>
			</svg>
		</a>
		<a href="https://magicbakery.github.io/?id=P202512210026" target="_blank" rel="noopener noreferrer"
			class="tool-btn bakery-link" style="float: right;height:24px;width:24px;margin-right:5px" title="Visit Homepage">
			<svg viewBox="-3 -3 30 30" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
				stroke-linejoin="round">
				<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
				<polyline points="9 22 9 12 15 12 15 22"></polyline>
			</svg>
		</a>

		<div class="panel-tabs">
			<div class="active-preview-container">
				<img id="active-preview-thumb" class="save-notes-btn" src="" alt="" style="display: none;"
					onclick="saveCardNotes(event)" title="Save changes to this card">
				<button class="tab-btn" onclick="toggleTab(event,'tab-card-notes')" title="Details">
					<svg width="24" height="18" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="2"
						stroke-linecap="round">
						<line x1="3" y1="6" x2="21" y2="6"></line>
						<line x1="3" y1="12" x2="15" y2="12"></line>
						<line x1="3" y1="18" x2="11" y2="18"></line>
					</svg>
				</button>


				<!--<button class="tab-btn save-notes-btn" onclick="saveCardNotes(event)" title="Save">
					<svg viewBox="0 0 100 100" style="width:16px; height:16px;">
					<path d="M20,15 H70 L85,30 V85 H20 Z" fill="none" stroke="currentColor" stroke-width="6" />

					<rect x="35" y="15" width="30" height="25" fill="none" stroke="currentColor" stroke-width="4" />

					<rect x="30" y="55" width="40" height="30" fill="none" stroke="currentColor" stroke-width="4" />
					<rect x="55" y="60" width="10" height="20" fill="currentColor" />
				</svg>
				</button>-->
			</div>
			<!--<button class="tab-btn" onclick="toggleTab(event,'tab-card-tags')">Tags</button>-->
			<button class="tab-btn" onclick="toggleTab(event,'tab-controls')" title="Controls">
				<svg width="24" height="18" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"
					style="transform: scale(1.4);">
					<path d="M12 9.5L9 6.5V3H15V6.5L12 9.5Z" stroke="currentColor" stroke-width="1" stroke-linejoin="round" />
					<path d="M12 14.5L15 17.5V21H9V17.5L12 14.5Z" stroke="currentColor" stroke-width="1"
						stroke-linejoin="round" />
					<path d="M9.5 12L6.5 15H3V9H6.5L9.5 12Z" stroke="currentColor" stroke-width="1" stroke-linejoin="round" />
					<path d="M14.5 12L17.5 9H21V15H17.5L14.5 12Z" stroke="currentColor" stroke-width="1"
						stroke-linejoin="round" />
				</svg>
			</button>
			<button class="tab-btn" onclick="toggleTab(event,'tab-dev-notes')">
				<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
					stroke-linecap="round" stroke-linejoin="round">
					<path d="M12 3v3m0 12v3M5.3 5.3l2.1 2.1m9.2 9.2l2.1 2.1M3 12h3m12 0h3m-15.7 6.7l2.1-2.1m9.2-9.2l2.1-2.1"
						opacity="0.5" />
					<path d="M12 8l-1 4-4 1 4 1 1 4 1-4 4-1-4-1-1-4z" />
				</svg>
			</button>
		</div>
		<div class="tabs-contents">

			<div id="tab-card-notes" style="padding-bottom:40px">
				<div id="card-tag-list" class="tag-cloud" style="padding:5px 0px"></div>
				<input type="text" id="assign-tag-input" placeholder="Add Tag" oninput="updateAssignmentUI()"
					onkeydown="handleTagKey(event)">

				<input type="text" id="card-title" placeholder="Title" title="Title (n)">
				<textarea id="card-notes" class="" oninput="markDirty(this)"
					style="resize:none;height:180px; margin-bottom:5px;font-size:16px;overflow-y: auto;"
					placeholder="Notes"></textarea>
				<input type="text" id="edit-img-path" placeholder="Cover Image" title="Cover Image (i)">
				<input type="text" id="edit-url-path" placeholder="Jump URL" title="Path/URL (p)">

			</div>
			<div id="tab-card-tags" class="tab-content" style="display:none">



			</div>
			<div id="tab-controls" class="tab-content" style="display:none">

				<div style="display:flex;">
					<div class="button-pad left"
						style="flex:1;display:flex;flex-wrap:wrap-reverse;justify-content: flex-start;flex-direction:column;height:108px;overflow-x:auto;box-sizing: content-box;align-items: flex-end;align-content: flex-start;scrollbar-width: none; -ms-overflow-style: none;">
						<button class="tool-btn full">L1</button>
						<button class="tool-btn half">L2</button>
						<button class="tool-btn half">L3</button>
						<button class="tool-btn half">L4</button>
						<button class="tool-btn half">L5</button>
						<button class="tool-btn">L6</button>
						<button class="tool-btn">L7</button>
						<button class="tool-btn">L8</button>
						<button class="tool-btn">L9</button>
						<button class="tool-btn">L10</button>
						<button class="tool-btn">L11</button>
						<button class="tool-btn">L12</button>
						<button class="tool-btn">L13</button>
						<button class="tool-btn">L14</button>
						<button class="tool-btn half">L15</button>
						<button class="tool-btn half">L16</button>
						<button class="tool-btn half">L17</button>
						<button class="tool-btn half">L18</button>
						<button class="tool-btn full">L19</button>
					</div>
					<div style="display:flex;flex-wrap:wrap;flex:0 0 auto;justify-content: center;width:120px;height:108px;">
						<!--Remove Track Button ◸-->
						<button class="tool-btn" onclick="removeTrackRelative(event,+1)" title="Remove Track Above/Left">
							<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
								<path d="M100,50 L50,50 L50,100 Z" fill="none" stroke="currentColor" stroke-width="6" />
							</svg>
						</button>
						<!--UP BUTTON-->
						<button class="tool-btn" onclick="moveActiveCard(event, 'up')" title="Move Up">
							<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
								<polygon points="10,80 50,10 90,80" fill="white" />
							</svg>
						</button>
						<!--Add Track Button ◥-->
						<button class="tool-btn" onclick="addTrackRelative(event,+1)" title="Add Track Above/Right">
							<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
								<polygon points="50,100 50,50 0,50" fill="currentColor" />
							</svg>
						</button>
						<div style="flex-basis:100%;height:0"></div>
						<!--LEFT BUTTON-->
						<button class="tool-btn" onclick="moveActiveCard(event,'left')" title="Move Left">
							<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
								<polygon points="80,10 10,50 80,90" fill="white" />
							</svg>
						</button>
						<!--Scroll Orientation Button-->
						<button id="mode-toggle" class="tool-btn" onclick="toggleScrollMode(event)" title="Scroll Direction">
							<div class="icon-h"></div>
						</button>
						<!--RIGHT BUTTON-->
						<button class="tool-btn" onclick="moveActiveCard(event,'right')" title="Move Right">
							<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
								<polygon points="20,10 90,50 20,90" fill="white" />
							</svg>
						</button>
						<div style="flex-basis:100%;height:0"></div>
						<!--Add Track Button ◣-->
						<button class="tool-btn" onclick="addTrackRelative(event,-1)" title="Add Track Below/Left">
							<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
								<polygon points="50,0 50,50 100,50" fill="currentColor" />
							</svg>
						</button>
						<!--DOWN BUTTON-->
						<button class="tool-btn" onclick="moveActiveCard(event,'down')" title="Move Down">
							<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
								<polygon points="10,20 50,90 90,20" fill="white" />
							</svg>
						</button>
						<!--Remove Track Button ◿-->
						<button class="tool-btn" onclick="removeTrackRelative(event,-1)" title="Add Track Below/Right">
							<svg viewBox="0 0 100 100" style="width: 80%; height: 80%;">
								<path d="M50,0 L50,50 L0,50 Z" fill="none" stroke="currentColor" stroke-width="6" />
							</svg>
						</button>
					</div>
					<div class="button-pad right"
						style="flex:1;display:flex;flex-wrap:wrap;justify-content: center;flex-direction:column;height:108px;overflow-x:auto;box-sizing: content-box;align-items: flex-start; scrollbar-width: none; -ms-overflow-style: none;align-content: flex-start">
						<button class="tool-btn full">R1</button>
						<button class="tool-btn half">R2</button>
						<button class="tool-btn half">R3</button>
						<button class="tool-btn half">R4</button>
						<button class="tool-btn half">R5</button>
						<button class="tool-btn">R6</button>
						<button class="tool-btn">R7</button>
						<button class="tool-btn">R8</button>
						<button class="tool-btn">R9</button>
						<button class="tool-btn">R10</button>
						<button class="tool-btn">R11</button>
						<button class="tool-btn">R12</button>
						<button class="tool-btn">R13</button>
						<button class="tool-btn">R14</button>
						<button class="tool-btn half">R15</button>
						<button class="tool-btn half">R16</button>
						<button class="tool-btn half">R17</button>
						<button class="tool-btn half">R18</button>
						<button class="tool-btn full">R19</button>
					</div>
				</div>




			</div>
			<div id="tab-dev-notes" style="display:none;padding-bottom:40px">
				<div style="display:flex; gap:5px; align-items:center;">
					<a id="add-btn" href="#" target="_blank" class="sq-btn action-btn" onclick="handleLinkAction(event)">+</a>
					<input type="text" id="add-url-input" class="unified-width" placeholder="URL for + button..."
						oninput="updateAddUrl(this.value)">

				</div>

				<textarea id="user-note" class="unified-width"
					style="resize:none;height:180px; margin-bottom:5px;font-size:16px;overflow-y: auto;" placeholder="NOTES..."
					oninput="saveNotes(this.value)"></textarea>
			</div>

		</div>





	</div>
	<div id="splash-screen" onclick="if(event.target === this) hideSplash()">
		<img id="splash-img" src="" alt="Enlarged View">
	</div>
	<!--
	<div class="bottom-menu-container" id="bottom-nav">
		<button class="semi-circle-btn" onclick="toggleBottomMenu(event)" title="Show Action Bar">
			<div class="menu-icon-graphic">
				<span></span><span></span><span></span>
			</div>
		</button>
	</div>
	<div id="bottom-menu-items" class="bottom-menu-panel">		
		<button class="sq-btn dim" onclick="toggleRemovalMode(this)" title="Removal Mode">✕</button>	
		<button id="mode-toggle" class="sq-btn active-gold" onclick="toggleScrollMode()" title="Scroll Wheel Direction">
					<div class="icon-h"></div>
				</button>	
		<button class="sq-btn dim" onclick="toggleBottomMenu(event)" title="Close Action Bar"><div class="menu-icon-graphic">
				<span></span><span></span><span></span>
			</div></button> 
		<button class="sq-btn dim" style="margin:-30px 0px 30px 0px" onclick="" title="">&#9664;</button>
		<button class="sq-btn dim" onclick="" title=""></button>	
	</div>-->
	<!--Transparent Buttons-->

	<div id="loading-screen" onclick="fadeLoadingScreen(false)"></div>
	<div id="trigger-left" class="hover-trigger" onclick="handleCornerClick('left')">☰</div>
	<div id="trigger-right" class="hover-trigger" onclick="handleCornerClick('right')">☰</div>
	<div id="ghost-restore" onclick="toggleSidebar(true)">☰</div>
	<div id="custom-confirm" class="modal-overlay" style="display:none;">
		<div class="modal-content">
			<p id="confirm-text" style="color: white; margin-bottom: 20px;"></p>
			<div class="modal-btns">
				<button id="btn-no" onclick="confirmChoice(false)" class="confirm-no">No</button>
				&nbsp;&nbsp;&nbsp;
				<button id="btn-yes" onclick="confirmChoice(true)" class="confirm-yes">Yes</button>
			</div>
		</div>
	</div>
	<div id="toast"></div>
	<script>
		let DATA = [];
		let ALL_TAGS = [];
		let activeTags = new Set(), sidebarIsGrid = false, currentDock = 'right', autoFlush = false;
		let tagSortMode = 'alpha', savedPaths = [];

		window.onload = () => {
			initZLayers();

			// Inject the version code into the info link tooltip
			document.getElementById('version-link').title = "Ver." + APP_VERSION;

			// 1. Tag Sort Initialization (Future State)
			tagSortMode = localStorage.getItem('gallery_tag_sort') || 'alpha';
			const tagBtn = document.getElementById('tag-sort-btn');
			tagBtn.innerText = (tagSortMode === 'alpha') ? '1-9' : 'A-Z';
			tagBtn.className = 'inline-toggle action-btn';

			// 2. View Mode Initialization (Future State / Reversed)
			const savedMax = localStorage.getItem('gallery_is_max_width') === 'true';
			const bodyWrap = document.getElementById('body-wrap');
			const btn = document.getElementById('mode-toggle');

			if (savedMax) {
				bodyWrap.classList.add('max-width');
				if (btn) btn.innerHTML = '<div class="icon-v"></div>';
			} else {
				bodyWrap.classList.remove('max-width');
				if (btn) btn.innerHTML = '<div class="icon-h"></div>';
			}

			persistentWallpaper();
			initScrollDirection();

			// 3. Restore Sidebar Docking
			currentDock = localStorage.getItem('gallery_dock') || 'right';
			updateDock(currentDock);

			// 4. Restore Settings & Notes
			const n = localStorage.getItem('gallery_notes');
			if (n) document.getElementById('user-note').value = n;

			autoFlush = localStorage.getItem('gallery_flush') === 'true';
			updateAutoFlushUI();



			// Restore Grid Columns
			const savedCols = localStorage.getItem('gallery_cols') || 3;
			document.documentElement.style.setProperty('--grid-cols', savedCols);
			document.getElementById('col-slider').value = savedCols;



			// Set initial slider visibility
			const container = document.getElementById('grid-slider-container');
			const icon = document.getElementById('toggle-icon');

			if (sidebarIsGrid) {
				container.style.display = 'flex';
				icon.className = 'css-list';
				icon.innerHTML = '<div></div><div></div><div></div>';
			} else {
				container.style.display = 'none';
				icon.className = 'css-grid';
				icon.innerHTML = '<div></div><div></div><div></div><div></div>';
			}


			const savedAddUrl = localStorage.getItem('gallery_add_url');
			if (savedAddUrl) {
				document.getElementById('add-url-input').value = savedAddUrl;
				document.getElementById('add-btn').href = savedAddUrl;
			}

			// Restore or initialize Collections
			const rawPaths = localStorage.getItem('gallery_paths');
			if (rawPaths) {
				savedPaths = JSON.parse(rawPaths).map(p => ({ ...p, data: null }));
			} else {
				// DEFAULT PATH: Starter Pack
				savedPaths = [{
					path: "https://magicbakery.github.io/starterpack.json",
					checked: true,
					data: null
				}];
			}

			renderPathList();
			// Load data for all checked paths
			savedPaths.forEach((item, index) => {
				if (item.checked && (item.path.startsWith('http'))) {
					importFromURL(item.path);
				}
			});

			// STEP: Content ready to be shown			
			summonFairyQueen();
			summonGateGuardian();
		};
		/* #ALPHABETICALLY SORTED CODE */
		const zLayers = ['Notifications', 'LoadingScreen', 'TransparentControls', 'ExamineScreen', 'GUIControls', 'Listings', 'Gallery', 'AppWallpaper'];
		let isRemovalMode = false; /* 20251226: StarTree: Used for the Removal button */
		let resolveConfirm = null;


		function exportMultiTrack() {
			// 20260104: Sasha: Export MultiTrack if it is not empty. If it is empty, import.
			const multiTrackDOM = document.getElementById('multitrack'); // Adjust ID to match your container
			if (!multiTrackDOM) {
				showToast("Error: MultiTrack container not found.");
				return;
			}
			const tracks = multiTrackDOM.querySelectorAll("#track");
			if (tracks.length <= 1 && tracks[0].innerHTML == "") {
				// The Multitrack section is empty. Switch to Import.
				importMultiTrackDOM();
				return;
			}



			const blob = new Blob([multiTrackDOM.outerHTML], { type: 'text/html' });
			const a = document.createElement('a');
			a.href = URL.createObjectURL(blob);
			a.download = `MultiTrack_${new Date().toISOString().slice(0, 10)}.dom`;

			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);

			showToast("MultiTrack HTML exported!");
		}
		function fadeLoadingScreen(bIn) {
			// 20251225: Tanya: Remove the loading screen after z-index are initialized.
			// 20251225: StarTree: bIn = false means fade out
			const curtain = document.getElementById('loading-screen');
			if (!curtain) return;
			if (bIn) {
				curtain.style.visibility = 'visible';
				curtain.style.display = "flex";
				curtain.style.opacity = '1';
			} else {
				curtain.style.visibility = 'hidden';
				curtain.style.opacity = '0';
				// Wait for the transition to finish (time defined in CSS)
				// then remove it from the layout entirely
				setTimeout(() => { curtain.style.display = 'none'; }, 800);
			}
		}
		function fairyActiveCardCheck(e) {
			// 20251226: StarTree: Set the card to be the active card if it is in multi track mode.
			// 20260108: LRRH: Clicking on a tag toggles it.
			const tagPill = e.target.closest('.tag-pill');
			if (tagPill) {
				e.stopPropagation();
				const t = tagPill.firstChild.textContent.trim();
				toggleTag(t);
				return true;
			}

			const file = e.target.closest('.file-item');
			if (file) {
				e.stopPropagation();
				const path = file.dataset.path;
				const item = DATA.find(i => i.p === path);
				if (item) {
					createCard(item);
				}
				return true;
			}

			const card = e.target.closest('.card');
			if (!card) return false;
			e.stopPropagation();
			if (getActiveCard() == card && isHidden("command-panel")) {
				toggleCommandPanel(e);
			}


			setActiveCard(card);

			return true;
		}
		async function fairyBlessCheck(e) {
			const tag = document.getElementById('assign-tag-input').value.trim().toUpperCase();
			if (tag == "") { return false; }
			const file = e.target.closest('.file-item');
			const card = e.target.closest('.card');
			const track = e.target.closest('#track');

			// 1. Click on File in Sidebar
			if (file) {
				e.stopPropagation();
				const item = DATA.find(i => i.p === file.dataset.path);
				if (item && !item.t.includes(tag)) {
					item.t.push(tag);
					showToast(`Added [${tag}] to ${item.n}`);
					refreshAllUI();
				}
				return true;
			}

			// 2. Click on Card in Track
			if (card) {
				e.stopPropagation();
				const item = DATA.find(i => i.p === card.dataset.path);
				if (item && !item.t.includes(tag)) {
					item.t.push(tag);
					showToast(`Added [${tag}] to card`);
					refreshAllUI();
				}
				return true;
			}

			// 3. Click on Track (Background)
			if (track) {
				e.stopPropagation();
				const cards = Array.from(track.querySelectorAll('.card'));
				if (cards.length > 0) {
					const count = cards.length;
					if (await showConfirm(`Add tag [${tag}] to all ${count} cards in this track?`)) {
						cards.forEach(c => {
							const item = DATA.find(i => i.p === c.dataset.path);
							if (item && !item.t.includes(tag)) item.t.push(tag);
						});
						showToast(`Tagged track with [${tag}]`);
						refreshAllUI();
					}
				}
				return true;
			}

			return false;
		}
		async function fairyRemovalCheck(e) {
			// 20251226: StarTree: Handle element removal
			// Returns true if the click is processed.
			if (!isRemovalMode) return false;
			const tagPill = e.target.closest('.tag-pill');
			if (tagPill) {
				e.stopPropagation();
				const t = tagPill.firstChild.textContent.trim();

				// 1. Check if it's in the Command Panel (Card Tags)
				if (e.target.closest('#card-tag-list')) {
					const activeCardData = getActiveCardData();
					if (activeCardData && activeCardData.t) {
						activeCardData.t = activeCardData.t.filter(tag => tag !== t);
						showToast(`Removed ${t} from current card`);
					}
				}
				// 2. Otherwise, assume it's in the Sidebar Tag Cloud
				else if (e.target.closest('#tag-cloud')) {
					const targetFiles = getFilteredData();
					// Find the count span inside the clicked tag-pill
					const countSpan = tagPill.querySelector('.tag-count-small');
					const displayCount = countSpan ? countSpan.textContent : targetFiles.length;
					if (await showConfirm(`Remove tag "${t}" from the ${displayCount} currently shown?`)) {
						targetFiles.forEach(item => {
							item.t = item.t.filter(tag => tag !== t);
						});
						// If the tag being removed was an active filter, clear it
						activeTags.delete(t);
						showToast(`Bulk removed tag: ${t}`);
					}
				}

				refreshAllUI();
				renderCardTags(); // Sync the command panel
				memDOM();
				return true;
			}

			const card = e.target.closest('.card');
			const track = e.target.closest('#track');
			const file = e.target.closest('.file-item');

			if (file) {
				e.stopPropagation();
				const pathToRemove = file.dataset.path;

				// If it's a blob, tell the browser to release the memory
				if (pathToRemove.startsWith('blob:')) {
					URL.revokeObjectURL(pathToRemove);
				}

				// 1. Remove from the master DATA array
				DATA = DATA.filter(item => item.p !== pathToRemove);

				// 2. Also remove it from the [Orphan Files] in savedPaths so it stays gone
				savedPaths.forEach(entry => {
					if (entry.data) {
						entry.data = entry.data.filter(item => item.p !== pathToRemove);
					}
				});

				// 3. Visual feedback & Save
				file.style.opacity = "0";
				file.style.transform = "translateX(-20px)";

				setTimeout(() => {
					refreshAllUI(); // Rebuilds the list without the deleted item
					memDOM();       // Persists the change to localStorage
				}, 200);
				return true;
			}
			if (card) {
				e.stopPropagation();
				if (card.classList.contains('pinned')) {
					if (await showConfirm("This card has a ⭐. Keep it?")) { return true; }
				}
				// Perform the removal
				card.style.transform = "scale(0.8) translateY(20px)";
				card.style.opacity = "0";
				setTimeout(() => {
					card.remove();
					refreshAllUI(); // Update your "Stage (X)" count in the sidebar
					memDOM();   // Ensure the deletion is saved to localStorage
				}, 300);
				return true;
			}
			if (track) {
				removeTrack(track);
				return true;
			}
			return false;
		}

		function getFullResURL(url) {
			// 20260110: Sasha: Given the url, get the full resolution URL.
			const substackRegex = /https:\/\/substackcdn\.com\/image\/fetch\/.*?\/(https%3A%2F%2Fsubstack-post-media\.s3\.amazonaws\.com%2F[^\s"']+)/;
			const match = url.match(substackRegex);
			return match ? decodeURIComponent(match[1]) : url;
		}
		function getImageURL(item) {
			// 20260103: Lei: Returns the image path for thumbnail when the item is not an image file.
			// Priority 1: If the item has an image, use it.
			if (item.i && item.i.trim() !== "") return item.i;

			// Priority 2: If the item has a path that is an image, use it.
			// Check if the path is a Base64 image string

			if (item.p) {
				if (typeof item.p === 'string' && item.p.startsWith('data:image/')) {
					return item.p; // Return as-is, browser can render this
				}
				// 2. Handle Mobile Blob URLs (Always images in our use case)
				if (typeof item.p === 'string' && item.p.startsWith('blob:')) {
					return item.p;
				}
				const cleanPath = item.p.trim();
				const parts = cleanPath.split('.');
				if (parts.length > 1) {
					const extension = parts.pop().toLowerCase();
					const imageExtensions = ['jpg', 'jpeg', 'png', 'webp', 'gif', 'svg', 'avif', 'url'];
					if (imageExtensions.includes(extension)) {
						return cleanPath;
					}
				}
			}
			const fileName = item.n;
			if (fileName.trim() == "") {
				fileName = cleanPath.split(/[/\\]/).pop().split(/[?#]/)[0];
			}
			return `https://placehold.co/400x400/000/FFF?text=${encodeURIComponent(fileName || 'FILE')}`;
		}
		function getThumbnailURL(url, res = 256) {
			// 20260110: Sash: Return the thumbnail image URL if it is from substack.
			if (url.includes("substackcdn.com")) {
				// This regex finds "w_" followed by any digits and replaces it with the new res
				const resRegex = /w_\d+/;
				return url.replace(resRegex, `w_${res}`);
			}
			return url;
		}
		function getURL(item) {
			// 20260106: Skyle: Returns the URL for a data entry.
			// 20260110: Sasha: If the path link is a substack proxy compression link, return the link to the full image.
			if (item.p) { return getFullResURL(item.p); }
			if (item.i) { return getFullResURL(item.i); }
			return "";
		}
		async function importMultiTrackDOM() {
			// 1. Create a hidden file input to trigger the dialog
			const fileInput = document.createElement('input');
			fileInput.type = 'file';
			fileInput.accept = '.DOM, .html, .txt'; // Accept your custom extension

			fileInput.onchange = async (e) => {
				const file = e.target.files[0];
				if (!file) return;

				const reader = new FileReader();
				reader.onload = (event) => {
					const fileContent = event.target.result;
					const parser = new DOMParser();
					const doc = parser.parseFromString(fileContent, 'text/html');
					const importedSection = doc.getElementById('multitrack');

					if (importedSection) {
						const mainContainer = document.getElementById('multitrack');

						// 3. Replace the live container's content with the imported content
						mainContainer.innerHTML = importedSection.innerHTML;

						showToast("MultiTrack section restored from file.");

						// 4. Update memory and UI
						if (typeof memDOM === 'function') memDOM();
						updateAllCardOverlays(); // Re-sync any visual states
					} else {
						showToast("Could not find the [multi-track-container] in that file.");
					}
				};

				reader.readAsText(file);
			};

			fileInput.click();
		}
		function initZLayers() {
			// 20251225: Tanya: Enumerate the layers by code.
			const root = document.documentElement;
			let zi = (zLayers.length) * 10;
			zLayers.forEach(layer => {
				root.style.setProperty(`--z-${layer}`, zi);
				zi -= 10;
			});
		}
		function isHidden(elID) {
			const el = document.getElementById(elID);
			return window.getComputedStyle(el).display === 'none';
		}
		function isMobile() {
			const isSmallScreen = window.innerWidth <= 768;
			return isSmallScreen;						
			const userAgent = navigator.userAgent || navigator.vendor || window.opera;
			const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
			

			// Check for specific mobile strings in User Agent
			const isMobileUA = /android|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());

			//return isMobileUA || isTouch;
			
		}
		function memDOM(isLoad, aID) {
			// 20251226: StarTree: For a quick way to save the workspace, save the html of the multitrack section to local storage
			// .. isLoad = true means loading to the page. 
			// .. isLoad = false means saving to local storage.

			if (!aID) {
				// if aID is not defined, save everything.
				memDOM(isLoad, "multitrack");
				return;
			}
			const mSection = document.getElementById(aID);
			if (isLoad) {
				const mSavedHTML = localStorage.getItem(aID + '_snapshot');
				if (!mSavedHTML) { return; }
				mSection.innerHTML = mSavedHTML;
			} else {
				localStorage.setItem(aID + '_snapshot', mSection.innerHTML);
				localStorage.setItem(aID + '_snapshot_version', APP_VERSION);
			}
		}
		function renderCardTags() {
			const container = document.getElementById('card-tag-list');
			if (!container) return;
			container.innerHTML = "";
			const card = document.querySelector(".card.is-active");
			if (!card) { return; }
			const path = card.dataset.path;
			const item = DATA.find(i => i.p === path);
			if (!item) return;

			[...item.t].sort().forEach(tag => {
				const p = document.createElement('div');
				const isActive = activeTags.has(tag);
				p.className = 'tag-pill' + (isActive ? ' active' : '');
				p.dataset.tag = tag;
				p.innerText = tag;
				container.appendChild(p);
			});

			/*
			activeCardData.t.forEach(tag => {
				const p = document.createElement('div');

				// Use the exact same class logic as your sidebar pills
				const isActive = activeTags.has(tag);
				p.className = 'tag-pill' + (isActive ? ' active' : '');
				p.innerText = tag;

				p.onclick = () => {
					// Mirror logic: toggle the global activeTags Set
					if (activeTags.has(tag)) {
						activeTags.delete(tag);
					} else {
						activeTags.add(tag);
					}

					// Refresh EVERYTHING to keep sidebar and command panel in sync
					refreshAllUI();
					renderCardTags();
				};

				container.appendChild(p);
			});*/
		}
		function saveCardNotes(e) {
			// 20251230: Cardinal
			e.stopPropagation();
			const activeCard = document.querySelector(".card.is-active");
			if (!activeCard) { return; }
			const textArea = document.getElementById("card-notes");
			activeCard.dataset.notes = encodeURIComponent(textArea.value);
			textArea.dataset.notes = activeCard.dataset.notes
			activeCard.classList.add("pinned");
			textArea.classList.remove("is-dirty");
			saveMetadata();
			memDOM();
		}
		function saveMetadata() {
			activeCardData = getActiveCardData();
			if (!activeCardData) return;
			activeCardData.i = document.getElementById('edit-img-path').value.trim();
			activeCardData.n = document.getElementById('card-title').value.trim();
			activeCardData.o = encodeURIComponent(document.getElementById('card-notes').value);
			activeCardData.p = document.getElementById('edit-url-path').value.trim();

			// Update the visual card immediately if the image changed
			const card = document.querySelector(`.card[data-path="${CSS.escape(activeCardData.p)}"]`);
			const cardThumbnail = document.getElementById('active-preview-thumb');
			cardThumbnail.src = getImageURL(activeCardData);
			if (card) {
				const img = card.querySelector('img');
				if (img) img.src = cardThumbnail.src;
			}
			// Persist to localStorage (see point 3 below)
		}
		function setActiveCard(card) {
			if (!card) return;
			// 20260108: LRRH: Remove the active attribute from all cards then set this card to be active
			document.querySelectorAll('.card').forEach(card => card.classList.remove('is-active'));
			card.classList.add('is-active');

			const activeCard = getActiveCardData();
			document.getElementById("edit-img-path").value = activeCard.i || "";
			document.getElementById("card-title").value = activeCard.n || "";
			document.getElementById("edit-url-path").value = activeCard.p || "";

			const cardNotes = document.getElementById("card-notes");

			if ('notes' in card.dataset) {
				cardNotes.dataset.notes = card.dataset.notes;
			} else {
				cardNotes.dataset.notes = activeCard.o || "";
			}
			cardNotes.value = decodeURIComponent(cardNotes.dataset.notes || "");
			renderCardTags();

			// Mirror Thumbnail.
			const mirrorImg = document.getElementById('active-preview-thumb');
			//const mirrorLabel = document.getElementById('active-preview-label');
			const cardImg = card.querySelector('img');
			const cardName = card.querySelector('.card-title')?.innerText || "Active Card";
			if (cardImg && mirrorImg) {
				mirrorImg.src = cardImg.src;
				mirrorImg.style.display = "block";
				//mirrorLabel.innerText = cardName;
			}
			// Mirror 
			memDOM();
		}
		function summonGateGuardian() {
			// 20251225: LRRH, StarTree: On mobile it is too easy to accidentally refresh the page and lose the arrangement.
			if (true) {
				// 20251226: LRRH: After implementing auto save, this doesn't seem necessary.
				// 20251226: Cardinal: Need this if the user loads local collections.
				window.addEventListener('beforeunload', (event) => {
					event.preventDefault();
					//fadeLoadingScreen(true);
					event.returnValue = '';
				});
			}
			// 20251228: Cardinal: Multi-tap storage sync
			window.addEventListener('storage', (event) => {
				if (event.key === 'multitrack_snapshot') {
					// NOTE: the listening cannot run a confirm and would skip it.
					memDOM(true);
					showToast("✨ Workspace synced from another tab");
				}
			});

			// 20251226: LRRH: There might need to be a check or a greeting before removing the loading screen.
			memDOM(true);
			fadeLoadingScreen(false);
		}
		function summonFairyQueen() {
			// 20251226: StarTree: This is supposed to handle all clicks on staging areas.
			document.addEventListener('click', async (e) => {
				if (await fairyRemovalCheck(e)) { return; }
				if (await fairyBlessCheck(e)) { return; }
				fairyActiveCardCheck(e);
			});
			// 20251226: StarTree: Double Click
			document.addEventListener('dblclick', (e) => {
				showSplash(e);
			});
			// 20260110: Sasha: Resizing the main area when the command-panel is shown.
			const cp = document.getElementById('command-panel');
			new ResizeObserver(() => {
				if (!isMobile()) { return; }
				const multitrack = document.getElementById('multitrack');
				const sidebar = document.getElementById('sidebar');
				if (multitrack) {
					multitrack.style.paddingBottom = `${cp.offsetHeight}px`;
				}
				if (sidebar) {
					sidebar.style.paddingBottom = `${cp.offsetHeight}px`;
				}
			}).observe(cp);

		}
		function toggleAllBlockByID(e, aID) {
			// 20251227: Black: Consolidating the toggle code.
			e.stopPropagation();
			const blocks = document.querySelectorAll("#" + aID);
			blocks.forEach(block => {
				if (block.style.display == "block") {
					block.style.display = "none";
				} else {
					block.style.display = "block";
				}
			});
		}
		function toggleBottomMenu(e) {
			if (e) e.stopPropagation(); // Prevents the 'click outside' from firing instantly

			const container = document.getElementById('bottom-nav');
			const panel = document.getElementById('bottom-menu-items');

			const isOpening = !panel.classList.contains('active');

			if (isOpening) {
				panel.classList.add('active');
				container.classList.add('active-state');
			} else {
				// This part handles clicking the semi-circle while it's already open
				panel.classList.remove('active');
				container.classList.remove('active-state');
			}
		}
		function togglePinActiveCard(e) {
			e.stopPropagation();
			// 1. Find the active card. 
			// This assumes you add an 'active' class when hovering or clicking.
			const activeCard = document.querySelector('.card.is-active');
			if (activeCard) {
				// 2. Toggle the 'pinned' class
				const isPinned = activeCard.classList.toggle('pinned');
				// 3. Optional: Provide haptic/visual feedback or save state				
				// If you use your memDOM function, save the change:
				if (typeof memDOM === "function") {
					memDOM(false, "multitrack");
				}
			} else {
				console.warn("No active card found to pin.");
			}
		}
		function toggleRemovalMode(btn) {
			// 20251226: StarTree, Gemini
			isRemovalMode = !isRemovalMode;
			// Toggle visual state of the button
			btn.classList.toggle('removal-active', isRemovalMode);
			// Toggle a class on the body so CSS can change card appearances
			document.body.classList.toggle('removal-mode', isRemovalMode);
			showToast(isRemovalMode ? "REMOVAL MODE: ON" : "REMOVAL MODE: OFF");
		}
		function toggleTab(e, aID) {
			// 20251230: Cardinal: A generic reusable function to show one tab and hide the rest.
			e.stopPropagation();
			const targetTab = document.getElementById(aID);
			if (!targetTab) return;
			const tabFrame = targetTab.parentElement;
			Array.from(tabFrame.children).forEach(child => {
				child.style.display = 'none';
				child.classList.remove('active-tab-content');
			});
			targetTab.style.display = 'block';
			targetTab.classList.add('active-tab-content');
		}



		/* UNSORTED CODE */
		function markDirty(elThis) {
			// 20251230: Cardinal
			const savedValue = elThis.dataset.notes || "";
			const currentValue = encodeURIComponent(elThis.value || "");
			if (savedValue !== currentValue) {
				elThis.classList.add('is-dirty');
			} else {
				elThis.classList.remove('is-dirty');
			}
		}
		function showConfirm(message) {
			const modal = document.getElementById('custom-confirm');
			const text = modal.querySelector('#confirm-text');
			const btnYes = document.getElementById('btn-yes');
			const btnNo = document.getElementById('btn-no');
			text.innerText = message;
			modal.style.display = 'flex';
			return new Promise((resolve) => {
				resolveConfirm = resolve;
			});
		}
		function confirmChoice(choice) {
			const modal = document.getElementById('custom-confirm');
			if (modal) modal.style.display = 'none';
			// Only resolve if we have a pending promise
			if (resolveConfirm) {
				resolveConfirm(choice);
				resolveConfirm = null; // Reset it so it can't be clicked twice
			}
		}
		// HOW TO USE IT IN YOUR STORAGE LISTENER:
		window.addEventListener('storage', async (event) => {
			if (event.key === 'multitrack_snapshot') {
				const userSaidYes = await showConfirm("Another tab has updated local storage. Sync with those changes?"); // Pauses here for the user!
				if (userSaidYes) {
					memDOM(true, "multitrack");
				}
			}
		});
		function addTrackRelative(e, direction) {
			e.stopPropagation();
			const multitrack = document.getElementById('multitrack');
			const activeCard = document.querySelector('.card.is-active');

			// 1. Identify the reference track
			// If no card is active, we default to the first track or create one if none exist
			let referenceTrack = activeCard ? activeCard.closest('#track') : multitrack.querySelector('#track');

			if (!referenceTrack) {
				// Fallback: If no tracks exist at all, just use babyStep
				babyStepAddTrack();
				return;
			}

			// 2. Create the new track element
			const newTrack = document.createElement('div');
			newTrack.id = 'track'; // Keeping ID consistent with your CSS selectors

			// Add the scroll listener so theater-mode centering works on the new track
			//newTrack.addEventListener('scroll', updateCenteredCard);

			// 3. Insert relative to the reference
			if (direction === -1) {
				// Insert BEFORE (Above in Horizontal / Left in Vertical)
				referenceTrack.insertAdjacentElement('beforebegin', newTrack);
				showToast("Track Added Below/Left");
			} else {
				// Insert AFTER (Below in Horizontal / Right in Vertical)
				referenceTrack.insertAdjacentElement('afterend', newTrack);
				showToast("Track Added Above/Right");
			}

			// 4. Update UI to reflect the new layout
			updateAllCardOverlays();
			memDOM();
		}

		/**
		 * Complementary function for the '-' buttons in your staging panel
		 */
		async function removeTrack(targetTrack) {
			// Keep the last track.
			if (!(targetTrack.closest('#multitrack').querySelectorAll('#track').length > 1)) {
				showToast("The last track cannot be deleted.")
				return;
			}
			if (targetTrack && targetTrack.id === 'track') {
				let cardsCount = targetTrack.querySelectorAll(".card").length;
				if (cardsCount > 0) {
					if (await showConfirm("The target track is not empty. Keep it?")) { return; }
				}
				let starsCount = targetTrack.querySelectorAll(".card.pinned").length;
				if (starsCount == 0 || !await showConfirm("The target track has ⭐ cards. Keep them?")) {
					targetTrack.remove();
					showToast("Track Removed");
					memDOM();
					return;
				}
				targetTrack.querySelectorAll(".card:not(.pinned)").forEach(card => {
					card.remove();
				});
				memDOM();
			} else {
				showToast("No track found in that direction");
			}
		}
		function removeTrackRelative(e, direction) {
			e.stopPropagation();
			const activeCard = document.querySelector('.card.is-active');
			if (!activeCard) {
				showToast("Please select a card first.");
				return;
			}
			const currentTrack = activeCard.closest('#track');
			const multitrack = document.getElementById('multitrack');

			// Logic: direction -1 targets the track ABOVE the current one, 1 targets BELOW.
			// 0 (if you wanted) would target the current track itself.
			const bodyWrap = document.getElementById('body-wrap');
			const isVertical = bodyWrap.classList.contains('max-width');
			let targetTrack;
			if (direction === -1) {
				if (isVertical) {
					targetTrack = currentTrack.nextElementSibling;
				} else {
					targetTrack = currentTrack.previousElementSibling;
				}

			} else if (direction === 1) {
				if (isVertical) {
					targetTrack = currentTrack.previousElementSibling;
				} else {
					targetTrack = currentTrack.nextElementSibling;
				}
			}

			removeTrack(targetTrack);
		}
		function babyStepAddTrack() {
			const multitrack = document.getElementById('multitrack');

			// 1. Create a second track
			const newTrack = document.createElement('div');
			newTrack.id = "track-2";
			newTrack.style.flex = "1"; // This splits the space 50/50
			newTrack.style.border = "2px dashed rgba(255,255,255,0.2)";
			//newTrack.innerHTML = "<div style='color:gray; padding:5px;'>Track 2 Active</div>";

			// 2. Ensure the first track is also flexible
			document.getElementById('track').style.flex = "1";

			multitrack.appendChild(newTrack);
			showToast("Multi-track split enabled");
		}
		/**
		 * Moves the active card within its track based on mode-restricted directions.
		 * @param {string} direction - 'up', 'down', 'left', or 'right'
		 */
		function moveActiveCard(e, direction) {
			e.stopPropagation();
			const activeCard = document.querySelector('.card.is-active');
			if (!activeCard) return;

			const bodyWrap = document.getElementById('body-wrap');
			const isVerticalMode = bodyWrap.classList.contains('max-width');
			const currentTrack = activeCard.closest('#track');

			// 1. Determine if we are moving WITHIN the track or BETWEEN tracks
			let isCrossTrackMove = false;
			if (isVerticalMode) {
				// In Vertical, Left/Right jumps tracks
				if (direction === 'left' || direction === 'right') isCrossTrackMove = true;
			} else {
				// In Horizontal, Up/Down jumps tracks
				if (direction === 'up' || direction === 'down') isCrossTrackMove = true;
			}

			if (isCrossTrackMove) {
				// --- LOGIC FOR MOVING TO ANOTHER TRACK ---
				// 20251227: Cardinal: If there is no next track, create the track.
				let targetTrack;
				if (direction === 'down' || direction === 'left') {
					targetTrack = currentTrack.previousElementSibling;
					if (!targetTrack || !(targetTrack.id === 'track')) {
						addTrackRelative(e, -1);
					}
					targetTrack = currentTrack.previousElementSibling;
				} else {
					targetTrack = currentTrack.nextElementSibling;
					if (!targetTrack || !(targetTrack.id === 'track')) {
						addTrackRelative(e, +1);
					}
					targetTrack = currentTrack.nextElementSibling;
				}

				if (targetTrack && targetTrack.id === 'track') {
					// Get current coordinates of the active card to determine where it "was"
					const rect = activeCard.getBoundingClientRect();
					const x = rect.left + rect.width / 2;
					const y = rect.top + rect.height / 2;

					// Find visual insertion point in the new track
					const sibling = getInsertionSibling(targetTrack, x, y);

					if (sibling) {
						targetTrack.insertBefore(activeCard, sibling);
					} else {
						targetTrack.appendChild(activeCard);
					}

					// Ensure the new track scrolls the moved card into view
					setTimeout(() => {
						activeCard.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
					}, 50);
				}
			} else {
				// --- LOGIC FOR MOVING WITHIN THE SAME TRACK ---
				if (direction === 'left' || direction === 'up') {
					const prev = activeCard.previousElementSibling;
					if (prev) activeCard.parentNode.insertBefore(activeCard, prev);
				} else {
					const next = activeCard.nextElementSibling;
					if (next) activeCard.parentNode.insertBefore(activeCard, next.nextElementSibling);
				}

				// Keep focus on the card after it moves
				activeCard.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
			}

			// Refresh overlays in case position-based logic (like theater mode) needs to update
			updateAllCardOverlays();
			memDOM();
		}
		function moveCurrentCard(direction) {
			const track = document.getElementById('track');
			const centeredCard = track.querySelector('.card.is-centered');

			if (!centeredCard) return;

			if (direction === -1) {
				// Move Left/Up: Insert before the previous sibling
				const prev = centeredCard.previousElementSibling;
				if (prev && prev.classList.contains('card')) {
					track.insertBefore(centeredCard, prev);
				}
			} else if (direction === 1) {
				// Move Right/Down: Insert after the next sibling
				const next = centeredCard.nextElementSibling;
				if (next && next.classList.contains('card')) {
					// insertBefore(node, nextNext) effectively moves it after next
					track.insertBefore(next, centeredCard);
				}
			}

			// After moving, re-center the view on the same card immediately
			setTimeout(() => {
				centeredCard.scrollIntoView({
					behavior: 'smooth',
					block: 'center',
					inline: 'center'
				});

				// Refresh UI if you have counters or specific ordering logic
				if (typeof refreshAllUI === "function") refreshAllUI();
			}, 50);
		}
		function persistentWallpaper() {
			const savedWallpaper = localStorage.getItem('gallery_wallpaper');
			const defaultWallpaper = "https://substackcdn.com/image/fetch/$s_!KRIG!,w_720,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc5630f5a-5397-4ad1-b713-9ade6321e486_1536x1024.jpeg";
			const b = document.body;

			// Apply the image logic
			if (savedWallpaper) {
				b.style.backgroundImage = `url("${getFullResURL(savedWallpaper)}")`;
			} else {
				b.style.backgroundImage = `url("${getFullResURL(defaultWallpaper)}")`;
			}
		}
		function setCenteredAsWallpaper(e) {
			e.stopPropagation();
			const body = document.body;
			const activeCard = document.querySelector('.card.is-active img');
			if (!activeCard) {
				body.style.backgroundImage = 'none';
				localStorage.removeItem('gallery_wallpaper'); // Remove from storage
				showToast("Wallpaper Removed");
				return;
			}

			const url = activeCard.src;

			// Normalize background string for comparison
			const currentBg = body.style.backgroundImage.replace(/url\(["']?/, '').replace(/["']?\)/, '');

			if (currentBg === url) {
				// Toggle OFF: If already set, remove it
				body.style.backgroundImage = 'none';
				localStorage.removeItem('gallery_wallpaper'); // Remove from storage
				showToast("Wallpaper Removed");
			} else {
				// Toggle ON: Set new wallpaper
				body.style.backgroundImage = `url('${getFullResURL(url)}')`;
				localStorage.setItem('gallery_wallpaper', url); // Save to storage
				showToast("Wallpaper Set");
			}
		}
		function setWallpaper(url) {
			const body = document.body;
			// Normalize the URL for comparison (removing potential browser-added quotes/wrappers)
			const cleanUrl = url.replace(/['"]/g, '');
			const currentBg = body.style.backgroundImage.replace(/url\(["']?/, '').replace(/["']?\)/, '');

			// TOGGLE: If it's already the wallpaper, remove it
			if (currentBg === cleanUrl && cleanUrl !== "") {
				body.style.backgroundImage = 'none';
				localStorage.removeItem('gallery_wallpaper'); // Clear from storage
				showToast("Wallpaper Removed");
				document.querySelectorAll('.sq-btn').forEach(btn => btn.classList.remove('active-gold'));
			} else {
				// SET: Apply and save
				body.style.backgroundImage = `url('${getFullResURL(cleanUrl)}')`;
				localStorage.setItem('gallery_wallpaper', cleanUrl); // Save to storage
				showToast("Wallpaper Set");

				// Update active button state
				document.querySelectorAll('.sq-btn').forEach(btn => btn.classList.remove('active-gold'));
				if (event && event.currentTarget) {
					event.currentTarget.classList.add('active-gold');
				}
			}
		}
		async function smartImport() {

			let clipboardText = "";
			try {
				// 1. Try to read the clipboard
				let rawText = await navigator.clipboard.readText();
				// 2. Trim whitespace AND strip leading/trailing quotes
				clipboardText = rawText ? rawText.trim().replace(/^"|"$/g, '') : "";
				console.log(clipboardText);
			} catch (err) {
				console.warn("Clipboard access denied, defaulting to file picker.");
			}

			// 2. Determine if it's a JSON Collection or a single Asset
			const isJson = clipboardText.toLowerCase().endsWith('.json');
			const isUrl = clipboardText.startsWith('http') || clipboardText.startsWith('data:');
			const isFilePath = clipboardText.includes('/') || clipboardText.includes('\\');

			if (isJson && isUrl) {
				// --- BRANCH A: Existing JSON Collection Logic ---
				//loadCollectionFromUrl(clipboardText);
				showToast("URL detected in clipboard. Importing...");
				importFromURL(clipboardText);
			}
			else if (clipboardText && (isUrl || isFilePath)) {
				// --- BRANCH B: New Single Entry Logic ---
				addNewEntryFromClipboard(clipboardText);
			}
			else {
				// --- BRANCH C: Fallback to File Browser ---
				//openFileBrowserForJson();
				if (isMobile()) {
					const input = document.getElementById('mobile-file-input');
					input.click();
				} else {
					document.getElementById('json-input').click();
				}

			}
		}
		function handlePlusButton() {
			// If on mobile (or just as an alternative)
			const input = document.getElementById('mobile-file-input');

			// Ask user: Paste Link or Upload?
			const choice = confirm("Press OK to Upload from Gallery, Cancel to Paste Link");

			if (choice) {
				input.click();
			} else {
				const link = prompt("Paste image URL:");
				if (link) createCard({ p: link, t: ['unlabeled'], n: 'New Image' });
			}
		}
		function handleTagKey(e) {
			// Only trigger on Enter
			if (e.key === 'Enter') {
				const input = e.target;
				const tag = input.value.trim().toUpperCase();

				if (tag === "") return;

				// 1. Add to the currently active card if it exists
				const activeCardData = getActiveCardData();
				if (activeCardData) {
					if (!activeCardData.t.includes(tag)) {
						activeCardData.t.push(tag);

						// 2. Ensure the tag exists in the global cloud list too
						if (!ALL_TAGS.includes(tag)) {
							ALL_TAGS.push(tag);
							ALL_TAGS.sort();
						}

						showToast(`Tagged active card: ${tag}`);
					}
				} else {
					showToast("No active card selected to tag.");
				}

				// 3. Clear the input and reset UI mode
				clearAssignmentTag();

				// 4. Update everything
				refreshAllUI();
				renderCardTags(); // Refresh the pill list in the command panel
				memDOM();         // Persist changes
			}
		}
		function updateAssignmentUI() {
			const input = document.getElementById('assign-tag-input');
			if (!input) return;

			const val = input.value.trim().toUpperCase();
			const isActive = val !== "";

			document.body.classList.toggle('tag-assign-active', isActive);

			// Target ONLY files and cards
			const targets = document.querySelectorAll('.file-item, .card');

			targets.forEach(el => {
				const path = el.dataset.path;
				if (!path) return;

				// Look up the item in your master DATA array
				const item = DATA.find(i => i.p === path);

				// If the item exists and its tags array (item.t) contains the input value
				const hasTag = item && item.t.includes(val);

				if (isActive && hasTag) {
					el.classList.add('already-has-tag');
				} else {
					el.classList.remove('already-has-tag');
				}
			});
		}
		function clearAssignmentTag() {
			const input = document.getElementById('assign-tag-input');
			input.value = "";
			updateAssignmentUI();
		}
		// Handle the file selection
		// This should be in your init code or script root
		document.getElementById('mobile-file-input').onchange = async (e) => {
			const file = e.target.files[0];
			if (!file) return;

			// BRANCH 1: User picked a JSON file (Collection)
			if (file.type === "application/json" || file.name.endsWith('.json')) {
				importJSON(e.target);
				// Note: importJSON handles its own reader and resetting input.value
			}

			// BRANCH 2: User picked an Image (Single Entry)
			else if (file.type.startsWith('image/')) {
				// Generate a temporary browser path for the mobile file
				const blobUrl = URL.createObjectURL(file);

				// Pass it to your existing function
				// This will handle tags, Orphans, and UI refresh automatically
				await addNewEntryFromClipboard(blobUrl);

				showToast(`Added: ${file.name}`);
			}

			// Reset the input so the same file can be picked again if deleted
			e.target.value = '';
		};
		async function addNewEntryFromClipboard(path) {
			const tagsToAdd = Array.from(activeTags);
			const searchInput = document.getElementById('master-search');
			const searchTag = searchInput.value.trim().toUpperCase();
			if (searchTag !== "" && !tagsToAdd.includes(searchTag)) {
				tagsToAdd.push(searchTag);
			}
			// Get extension, remove query params, and check if it's not empty
			const extMatch = path.split(/[\\/]/).pop().split('?')[0].split('#')[0].split('.');
			if (extMatch.length > 1) {
				const extTag = "." + extMatch.pop().toLowerCase();
				// Use a safe prefix like "type:" or just the extension name
				const formattedExt = `type:${extTag}`;
				if (!tagsToAdd.includes(formattedExt)) {
					tagsToAdd.push(formattedExt);
				}
			}

			// Create the new item object
			// This regex /[\\/]/ means "split by \ OR /"
			const filename = path.split(/[\\/]/).pop().split('#')[0].split('?')[0] || "New Entry";
			const newItem = {
				n: filename,
				t: tagsToAdd,
				p: path,
			};

			// 1. Duplicate check against current master DATA
			if (DATA.some(item => item.p === path)) {
				alert("This item is already in your list.");
				return;
			}

			// 2. Find or Create the [Orphan Files] collection in savedPaths
			const orphanName = "[Orphan Files]";
			let orphanEntry = savedPaths.find(p => p.path === orphanName);

			if (!orphanEntry) {
				// Create the "Ghost Collection" if it doesn't exist
				orphanEntry = {
					path: orphanName,
					checked: true,
					data: []
				};
				savedPaths.push(orphanEntry);
			} else {
				orphanEntry.checked = true;
				if (!orphanEntry.data) {
					orphanEntry.data = [];
				}
			}
			// 3. Add the file to this ghost collection's data
			// Prevent duplicates within orphans
			if (!orphanEntry.data.some(item => item.p === path)) {
				orphanEntry.data.push(newItem);
			}


			// 4. Update the UI
			renderPathList();        // Refreshes the checkbox list so [Orphan Files] appears
			loadActiveCollections(); // Rebuilds the main DATA array from all checked paths

			// Create card from the version now inside DATA (to ensure references match)
			const finalItem = DATA.find(i => i.p === path);
			if (finalItem) createCard(finalItem);
		}
		async function importFromURL(url) {
			try {
				const response = await fetch(url);
				if (!response.ok) throw new Error(`HTTP ${response.status}`);
				const importedData = await response.json();

				const pathName = url;
				const existingIndex = savedPaths.findIndex(p => p.path === pathName);

				if (existingIndex === -1) {
					savedPaths.push({ path: pathName, checked: true, data: importedData });
				} else {
					savedPaths[existingIndex].data = importedData;
					savedPaths[existingIndex].checked = true;
				}

				renderPathList();
				loadActiveCollections();
				showToast(`Loaded: ${pathName.split('/').pop()}`);
			} catch (err) {
				showToast("Web Import Failed: " + err.message);
				// If web import fails, maybe the user actually wanted the file picker
				document.getElementById('json-input').click();
			}
		}
		function toggleCommandPanel(e) {
			e.stopPropagation();
			const panel = document.getElementById('command-panel');
			if (isHidden('command-panel')) {
				panel.style.display = 'block';
				// Optional: add your existing entrance animation
				panel.style.animation = 'cardEntrance 0.3s ease-out';
			} else {
				panel.style.display = 'none';
			}
		}
		function toggleImages(e) {
			toggleSidebarUpper(e, 'collapsible-images');

			refreshAllUI();
		}
		function toggleOrientation() {
			const body = document.getElementById('body-wrap');
			const btn = document.getElementById('mode-toggle');
			const isVertical = body.classList.toggle('max-width');
			btn.innerText = isVertical ? 'V' : 'H';

			// No need to clear inline styles anymore, 
			// Flexbox handles the transition between row and column.
			//updateCenteredCard();
		}
		function toggleOverlay(btn) {
			const card = btn.closest('.card');
			const overlay = card.querySelector('.card-tag-overlay');

			// Toggle between none and flex
			if (overlay.style.display === 'flex') {
				overlay.style.display = 'none';
			} else {
				overlay.style.display = 'flex';
				// Ensure the overlay content is up to date
				updateAllCardOverlays();
			}
		}
		function togglePathCheck(index) {
			savedPaths[index].checked = !savedPaths[index].checked;
			renderPathList();
			loadActiveCollections();
		}
		function toggleScrollMode(e) {
			e.stopPropagation();
			const body = document.getElementById('body-wrap');
			const btn = document.getElementById('mode-toggle');
			const iconContainer = btn.querySelector('div'); // Targets the icon-h or icon-v div

			if (body.classList.contains('max-width')) {
				// Switch to Horizontal
				body.classList.remove('max-width');
				iconContainer.className = 'icon-h';
				localStorage.setItem('scrollDirection', 'horizontal'); // Save state
			} else {
				// Switch to Vertical
				body.classList.add('max-width');
				iconContainer.className = 'icon-v';
				localStorage.setItem('scrollDirection', 'vertical'); // Save state
			}

			const activeCard = document.querySelector('.card.is-active');
			if (activeCard) {
				// We use a small timeout to ensure the CSS transition/layout 
				// has started before calculating the new scroll position.
				setTimeout(() => {
					activeCard.scrollIntoView({
						behavior: 'smooth',
						block: 'nearest',    // Centers vertically in vertical mode
						inline: 'nearest'    // Centers horizontally in horizontal mode
					});
				}, 400);
			}

			//updateCenteredCard();

		}
		function removePath(index) {
			savedPaths.splice(index, 1);
			renderPathList();
			loadActiveCollections();
		}
		/** * Reorders the active image within its track.
 * @param {number} direction - -1 for Up/Left, 1 for Down/Right
 * @param {string} modeRequirement - 'horizontal' or 'vertical'
 */
		function reorderImage(direction, modeRequirement) {
			const activeCard = document.querySelector('.card.is-active');
			if (!activeCard) return;

			const bodyWrap = document.getElementById('body-wrap');
			const isMaxHeight = bodyWrap.classList.contains('max-height'); // Vertical Mode
			const isMaxWidth = bodyWrap.classList.contains('max-width');   // Horizontal Mode

			// Validation: Only allow movement if the mode matches the button
			if (modeRequirement === 'horizontal' && isMaxHeight) return;
			if (modeRequirement === 'vertical' && isMaxWidth) return;

			if (direction === -1) {
				const prev = activeCard.previousElementSibling;
				if (prev) activeCard.parentNode.insertBefore(activeCard, prev);
			} else {
				const next = activeCard.nextElementSibling;
				if (next) activeCard.parentNode.insertBefore(next, activeCard);
			}

			// Ensure the moved card stays centered in the view
			activeCard.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
		}
		function loadActiveCollections() {
			let combined = [];
			savedPaths.forEach(item => {
				if (item.checked && item.data) {
					combined = combined.concat(Array.isArray(item.data) ? item.data : [item.data]);
				}
			});

			// Fast duplicate removal using a Map
			const uniqueMap = new Map();
			combined.forEach(item => uniqueMap.set(item.p, item));
			DATA = Array.from(uniqueMap.values());

			const tags = new Set();
			DATA.forEach(item => {
				if (item.t && Array.isArray(item.t)) {
					item.t.forEach(tag => tags.add(tag));
				}
			});
			ALL_TAGS = Array.from(tags).sort(); // Update the cloud source

			refreshAllUI();
		}

		function initScrollDirection() {
			const savedDirection = localStorage.getItem('scrollDirection');
			const body = document.getElementById('body-wrap');
			const btn = document.getElementById('mode-toggle');
			const iconContainer = btn?.querySelector('div');

			if (savedDirection === 'vertical') {
				body.classList.add('max-width');
				if (iconContainer) iconContainer.className = 'icon-v';
			} else {
				// Default to horizontal
				body.classList.remove('max-width');
				if (iconContainer) iconContainer.className = 'icon-h';
			}
		}

		function importJSON(input) {
			const file = input.files[0];
			if (!file) return;
			const reader = new FileReader();
			reader.onload = (e) => {
				try {
					const importedData = JSON.parse(e.target.result);

					// Use webkitRelativePath if available, otherwise fallback to name
					const pathName = file.webkitRelativePath || file.name;
					const existingIndex = savedPaths.findIndex(p => p.path === pathName);
					if (existingIndex === -1) {
						savedPaths.push({ path: pathName, checked: true, data: importedData });
					} else {
						savedPaths[existingIndex].data = importedData;
						savedPaths[existingIndex].checked = true;
					}
					renderPathList();
					loadActiveCollections();
					showToast(`Imported: ${pathName}`);
				} catch (err) {
					showToast("Error: Invalid JSON");
				}
				input.value = "";
			};
			reader.readAsText(file);
		}

		function renderPathList() {
			const container = document.getElementById('path-list-container');
			if (!container) return;
			container.innerHTML = '';

			// Calculate the counts for the header display
			const greenCount = savedPaths.filter(p => p.data !== null).length;
			const totalCount = savedPaths.length;

			// Update the UI with the "Green / Total" format
			document.getElementById('collection-count').innerText = `${greenCount}/${totalCount}`;

			savedPaths.forEach((item, index) => {
				const isLoaded = item.data !== null;
				const div = document.createElement('div');
				// Apply 'loaded' class if data exists (green), 'stale' if checked but no data (yellow)
				div.className = `path-entry ${isLoaded ? 'loaded' : (item.checked ? 'stale' : '')}`;

				div.innerHTML = `
            <input type="checkbox" ${item.checked ? 'checked' : ''} onchange="togglePathCheck(${index})">
            <div class="path-text" onclick="handlePathClick(${index})">${item.path}</div>
            <button class="inline-toggle action-btn" onclick="removePath(${index})">✕</button>
        `;
				container.appendChild(div);
			});

			// Save metadata to local storage
			const metadata = savedPaths.map(p => ({ path: p.path, checked: p.checked }));
			localStorage.setItem('gallery_paths', JSON.stringify(metadata));
		}

		async function handlePathClick(index) {
			const path = savedPaths[index].path;
			const isURL = path.startsWith('http://') || path.startsWith('https://');

			if (isURL) {
				showToast("Fetching data from URL...");
				await importFromURL(path);
			} else {
				try {
					await navigator.clipboard.writeText(path);
					showToast("Path copied. Paste into file picker.");
					document.getElementById('json-input').click();
				} catch (err) {
					showToast("Clipboard failed. Opening picker...");
					document.getElementById('json-input').click();
				}
			}
		}



		function showSplash(e) {
			// 20251226: StarTree: If the e target is not an image, return
			if (!e || !e.target) return false;
			const image = e.target.closest('img');
			if (!image) return;

			const splash = document.getElementById('splash-screen');
			const splashImg = document.getElementById('splash-img');

			// 1. Reset values so it starts maximized and centered
			scale = 1;
			pointX = 0;
			pointY = 0;

			// 2. Set image and update transform BEFORE showing
			splashImg.src = getFullResURL(image.src);
			updateTransform();

			// 3. Show the screen
			splash.style.display = 'flex';
			document.body.style.overflow = 'hidden';
		}

		function hideSplash() {
			const splash = document.getElementById('splash-screen');
			splash.style.display = 'none';
			document.body.style.overflow = '';

			// Clear image to save memory
			document.getElementById('splash-img').src = '';
		}

		function updateTransform() {
			const img = document.getElementById('splash-img');
			// Using translate3d is more performant for panning
			img.style.transform = `translate3d(${pointX}px, ${pointY}px, 0) scale(${scale})`;
		}

		// Panning Logic
		const sImg = document.getElementById('splash-img');
		sImg.onmousedown = (e) => {
			if (scale === 1) return;
			isPanning = true;
			startX = e.clientX - pointX;
			startY = e.clientY - pointY;
		};
		window.onmousemove = (e) => {
			if (!isPanning) return;
			pointX = e.clientX - startX;
			pointY = e.clientY - startY;
			updateTransform();
		};
		window.onmouseup = () => isPanning = false;

		// Zoom Logic
		document.getElementById('splash-screen').onwheel = (e) => {
			e.preventDefault();
			scale = e.deltaY > 0 ? Math.max(1, scale - 0.2) : Math.min(5, scale + 0.2);
			if (scale === 1) { pointX = 0; pointY = 0; }
			updateTransform();
		};

		let initialDist = 0; // For pinch-zoom

		document.getElementById('splash-screen').addEventListener('touchstart', (e) => {
			if (e.touches.length === 2) {
				// Prepare for pinch-zoom
				initialDist = Math.hypot(
					e.touches[0].pageX - e.touches[1].pageX,
					e.touches[0].pageY - e.touches[1].pageY
				);
			} else if (e.touches.length === 1) {
				// Prepare for panning
				startX = e.touches[0].pageX - translateX;
				startY = e.touches[0].pageY - translateY;
			}
		}, { passive: false });

		document.getElementById('splash-screen').addEventListener('touchmove', (e) => {
			e.preventDefault(); // Stop the page from bouncing/scrolling

			if (e.touches.length === 2 && initialDist > 0) {
				// Handle Pinch Zoom
				const currentDist = Math.hypot(
					e.touches[0].pageX - e.touches[1].pageX,
					e.touches[0].pageY - e.touches[1].pageY
				);
				const zoomFactor = currentDist / initialDist;
				scale *= zoomFactor;
				initialDist = currentDist; // Update for next move
			} else if (e.touches.length === 1) {
				// Handle Panning
				translateX = e.touches[0].pageX - startX;
				translateY = e.touches[0].pageY - startY;
			}

			updateSplashTransform(); // Your existing function to apply scale/translate
		}, { passive: false });


		function showToast(msg) {
			const t = document.getElementById('toast');
			t.innerText = msg;
			t.classList.add('show');
			setTimeout(() => t.classList.remove('show'), 2500);
		}
		function updateCenteredCard(e) {
			// 20251226: StarTree: If the user is scrolling on a track in single track mode, automatically set the center card as the active card.
			return;
			let track = document.getElementById('track');
			console.log(e);
			if (e && e.target) {
				if (typeof e.target.closest === "function") {
					track = e.target.closest('#track');

				}
			}
			if (!track) return;
			const tracks = document.querySelectorAll('#track');
			if (tracks.length > 1) { return; }
			const cards = track.querySelectorAll('.card');
			const bodyWrap = document.getElementById('body-wrap');
			const isVertical = bodyWrap.classList.contains('max-width');

			// Find the center point of the viewport
			const viewportCenterX = window.innerWidth / 2;
			const viewportCenterY = window.innerHeight / 2;

			let closestCard = null;
			let minDistance = Infinity;

			cards.forEach((card, index) => {
				const rect = card.getBoundingClientRect();
				const cardCenterX = rect.left + rect.width / 2;
				const cardCenterY = rect.top + rect.height / 2;

				// Calculate distance from viewport center based on orientation
				const distance = isVertical
					? Math.abs(viewportCenterY - cardCenterY)
					: Math.abs(viewportCenterX - cardCenterX);

				if (distance < minDistance) {
					minDistance = distance;
					closestCard = { card, index };
				}
			});

			if (closestCard) {
				// 1. Clear previous centered/active states
				cards.forEach(c => {
					c.classList.remove('is-centered');
					c.classList.remove('is-active'); // This triggers the white border
				});

				// 2. Highlight the new center card
				closestCard.card.classList.add('is-centered');
				closestCard.card.classList.add('is-active');
			}
		}
		function updateStageCount() {
			const count = document.querySelectorAll('.card').length;
			document.getElementById('stage-count').innerText = count;
		}
		function syncSidebarHighlights() {
			const activePaths = Array.from(document.querySelectorAll('.card')).map(c => c.dataset.path);
			document.querySelectorAll('.file-item').forEach(item => {
				const itemPath = item.dataset.path;
				item.classList.toggle('active-item', activePaths.includes(itemPath));
			});
			updateStageCount();
		}

		async function createCard(item) {
			// If the item is null, choose a random one from the file list.
			if (!item) {
				const choices = document.querySelectorAll(".file-item:not(.active-item)");
				const numChoices = choices.length;
				if (choices.length < 1) { return; }
				const file = choices[Math.floor(Math.random() * choices.length)];
				const path = file.dataset.path;
				item = DATA.find(i => i.p === path);
			}

			// 1. Change: Target the active track or the default track
			const multitrack = document.getElementById('multitrack');
			let activeCard = document.querySelector('.card.is-active');
			const activeTrack = activeCard ? activeCard.parentElement : document.querySelector('#track');
			const isVertical = document.getElementById('body-wrap').classList.contains('max-width');

			// Duplicate check
			const existing = Array.from(document.querySelectorAll('.card')).find(c => c.dataset.path === item.p);
			if (existing) {
				const bSameTrack = (activeTrack == existing.closest('#track'));
				if (existing.classList.contains('pinned')) {
					existing.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
					setActiveCard(existing);
					return;
				} else {
					existing.remove();
					if (bSameTrack) {
						syncSidebarHighlights();
						return;
					}
				}
			}

			if (autoFlush) {
				// 20251227: Cardinal: First count the number of cards in the track.
				const cardsInTrack = activeTrack.querySelectorAll('.card:not(.pinned)');
				if (cardsInTrack.length > 0) {
					if (cardsInTrack.length > 1) {
						if (!await showConfirm("This track has more than one unstarred cards. Keep them?")) {
							cardsInTrack.forEach(c => {
								if (!c.classList.contains('pinned')) c.remove();
							});
						}
					} else {
						cardsInTrack.forEach(c => {
							if (!c.classList.contains('pinned')) c.remove();
						});
					}
				}
				activeCard = document.querySelector('.card.is-active');
			}




			const c = document.createElement('div');
			c.className = 'card';
			c.dataset.path = item.p;
			updateStarButtonState();

			// 20250103: Lei: using iFrame to show PDF
			const isPDF = item.p.toLowerCase().endsWith('.pdf');

			if (isPDF) {
				const pdfUrl = `${item.p}#view=FitH&zoom=100`;
				c.innerHTML = `
        <div class="card-selection-hitbox" style="position:absolute; top:0; left:0; width:100%; height:20px; z-index:20; cursor:cell;"></div>
				<div class="card-tag-overlay"></div>
        <embed 
            src="${pdfUrl}" 
            type="application/pdf" 
            style="min-width: 100%;"
				/>`;
			} else {
				c.innerHTML = `<a href="${getURL(item)}" target="_blank" class="file-link" onclick="return false;"><img src="${getImageURL(item)}" loading="lazy"></a>`;
			}

			// 20251229: Sasha: In Multitrack vertical mode insert after the active card.
			const isMultitrack = multitrack.querySelectorAll("#track").length > 1;
			if (isMultitrack && activeCard) {
				if (isVertical) {
					activeCard.after(c);
				} else {
					if (currentDock === 'left') {
						activeCard.before(c);

					} else {
						activeCard.after(c);

					}
				}
			} else {
				// 3. Change: Insertion logic targets activeTrack
				const cards = Array.from(activeTrack.querySelectorAll('.card'));

				if (cards.length === 0) {
					activeTrack.appendChild(c);
				} else {
					const centerX = activeTrack.scrollLeft + (activeTrack.clientWidth / 2);
					const centerY = activeTrack.scrollTop + (activeTrack.clientHeight / 2);

					let closestCard = cards[0];
					let minDistance = Infinity;

					cards.forEach(card => {
						const midX = card.offsetLeft + (card.offsetWidth / 2);
						const midY = card.offsetTop + (card.offsetHeight / 2);
						const dist = isVertical ? Math.abs(centerY - midY) : Math.abs(centerX - midX);

						if (dist < minDistance) {
							minDistance = dist;
							closestCard = card;
						}
					});

					if (currentDock === 'left') {
						closestCard.insertAdjacentElement('beforebegin', c);

					} else {
						closestCard.insertAdjacentElement('afterend', c);

					}
				}

				// --- NEW LOGIC FOR MULTI-TRACK AUTO-ACTIVE ---			
				if (multitrack && multitrack.children.length > 1) {
					// 1. Clear existing active state from all other cards
					document.querySelectorAll('.card.is-active').forEach(c => c.classList.remove('is-active'));

					// 2. Make this new card active
					c.classList.add('is-active');
					updateStarButtonState();


				}

			}
			setTimeout(() => {
				//if (multitrack.children.length > 1) {
				c.scrollIntoView({
					behavior: 'smooth',
					block: 'center',
					inline: 'center'
				});

				updateAllCardOverlays();
				syncSidebarHighlights();
				memDOM();
			}, 50);
			setActiveCard(c);
		}
		function updateStarButtonState() {
			const activeCard = document.querySelector('.card.is-active');
			const starBtn = document.querySelector('.star-btn'); // or .pin-btn

			if (activeCard && activeCard.classList.contains('pinned')) {
				starBtn.classList.add('active-gold');
			} else {
				starBtn.classList.remove('active-gold');
			}
		}
		function updateAllCardOverlays() {
			// 20251226: StarTree: To be changed to so the tags don't show on the card itself.
			return;
			document.querySelectorAll('.card').forEach(card => {
				const path = card.dataset.path;
				const item = DATA.find(i => i.p === path);
				if (!item) return;

				const overlay = card.querySelector('.card-tag-overlay');
				overlay.innerHTML = "";
				[...item.t].sort().forEach(t => {
					const p = document.createElement('div');
					p.className = 'tag-pill';
					if (activeTags.has(t)) p.classList.add('active');
					p.dataset.tag = t;
					p.innerText = t;
					p.onclick = (e) => { e.stopPropagation(); toggleTag(t); };
					overlay.appendChild(p);
				});
			});
			memDOM();
		}
		function getActiveCard() {
			const card = document.querySelector(".card.is-active");
			if (!card) { return null; }
			return card;
		}
		function getActiveCardData() {
			const card = getActiveCard();
			if (!card) { return null; }
			const path = card.dataset.path;
			const item = DATA.find(i => i.p === path);
			return item;
		}
		function toggleAutoFlush(e) {
			e.stopPropagation();
			autoFlush = !autoFlush;
			localStorage.setItem('gallery_flush', autoFlush);
			updateAutoFlushUI();
			showToast(autoFlush ? "Auto-Flush Enabled" : "Auto-Flush Disabled");
		}

		function updateAutoFlushUI() {
			const btn = document.getElementById('auto-flush-btn');
			btn.classList.toggle('active-gold', autoFlush); // Solid yellow when active
			btn.classList.toggle('action-btn', !autoFlush); // Semi-transparent when inactive
		}

		function toggleTagSort() {
			// 1. Switch the underlying mode
			tagSortMode = (tagSortMode === 'alpha') ? 'freq' : 'alpha';
			localStorage.setItem('gallery_tag_sort', tagSortMode);

			const btn = document.getElementById('tag-sort-btn');

			// 2. Show the FUTURE state (the opposite of current mode)
			// If current is alpha, show '1-9' (the frequency option)
			// If current is freq, show 'A-Z' (the alphabetical option)
			btn.innerText = (tagSortMode === 'alpha') ? '1-9' : 'A-Z';

			// 3. Keep it semi-transparent by ensuring only 'action-btn' is used
			btn.className = 'inline-toggle action-btn';

			refreshAllUI();
		}
		function updateTagSortUI() {
			document.getElementById('tag-sort-btn').innerText = tagSortMode === 'alpha' ? 'A-Z' : '1-9';
		}
		function getFilteredData() {
			const q = document.getElementById('master-search').value.toLowerCase().trim();

			return DATA.filter(i => {
				// 1. Must have EVERY active tag
				const matchesActive = Array.from(activeTags).every(at => i.t.includes(at));

				// 2. Must match the text search (against tags)
				const matchesSearch = q === "" || i.t.some(it => it.toLowerCase().includes(q));

				return matchesActive && matchesSearch;
			});
		}
		function refreshAllUI() {
			const q = document.getElementById('master-search').value.toLowerCase();
			const list = document.getElementById('file-list');
			list.innerHTML = "";
			list.className = "file-list" + (sidebarIsGrid ? " grid-view" : "");

			const filtered = DATA.filter(i => {
				const matchesActive = Array.from(activeTags).every(at => i.t.includes(at));
				const matchesSearch = q === "" || i.t.some(it => it.toLowerCase().includes(q));
				return matchesActive && matchesSearch;
			});

			renderCardTags();

			// 1. Calculate tag frequencies in the current filtered set
			const tagFreq = {};
			filtered.forEach(i => {
				i.t.forEach(t => {
					if (t && t.trim() !== "") {
						tagFreq[t] = (tagFreq[t] || 0) + 1;
					}
				});
			});

			// 2. Sort the cloud based on the active mode (Alpha vs Frequency)
			let sortedTags = ALL_TAGS.filter(t => {
				const matchesSearch = t.toLowerCase().includes(q);
				const isNotEmpty = t && t.trim() !== ""; // <--- ADD THIS CHECK
				return matchesSearch && isNotEmpty;
			});

			if (tagSortMode === 'freq') {
				sortedTags.sort((a, b) => (tagFreq[b] || 0) - (tagFreq[a] || 0) || a.localeCompare(b));
			} else {
				sortedTags.sort((a, b) => a.localeCompare(b));
			}

			const cloud = document.getElementById('tag-cloud');
			cloud.innerHTML = "";

			sortedTags.forEach(t => {
				const count = tagFreq[t] || 0;
				if (count === 0 && activeTags.size > 0 && !activeTags.has(t)) return; // Hide empty tags if filtering

				const p = document.createElement('div');
				p.className = 'tag-pill' + (activeTags.has(t) ? ' active' : '');
				p.dataset.tag = t;
				// Optional: Add a small count indicator next to the tag name
				p.innerHTML = `${t} <span class="tag-count-small">${count}</span>`;
				cloud.appendChild(p);
			});

			document.getElementById('tag-count').innerText = cloud.children.length;
			document.getElementById('img-count').innerText = filtered.length;

			// ... rest of function (file-item generation) remains same
			filtered.forEach((item, idx) => {
				const d = document.createElement('div');
				d.className = 'file-item';
				d.dataset.path = item.p;
				d.id = 'f-' + idx;
				if (sidebarIsGrid) {
					// Wrap the thumbnail in a link pointing to the real source
					d.innerHTML = `
      <a href="${getURL(item)}" target="_blank" class="file-link" onclick="return false;">
        <img src="${getThumbnailURL(getImageURL(item))}" loading="lazy" alt="${getURL(item)}">
      </a>`;
				} else {
					d.innerHTML = `<a href="${getURL(item)}" target="_blank" class="file-link" onclick="return false;" title="${item.p}">${item.n}</a>`;
				}
				list.appendChild(d);
			});
			updateAllCardOverlays();
			syncSidebarHighlights();
			updateStageCount();
			memDOM();
			updateAssignmentUI();
		}

		async function clearWorkspace(e) {
			e.stopPropagation();
			// 20260105: Sasha: If the multitrack area has pinned cards, but not all of them are pinned, remove only the unpinned cards.

			const multitrack = document.querySelector("#multitrack");
			const numCards = document.querySelectorAll(".card").length;
			const numPinned = document.querySelectorAll(".card.pinned").length;

			let msg = "This will wipe the multitrack area. Keep it?"
			if (numCards != numPinned && numPinned > 0) {
				msg = "This will remove " + (numCards - numPinned) + " card(s) without ⭐. Keep them?";
				if (await showConfirm(msg)) { return; }
				document.querySelectorAll('.card').forEach(c => {
					if (!c.classList.contains('pinned')) c.remove();
				});
				return;
			} else if (numCards == numPinned) {
				msg = "The multitrack only has ⭐ card(s). Keep them?"
				if (await showConfirm(msg)) { return; }
			}
			multitrack.innerHTML = "<div id='track'></div>";
			syncSidebarHighlights();
		}
		async function exportFilteredData(mode = 'path') {
			const q = document.getElementById('master-search').value.toLowerCase();
			const filtered = DATA.filter(i => {
				const matchesActive = Array.from(activeTags).every(at => i.t.includes(at));
				return matchesActive && (q === "" || i.t.some(it => it.toLowerCase().includes(q)));
			});

			showToast(`Preparing ${filtered.length} items for export...`);
			document.body.style.cursor = 'wait';
			let dataToExport = [];
			let failCount = 0; // Track failures

			if (mode === 'base64') {
				showToast("Starting Base64 conversion...");
				// Transform the paths into Base64 strings
				dataToExport = await Promise.all(filtered.map(async (item) => {
					try {
						const base64String = await getBase64FromUrl(item.p);
						return { ...item, p: base64String }; // Replace path with base64
					} catch (err) {
						console.error(`@@Failed to convert ${item.p}:`, err);
						failCount++; // Increment failure count
						return item; // Fallback to path if conversion fails
					}
				}));
			} else {
				dataToExport = filtered;
			}

			// standard Download Logic
			const blob = new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json' });
			const a = document.createElement('a');
			a.href = URL.createObjectURL(blob);
			a.download = `${mode.toUpperCase()}_Export_${new Date().toISOString().slice(0, 10)}.json`;
			a.click();

			// 5. Cleanup
			document.body.style.cursor = 'default';
			setTimeout(() => URL.revokeObjectURL(a.href), 1000);

			// --- THE FIX: COMBINED FINAL TOAST ---
			let finalMsg = `Exported ${filtered.length} items.`;
			if (failCount > 0) {
				finalMsg += ` (${failCount} images kept as URLs due to CORS)`;
			}

			showToast(finalMsg);
		}

		// Helper function to handle the conversion
		async function getBase64FromUrl(url) {
			const response = await fetch(url);
			const blob = await response.blob();
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				reader.onloadend = () => resolve(reader.result);
				reader.onerror = reject;
				reader.readAsDataURL(blob);
			});
		}

		function exportGallery() {
			let docClone = document.documentElement.cloneNode(true);
			let bodyWrap = docClone.querySelector('#body-wrap');
			if (bodyWrap) bodyWrap.classList.add('collapsed');

			// Ensure Meta Charset is present
			let head = docClone.querySelector('head');
			if (!head.querySelector('meta[charset]')) {
				let meta = document.createElement('meta');
				meta.setAttribute('charset', 'UTF-8');
				head.prepend(meta);
			}

			let html = docClone.outerHTML;

			// 3. Inject current data and tags
			html = html.replace(/let DATA = \[.*?\];/, `let DATA = ${JSON.stringify(DATA)};`);
			html = html.replace(/let ALL_TAGS = \[.*?\];/, `let ALL_TAGS = ${JSON.stringify(ALL_TAGS)};`);

			const blob = new Blob(['<!DOCTYPE html>\n' + html], { type: 'text/html' });
			const a = document.createElement('a');
			a.href = URL.createObjectURL(blob);
			a.download = 'Gallery_Export.html';
			a.click();
		}
		/**
		 * Finds the existing card in a track that the new card should be inserted BEFORE.
		 * @param {HTMLElement} track - The target track container.
		 * @param {number} x - The horizontal coordinate (for Horizontal mode).
		 * @param {number} y - The vertical coordinate (for Vertical mode).
		 * @returns {HTMLElement|null} - The sibling to insert before, or null to append at the end.
		 */
		function getInsertionSibling(track, x, y) {
			const isVertical = document.getElementById('body-wrap').classList.contains('max-width');
			const siblings = Array.from(track.querySelectorAll('.card:not(.is-dragging)'));

			return siblings.find(sibling => {
				const box = sibling.getBoundingClientRect();
				if (isVertical) {
					// In Vertical mode, compare Y coordinates (Vertical mid-point)
					return y < box.top + box.height / 2;
				} else {
					// In Horizontal mode, compare X coordinates (Horizontal mid-point)
					return x < box.left + box.width / 2;
				}
			});
		}
		function updateStageCount() {
			return;
			document.getElementById('stage-count').innerText = document.querySelectorAll('.card').length;
		}
		// New function to handle the side-specific click
		function restoreAndDock(side) {
			updateDock(side);      // Move the sidebar to clicked side
			toggleSidebar(true);   // Show the sidebar
		}
		function handleCornerClick(clickedSide) {
			const bodyWrap = document.getElementById('body-wrap');
			const isCollapsed = bodyWrap.classList.contains('collapsed');
			if (currentDock !== clickedSide) {
				// Instant side swap and show
				updateDock(clickedSide);
				toggleSidebar(true);
			} else {
				// Toggle fade in/out
				toggleSidebar(isCollapsed);
			}
		}
		function toggleSidebar(show) {
			const splash = document.getElementById('splash-screen');

			// 1. Check if the splash screen is currently visible
			if (window.getComputedStyle(splash).display !== 'none') {
				// If splash is open, the button acts as a CLOSE button
				hideSplash();
				return; // Exit the function so the sidebar doesn't open
			}

			const bodyWrap = document.getElementById('body-wrap');
			bodyWrap.classList.toggle('collapsed', !show);
		}
		function updateDock(side) {
			currentDock = side;
			// Add/Remove class to handle the layout direction
			document.body.classList.toggle('dock-left', side === 'left');


			// Save preference
			localStorage.setItem('gallery_dock', side);
		}
		function handleLinkAction(e) { e.preventDefault(); const filtered = Array.from(activeTags).filter(t => !t.match(/^\[.*\]$/)); navigator.clipboard.writeText((document.getElementById('user-note').value + " " + filtered.join(' ')).trim()); const btn = document.getElementById('add-btn'); btn.innerText = '✓'; setTimeout(() => btn.innerText = '+', 1000); }


		function toggleFocus(card) { cycleViewMode(); setTimeout(() => { card.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' }); }, 150); }
		function handleMissingImage(img, path) {
			// 20260110: Sasha: Don't need to remove the image.
			const card = img.closest('.card');
			DATA = DATA.filter(i => i.p !== path);
			card.remove();
			refreshAllUI();
		}
		function toggleTag(t) {
			if (activeTags.has(t)) activeTags.delete(t); else activeTags.add(t); refreshAllUI();
		}
		function saveNotes(v) { localStorage.setItem('gallery_notes', v); }
		let scale = 1;
		let pointX = 0;
		let pointY = 0;
		let startX = 0;
		let startY = 0;
		let isPanning = false;

		const splashImg = document.getElementById('splash-img');
		const splashScreen = document.getElementById('splash-screen');

		// ZOOM LOGIC (Mouse Wheel)
		splashScreen.onwheel = function (e) {
			e.preventDefault();
			const delta = e.deltaY;
			const zoomSpeed = 0.2;

			if (delta > 0) {
				scale = Math.max(1, scale - zoomSpeed); // Min zoom is 1x
			} else {
				scale = Math.min(5, scale + zoomSpeed); // Max zoom is 5x
			}

			// If we zoom back to 1, reset position
			if (scale === 1) {
				pointX = 0;
				pointY = 0;
			}

			updateTransform();
		};

		// PAN LOGIC (Click and Drag)
		splashImg.onmousedown = function (e) {
			if (scale === 1) return; // Only pan if zoomed in
			e.preventDefault();
			isPanning = true;
			startX = e.clientX - pointX;
			startY = e.clientY - pointY;
		};

		window.onmousemove = function (e) {
			if (!isPanning) return;
			pointX = e.clientX - startX;
			pointY = e.clientY - startY;
			updateTransform();
		};

		window.onmouseup = function () {
			isPanning = false;
		};

		function updateTransform() {
			splashImg.style.transform = `translate(${pointX}px, ${pointY}px) scale(${scale})`;
		}

		// Update your hideSplash to reset these values
		function hideSplash() {
			const splash = document.getElementById('splash-screen');
			splash.style.display = 'none';
			document.body.style.overflow = '';

			// Reset state for next time
			scale = 1;
			pointX = 0;
			pointY = 0;
			updateTransform();
		}
		function toggleStageTools(e) {
			e.stopPropagation();
			const s = document.getElementById('button-palatte');
			// Check for empty string (initial state)
			s.style.display = (s.style.display === 'none' || s.style.display === '') ? 'block' : 'none';
		}
		function toggleSidebarUpper(e, aID) {
			e.stopPropagation();
			const c = document.getElementById(aID);
			if (c.checkVisibility()) {
				c.style.display = "none";
				c.classList.remove("sidebar-upper");
			} else {
				c.style.display = "flex";
				c.classList.add("sidebar-upper");
			}
		}

		function toggleCollections(e) {
			toggleSidebarUpper(e, 'collapsible-collections');
		}
		function toggleTagCloud(e) {
			e.stopPropagation();
			const c = document.getElementById('collapsible-tags');
			if (c.checkVisibility()) {
				c.style.display = "none";
				c.classList.remove("sidebar-upper");
			} else {
				c.style.display = "block";
				c.classList.add("sidebar-upper");
			}
		}
		function cycleViewMode() {
			const bodyWrap = document.getElementById('body-wrap');
			const btn = document.getElementById('mode-toggle');
			const isMax = bodyWrap.classList.toggle('max-width');

			localStorage.setItem('gallery_is_max_width', isMax);

			// Set character based on current mode
			// icon-v is used for Max Height mode, icon-h for Max Width mode
			btn.innerHTML = isMax ? '<div class="icon-v"></div>' : '<div class="icon-h"></div>';
			// Trigger highlight update immediately after switching modes
			//setTimeout(updateCenteredCard, 100);
		}

		function toggleSidebarView() {
			sidebarIsGrid = !sidebarIsGrid;
			const icon = document.getElementById('toggle-icon');
			const container = document.getElementById('grid-slider-container'); // Get the slider container

			if (sidebarIsGrid) {
				icon.className = 'css-list';
				icon.innerHTML = '<div></div><div></div><div></div>';
				if (container) container.style.display = 'flex'; // Show slider
			} else {
				icon.className = 'css-grid';
				icon.innerHTML = '<div></div><div></div><div></div><div></div>';
				if (container) container.style.display = 'none'; // Hide slider
			}

			refreshAllUI();
		}
		function updateGridCols(v) {
			document.documentElement.style.setProperty('--grid-cols', v);
			// document.getElementById('col-val').innerText = v; // REMOVE OR COMMENT OUT THIS LINE
			localStorage.setItem('gallery_cols', v);
		}

		document.addEventListener('wheel', (e) => {
			// 20260110: Sasha: Also for the button pad.
			const buttonPad = e.target.closest('.button-pad');
			if (buttonPad) {
				e.preventDefault();
				if (buttonPad.classList.contains("left")) {
					buttonPad.scrollLeft -= e.deltaY;
				} else {
					buttonPad.scrollLeft += e.deltaY;
				}

				return; // Stop here so we don't trigger the track logic below
			}

			// Horizontal scrolling for horizontal tracks
			const isHorizontalMode = !document.getElementById('body-wrap').classList.contains('max-width');
			if (isHorizontalMode) {
				const targetTrack = e.target.closest('#track');
				if (targetTrack) {
					e.preventDefault();
					targetTrack.scrollLeft += e.deltaY;
				}
			}
		}, { passive: false });
	</script>
</body>

</html>