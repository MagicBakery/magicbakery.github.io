<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Magic Theater</title>
	<link rel="icon" type="image/png" href="https://raw.githubusercontent.com/MagicBakery/Icons/refs/heads/main/Star.png">
	<style>
		:root {
			--bg: #000;
			--panel: rgba(15, 15, 15, 0.5);
			--border: rgba(255, 255, 255, 0.1);
			--accent: #fff;
			--text: #fff;
			--text-dim: #CCC;
			--grid-cols: 3;
			--sidebar-w: 300px;
			--gold: #ffd700;
			--h-dir: row;
			--green: #4CAF50;
		}

		* {
			box-sizing: border-box;
		}

		#sidebar *,
		#tag-cloud,
		.file-list,
		#main {
			-ms-overflow-style: none;
			scrollbar-width: none;
		}

		#sidebar *::-webkit-scrollbar,
		#main::-webkit-scrollbar {
			display: none;
		}

		body {
			background: var(--bg);
			/* This is #000, so it fades from black */
			color: var(--text);
			font-family: monospace;
			margin: 0;
			display: flex;
			height: 100vh;
			width: 100vw;
			overflow: hidden;
			background-size: cover;
			background-position: center;
			background-attachment: fixed;
			transition: background-image 0.5s ease-in-out;
		}

		body::before {
			content: "";
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.2);
			z-index: -1;
			pointer-events: none;
		}

		#sidebar {
			width: var(--sidebar-w);
			background: var(--panel);
			backdrop-filter: blur(12px);
			display: flex;
			flex-direction: column;
			/* Transition opacity instead of transform */
			transition: opacity 0.3s ease, visibility 0.3s ease;
			z-index: 10000;
			position: relative;
		}

		/* Default Right Docked */
		body:not(.dock-left) #sidebar {
			order: 2;
			border-left: 1px solid var(--border);
		}

		/* Left Docked */
		body.dock-left #sidebar {
			order: 0;
			border-right: 1px solid var(--border);
		}

		/* Hidden States: Force the sidebar to the literal edges */
		body.collapsed:not(.dock-left) #sidebar {
			position: fixed;
			right: 0;
			top: 0;
			height: 100%;
			transform: translateX(100%);
		}

		body.collapsed.dock-left #sidebar {
			position: fixed;
			left: 0;
			top: 0;
			height: 100%;
			transform: translateX(-100%);
			/* Slides completely off-screen to the left */
		}

		/* Hidden States: No sliding, just fade out */
		body.collapsed #sidebar {
			opacity: 0;
			visibility: hidden;
			pointer-events: none;
			position: absolute;
			/* Take out of flow so #main expands instantly */
		}

		/* Visible States: Fade in */
		body:not(.collapsed) #sidebar {
			opacity: 1;
			visibility: visible;
			pointer-events: auto;
			position: relative;
		}


		#toast {
			position: fixed;
			bottom: 20px;
			left: 50%;
			transform: translateX(-50%);
			background: rgba(255, 215, 0, 0.6);
			backdrop-filter: blur(8px);
			color: #000;
			padding: 10px 20px;
			border-radius: 8px;
			font-weight: bold;
			font-size: 14px;
			z-index: 9999;
			opacity: 0;
			transition: opacity 0.3s ease;
			pointer-events: none;
			border: 1px solid rgba(255, 255, 255, 0.2);
		}

		#toast.show {
			opacity: 1;
		}

		/* Hide the old ghost restore button */
		#ghost-restore {
			display: none !important;
		}

		/* New Hover-to-Show zones: Always on top */
		.hover-trigger {
			position: fixed;
			bottom: 0;
			/* Changed from top: 0 */
			width: 60px;
			height: 60px;
			z-index: 10001;
			display: flex;
			align-items: center;
			justify-content: center;
			background: rgba(255, 255, 255, 0.05);
			backdrop-filter: blur(5px);
			cursor: pointer;
			font-size: 20px;
			color: #fff;
			opacity: 0;
			transition: opacity 0.3s ease, background 0.2s;
			border: 1px solid var(--border);
		}

		.hover-trigger:hover {
			opacity: 1;
			background: rgba(255, 255, 255, 0.15);
		}

		#trigger-left {
			left: 0;
			border-radius: 0 15px 0 0;
			/* Adjusted for bottom left */
		}

		#trigger-right {
			right: 0;
			border-radius: 15px 0 0 0;
			/* Adjusted for bottom right */
		}

		/* Ensure triggers only appear when collapsed */
		body.collapsed .hover-trigger {
			display: flex;
		}

		body.dock-left #ghost-restore {
			right: auto;
			left: 15px;
		}

		body.collapsed #ghost-restore {
			display: flex;
		}

		#main {
			flex: 1;
			padding: 10px;
			display: flex;
			gap: 40px;
			/* Wider gap for cleaner storyboard look */
			transition: width 0.3s ease;
			height: 100vh;
			order: 1;
			flex-direction: var(--h-dir);
			align-items: center;
			/* Center images vertically in horizontal mode */
			overflow-x: auto;
			overflow-y: hidden;
			flex-wrap: nowrap;

			/* Horizontal Centering Padding */
			padding-left: calc(50vw - (var(--sidebar-w) / 2) - 150px);
			padding-right: 50vw;

			scroll-behavior: smooth;
			/* Ensure the container transitions smoothly if padding changes */
			transition: padding 0.5s ease;
		}

		/* Ensure vertical mode keeps its original padding */
		body.max-width #main {
			padding: 20px;
			padding-bottom: 40vh;
			/* Adds empty space at the bottom so the last card can scroll up to the middle */
			flex-direction: column;
			align-items: center;
			overflow-y: auto;
			overflow-x: hidden;
		}



		.card {
			position: relative;
			border: 3px solid rgba(255, 255, 255, 0.4);
			border-radius: 14px;
			flex-shrink: 0;
			height: 98vh;
			overflow: hidden;
			background: transparent;
			transition: opacity 0.3s ease, box-shadow 0.3s ease;
			transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
			/* Smoothly slides existing cards */
			animation: cardEntrance 0.6s cubic-bezier(0.23, 1, 0.32, 1) both;
			/* Arrival animation */
			box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
			display: inline-block;
			transition: transform 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
		}

		/* The active/centered card style */
		.card.is-centered {
			border-color: rgba(255, 255, 255, 1);
			/* Pure white border */
			box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
			/* Soft glow */
			transform: scale(1.02);
			/* Slight pop-out effect */
			z-index: 10;
		}

		/* Keyframes for the new card appearing */
		@keyframes cardEntrance {
			0% {
				opacity: 0;
				transform: scale(0.8) translateY(20px);
				filter: blur(10px);
			}

			100% {
				opacity: 1;
				transform: scale(1) translateY(0);
				filter: blur(0);
			}
		}

		body.max-width .card {
			width: 98%;
			height: auto;
			margin-bottom: 20px;
		}

		.card img {
			height: 100%;
			width: auto;
			object-fit: contain;
			display: block;
		}

		body.max-width .card img {
			width: 100%;
			height: auto;
		}

		.card.pinned {
			border-color: var(--gold);
			box-shadow: 0 0 25px rgba(255, 215, 0, 0.4);
		}

		.card-tools {
			position: absolute;
			top: 15px;
			right: 15px;
			display: flex;
			gap: 8px;
			z-index: 100;
		}

		.tool-btn {
			background: rgba(0, 0, 0, 0.1);
			color: rgba(255, 255, 255, 0.1);
			border: 1px solid rgba(255, 255, 255, 0.1);
			width: 36px;
			height: 36px;
			cursor: pointer;
			border-radius: 8px;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 16px;
			text-decoration: none;
		}

		.tool-btn:hover {
			border: 1px solid rgba(255, 255, 255, 0.8);
			color: rgba(255, 255, 255, 0.8);
		}

		.import-btn {
			background: var(--gold);
			color: #000;
			border: none;
			padding: 8px;
			border-radius: 4px;
			cursor: pointer;
			font-family: monospace;
			font-weight: bold;
			width: 100%;
		}

		.css-grid {
			width: 14px;
			height: 14px;
			display: grid;
			grid-template-columns: 1fr 1fr;
			grid-template-rows: 1fr 1fr;
			gap: 2px;
		}

		.css-grid div {
			border: 1.5px solid currentColor;
			border-radius: 1px;
		}

		.css-list {
			width: 14px;
			height: 14px;
			display: flex;
			flex-direction: column;
			justify-content: space-between;
			padding: 1px 0;
		}

		.css-list div {
			height: 2px;
			background: currentColor;
			width: 100%;
			border-radius: 1px;
		}

		.css-mag {
			width: 14px;
			height: 14px;
			border: 2px solid currentColor;
			border-radius: 50%;
			position: relative;
		}

		.css-mag::after {
			content: "";
			position: absolute;
			top: 11px;
			left: 11px;
			width: 6px;
			height: 2px;
			background: currentColor;
			transform: rotate(45deg);
			transform-origin: top left;
		}

		.css-wall {
			width: 12px;
			height: 12px;
			border: 2px solid currentColor;
			border-radius: 50% 50% 50% 0;
			transform: rotate(-45deg);
			position: relative;
			top: -2px;
		}

		.header-bar {
			padding: 5px 15px;
			display: flex;
			flex-direction: column;
			width: 100%;
		}

		.btn-group {
			display: flex;
			gap: 8px;
			/* Slightly wider gap for better touch/click targets */
			margin-bottom: 10px;
			justify-content: center;
			/* Centers the buttons horizontally */
			width: 100%;
			/* Ensures the group spans the sidebar width */
		}

		/* Ensure buttons within the group don't stretch */
		.btn-group .sq-btn {
			flex: 0 0 auto;
		}

		.sq-btn {
			background: var(--accent);
			border: none;
			width: 40px;
			height: 40px;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 18px;
			color: #000 !important;
			border-radius: 8px;
			flex-shrink: 0;
			transition: all 0.2s;
			text-decoration: none;
		}

		.sq-btn.dim {
			background: rgba(255, 255, 255, 0.1);
			color: var(--text-dim) !important;
		}

		.sq-btn.active-gold {
			background: var(--gold);
			color: #000 !important;
		}

		/* Centers the wallpaper icon inside the sidebar square button */
		.sq-btn .css-wall {
			margin: 0 auto;
			transform: rotate(-45deg) scale(1.2);
			/* Slightly larger for the sidebar */
		}

		#settings-panel {
			background: rgba(10, 10, 10, 0.9);
			/* Increased opacity for readability */
			border: 1px solid var(--border);
			padding: 15px;
			display: none;
			flex-direction: column;
			gap: 12px;
			font-size: 10px;
			border-radius: 12px;
			backdrop-filter: blur(15px);
			box-shadow: 0 -10px 20px rgba(0, 0, 0, 0.5);

			/* Anchor it to the bottom of the sidebar area */
			position: absolute;
			bottom: 60px;
			/* Sits exactly above the footer buttons */
			left: 10px;
			right: 10px;
			width: calc(100% - 20px);
			/* Stays within sidebar width */
			z-index: 10002;
		}



		.unified-width {
			width: 100%;
			background: rgba(255, 255, 255, 0.0);
			color: #fff;
			border: 1px solid var(--border);
			font-family: monospace;
			outline: none;
			border-radius: 6px;
			padding: 8px;
		}

		#tag-cloud {
			display: flex;
			flex-wrap: wrap;
			gap: 4px;
			padding: 5px 15px;
			border-bottom: 1px solid var(--border);
			max-height: 25vh;
			overflow-y: auto;
		}

		.tag-pill {
			background: rgba(0, 0, 0, 0.5);
			color: var(--text-dim);
			padding: 4px 8px;
			border: 1px solid var(--border);
			font-size: 10px;
			cursor: pointer;
			border-radius: 4px;
		}

		.tag-pill.active {
			background: var(--accent);
			color: #000 !important;
		}

		.tag-count-small {
			opacity: 0.5;
			font-size: 9px;
		}

		.action-btn {
			background: rgba(255, 255, 255, 0.1) !important;
			color: var(--text-dim) !important;
			border: 1px solid var(--border) !important;
			opacity: 0.7;
		}

		.action-btn:hover {
			background: rgba(255, 255, 255, 0.2) !important;
			color: #fff !important;
			opacity: 1;
		}

		/* Current State: Solid/Bright */
		.state-active {
			background: var(--accent) !important;
			color: #000 !important;
			opacity: 1 !important;
		}

		.stats-bar {
			display: flex;
			align-items: center;
			justify-content: space-between;
			padding: 8px 15px;
			background: rgba(0, 0, 0, 0.3);
			border-bottom: 1px solid var(--border);
			font-size: 14px;
		}

		.stats-clickable {
			cursor: pointer;
			white-space: nowrap;
			/* Prevents text from wrapping */
			flex-shrink: 0;
			/* Prevents the label from being squashed */
			width: fit-content;
			/* Only takes the space of the words */
		}

		.stats-clickable:hover {
			color: #fff;
		}

		/* Centering logic for Tags Bar */
		.stats-bar.tags-bar {
			display: flex;
			align-items: center;
			gap: 10px;
			padding: 8px 15px;
		}

		.stats-bar-spacer {
			width: 32px;
			flex-shrink: 0;
		}

		.version-code {
			font-size: 9px;
			color: var(--text-dim);
			opacity: 0.6;
			font-family: monospace;
			flex-grow: 1;
			text-align: center;
		}

		.bakery-link {
			color: var(--text-dim);
			text-decoration: none;
			font-size: 14px;
			transition: color 0.2s;
			cursor: help;
			/* Indicates hoverable info */
		}

		.bakery-link:hover {
			color: var(--gold);
		}

		/* Matches Sort button width */
		.tags-bar-center {
			display: flex;
			align-items: center;
			justify-content: center;
			flex-grow: 1;
			gap: 8px;
			overflow: hidden;
		}

		.inline-toggle {
			background: transparent;
			border: 1px solid var(--border);
			color: var(--text-dim);
			cursor: pointer;
			border-radius: 4px;
			padding: 4px 6px;
			display: flex;
			align-items: center;
			transition: all 0.2s;
			font-size: 10px;
			min-width: 32px;
			justify-content: center;
		}

		.inline-toggle:hover {
			border-color: var(--accent);
			color: #fff;
		}

		/* Ensure the image container grows to fill all vertical space */
		#collapsible-images {
			flex: 1;
			display: flex;
			/* Default to flex so it fills space */
			flex-direction: column;
			overflow: hidden;
			min-height: 0;
			background: rgba(0, 0, 0, 0.2);
			/* Matching the stage-tools/collections background */
		}

		#file-list {
			flex: 1;
			overflow-y: auto;
			width: 100%;
		}

		#stage-tools,
		#collapsible-collections {
			display: none;
			padding: 10px 15px;
			gap: 8px;
			flex-direction: column;
			border-bottom: 1px solid var(--border);
			background: rgba(0, 0, 0, 0.2);
		}

		#master-search {
			flex: 1;
			/* This makes the search box grow to fill all available space */
			min-width: 50px;
			/* Prevents it from disappearing on tiny screens */
			text-align: center;
			background: rgba(255, 255, 255, 0.05);
			border: 1px solid var(--border);
			color: #fff;
			border-radius: 6px;
			padding: 6px;
			outline: none;
			transition: border-color 0.2s;
		}

		#master-search:focus {
			border-color: var(--accent);
		}

		/* Ensure the label and button don't shrink */
		.tags-bar .stats-clickable,
		#tag-sort-btn {
			flex-shrink: 0;
		}

		/* Collection Path List Styles */
		#path-list-container {
			display: flex;
			flex-direction: column;
			gap: 4px;
			margin-top: 5px;
			max-height: 150px;
			overflow-y: auto;
			padding-right: 4px;
		}

		.path-entry {
			display: flex;
			align-items: center;
			gap: 6px;
			background: rgba(255, 255, 255, 0.05);
			padding: 4px;
			border-radius: 4px;
		}

		.path-entry input[type="text"] {
			flex: 1;
			background: transparent;
			border: none;
			color: var(--text-dim);
			font-size: 9px;
			pointer-events: none;
		}

		.path-entry input[type="checkbox"] {
			cursor: pointer;
			width: 16px;
			height: 16px;
			accent-color: var(--gold);
		}

		.path-entry.stale input[type="checkbox"] {
			accent-color: var(--gold);
		}

		.path-entry.loaded input[type="checkbox"] {
			accent-color: var(--green);
		}

		.path-text {
			flex: 1;
			background: transparent;
			border: none;
			color: var(--text-dim);
			font-size: 10px;
			cursor: pointer;
			/* Updated for full path visibility */
			word-break: break-all;
			/* Breaks long strings like URLs */
			white-space: normal;
			/* Allows wrapping to new lines */
			line-height: 1.2;
			padding: 2px 0;
		}

		.path-entry {
			display: flex;
			align-items: flex-start;
			/* Align checkbox/trash to the top of wrapped text */
			gap: 6px;
			background: rgba(255, 255, 255, 0.05);
			padding: 6px;
			border-radius: 4px;
			margin-bottom: 2px;
		}

		.path-text:hover {
			color: #fff;
			text-decoration: underline;
		}

		.trash-btn {
			background: transparent;
			border: none;
			color: #ff4444;
			cursor: pointer;
			font-size: 12px;
			padding: 2px 6px;
			opacity: 0.7;
		}

		.trash-btn:hover {
			opacity: 1;
		}

		.file-list {
			flex: 1;
			overflow-y: auto;
		}

		.grid-view {
			display: grid !important;
			grid-template-columns: repeat(var(--grid-cols), 1fr) !important;
			grid-auto-rows: min-content;
			gap: 6px;
			padding: 8px;
		}

		.grid-view .file-item {
			padding: 0;
			border: 1px solid var(--border);
			aspect-ratio: 1/1;
			border-radius: 6px;
			position: relative;
			overflow: hidden;
			display: block;
		}

		.grid-view .file-item img {
			width: 100%;
			height: 100%;
			object-fit: cover;
			position: absolute;
			top: 0;
			left: 0;
		}

		.grid-view .active-item {
			border: 5px solid var(--gold) !important;
			z-index: 10;
			transform: scale(1.02);
		}

		.file-item {
			padding: 10px 15px;
			border-bottom: 1px solid rgba(255, 255, 255, 0.05);
			font-size: 11px;
			cursor: pointer;
			color: var(--text-dim);
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.active-item {
			color: var(--gold) !important;
			font-weight: bold;
			background: rgba(255, 215, 0, 0.1);
		}

		.card-tag-overlay {
			display: none;
			/* Controlled by toggleOverlay */
			position: absolute;
			top: 55px;
			/* Positions it just below the card-tools buttons */
			right: 15px;
			width: 200px;
			/* Constrains the width to a small side frame */
			max-height: 70%;
			flex-wrap: wrap;
			gap: 5px;
			padding: 10px;
			background: rgba(0, 0, 0, 0.85);
			border: 1px solid var(--border);
			border-radius: 8px;
			z-index: 101;
			/* Above the image but below main sidebar */
			overflow-y: auto;
			backdrop-filter: blur(10px);
		}

		#grid-slider-container {
			display: none;
			/* JavaScript toggles this to 'flex' */
			align-items: center;
			margin-left: 15px;
			/* Space after "Images" text */
			margin-right: 15px;
			/* Space before the grid button */
			flex: 1;
			/* Fills the entire gap */
			min-width: 0;
		}

		#col-slider {
			-webkit-appearance: none;
			width: 100%;
			/* Slider stretches to fill the whole container */
			height: 4px;
			background: var(--border);
			border-radius: 2px;
			outline: none;
			cursor: pointer;
			accent-color: var(--accent);
		}

		#grid-toggle-btn {
			flex-shrink: 0;
			/* Keeps the button square and fixed to the right */
		}

		#col-slider::-webkit-slider-thumb {
			-webkit-appearance: none;
			width: 12px;
			height: 12px;
			background: var(--accent);
			border-radius: 50%;
			cursor: pointer;
		}


		/* 1. Base style for the Scroll Direction button */
		#mode-toggle {
			background: rgba(255, 255, 255, 0.1) !important;
			/* Semi-transparent */
			color: #fff !important;
			/* Current direction in White */
			border: 1px solid var(--border) !important;
			transition: all 0.2s ease;
		}

		/* 2. Hover state: Border turns white */
		#mode-toggle:hover {
			border-color: #fff !important;
			background: rgba(255, 255, 255, 0.2) !important;
		}


		/* Center the character containers perfectly */
		.icon-h,
		.icon-v {
			display: flex;
			align-items: center;
			justify-content: center;
			width: 24px;
			/* Fixed width to prevent shifting */
			height: 24px;
			/* Fixed height to prevent shifting */
			font-size: 24px;
			font-weight: bold;
			color: #fff;
			line-height: 0;
			/* Strips font-specific vertical padding */
			pointer-events: none;
			user-select: none;
			margin: 0 auto;
			/* Centers the div within the square button */
		}

		/* Horizontal Dash centering */
		.icon-h::before {
			content: '—';
			transform: translateY(-2px);
			/* Corrects the typical 'sink' of a dash */
		}

		/* Vertical Pipe centering */
		.icon-v::before {
			content: '|';
			transform: translateX(0);
			/* Ensure no horizontal bias */
		}

		/* Hover Preview Logic: Ensure previews use the same offsets as active states */
		#mode-toggle:hover .icon-h::before {
			content: '|';
			opacity: 0.7;
			transform: translateY(0);
			/* Remove the dash-specific vertical shift */
		}

		#mode-toggle:hover .icon-v::before {
			content: '—';
			opacity: 0.7;
			transform: translateY(-2px);
			/* Apply the dash-specific vertical shift */
		}


		/* CSS Star Icon */
		/* Perfect 5-Point Star using Clip-Path */
		.icon-star {
			width: 20px;
			height: 20px;
			background: currentColor;
			clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
		}

		.icon-star::after {
			content: "";
			position: absolute;
			top: 6px;
			left: -10px;
			border-left: 10px solid transparent;
			border-right: 10px solid transparent;
			border-top: 18px solid currentColor;
		}

		/* When the card is pinned, turn the star button gold and solid */
.card.pinned .pin-btn {
    color: var(--gold) !important;
    background: rgba(0, 0, 0, 0.4); /* Slightly darker background to pop the gold */
    border-color: var(--gold);
}

/* Ensure that when NOT pinned, the star stays semi-transparent even on the 'centered' card */
.pin-btn {
    color: rgba(255, 255, 255, 0.1) !important;
}

/* Hovering over the star should still make it visible */
.pin-btn:hover {
    color: rgba(255, 255, 255, 0.8) !important;
}

		

		/* Simple Perfect Circle Icon */
		.icon-circle {
			width: 14px;
			height: 14px;
			border: 2px solid currentColor;
			/* Matches the button's text color */
			border-radius: 50%;
			display: inline-block;
			background: transparent;
			/* Hollow circle */
		}

		/* Optional: Solid circle on hover */
		.action-btn:hover .icon-circle {
			background: currentColor;
		}
	</style>
</head>

<body id="body-wrap" contenteditable="false">
	<div id="trigger-left" class="hover-trigger" onclick="handleCornerClick('left')">☰</div>
	<div id="trigger-right" class="hover-trigger" onclick="handleCornerClick('right')">☰</div>
	<div id="toast"></div>
	<div id="ghost-restore" onclick="toggleSidebar(true)">☰</div>

	<div id="sidebar">
		<div class="stats-bar">
			<div class="stats-clickable" onclick="toggleCollections()">Collections (<span id="collection-count">0</span>)
			</div>
			<a href="https://magicbakery.github.io/?id=P202512210026" target="_blank" class="bakery-link"
				id="version-link">ⓘ</a>
		</div>
		<div id="collapsible-collections">




			<input type="file" id="json-input" style="display:none" accept=".json" onchange="importJSON(this)">
			<div style="display:flex; gap:4px;">
				<button class="import-btn action-btn" style="width: 32px;" onclick="smartImport()">+</button>
				<button class="import-btn action-btn" style="flex: 1;" onclick="exportFilteredData()">EXPORT JSON</button>
				<button class="import-btn action-btn" style="flex: 1;" onclick="exportGallery()">EXPORT HTML</button>
			</div>
			<div id="path-list-container"></div>
		</div>




		<div class="stats-bar tags-bar">
			<span class="stats-clickable" onclick="toggleTagCloud()">Tags (<span id="tag-count">0</span>)</span>
			<input type="text" id="master-search" class="unified-width" style="width:100px; text-align:center"
				placeholder="SEARCH..." oninput="refreshAllUI()">
			<button class="inline-toggle" id="tag-sort-btn" onclick="toggleTagSort()">A-Z</button>
		</div>
		<div id="collapsible-tags">
			<div id="tag-cloud"></div>
		</div>

		<div class="stats-bar">
			<div class="stats-clickable" onclick="toggleImages()">Images (<span id="img-count">0</span>)</div>
			<div id="grid-slider-container">
				<input type="range" id="col-slider" min="1" max="5" value="3" oninput="updateGridCols(this.value)">
			</div>
			<button class="inline-toggle" id="grid-toggle-btn" onclick="toggleSidebarView()">
				<div class="css-grid" id="toggle-icon">
					<div></div>
					<div></div>
					<div></div>
					<div></div>
				</div>
			</button>
		</div>
		<div id="collapsible-images"
			style="flex: 1; display: flex; flex-direction: column; overflow: hidden; background: rgba(0,0,0,0.2);">
			<div id="file-list" class="file-list"></div>
		</div>



		<div class="stats-bar">
			<div class="stats-clickable" onclick="toggleStageTools()">Staging (<span id="stage-count">0</span>)</div>
			<button class="inline-toggle" onclick="clearWorkspace()">✕</button>
		</div>
		<div id="stage-tools">
			<div class="btn-group">
				<button class="sq-btn dim" onclick="moveCurrentCard(-1)" title="Move Left/Up">&#9664;</button>
				<button class="sq-btn state-active" id="mode-toggle" onclick="cycleViewMode()" title="Scroll Direction">
					<div class="icon-h"></div>
				</button>
				<button class="sq-btn dim" onclick="moveCurrentCard(1)" title="Move Right/Down">&#9654;</button>
			</div>
		</div>

		<div id="settings-panel" style="display: none;">

			<div style="display:flex; gap:5px; align-items:center;">
				<a id="add-btn" href="#" target="_blank" class="sq-btn action-btn" onclick="handleLinkAction(event)">+</a>
				<input type="text" id="add-url-input" class="unified-width" placeholder="URL for + button..."
					oninput="updateAddUrl(this.value)">
			</div>
			<textarea id="user-note" class="unified-width" style="height:80px; margin-bottom:10px;" placeholder="NOTES..."
				oninput="saveNotes(this.value)"></textarea>
		</div>

		<div class="header-bar" style="border-top: 1px solid var(--border); padding-top: 10px;">
			<div class="btn-group">
				<button id="auto-flush-btn" class="sq-btn action-btn" onclick="toggleAutoFlush()">↻</button>
				<button class="sq-btn action-btn" id="settings-btn" onclick="toggleSettings()">
					<div class="icon-circle"></div>
				</button>
				<button class="sq-btn action-btn" onclick="setCenteredAsWallpaper()" title="Set Center as Wallpaper">
					<div class="css-wall"></div>
				</button>
			</div>
		</div>



	</div>
	<div id="main"></div>

	<script>
		// --- UPDATE VERSION HERE (#Version)---
		const APP_VERSION = "20251224172300";
		// ---------------------------
		let DATA = [];
		let ALL_TAGS = [];
		let activeTags = new Set(), sidebarIsGrid = false, currentDock = 'right', autoFlush = false;
		let tagSortMode = 'alpha', savedPaths = [];

		window.onload = () => {
			// Inject the version code into the info link tooltip
			document.getElementById('version-link').title = "Ver." + APP_VERSION;

			// 1. Tag Sort Initialization (Future State)
			tagSortMode = localStorage.getItem('gallery_tag_sort') || 'alpha';
			const tagBtn = document.getElementById('tag-sort-btn');
			tagBtn.innerText = (tagSortMode === 'alpha') ? '1-9' : 'A-Z';
			tagBtn.className = 'inline-toggle action-btn';

			// 2. View Mode Initialization (Future State / Reversed)
			const savedMax = localStorage.getItem('gallery_is_max_width') === 'true';
			const bodyWrap = document.getElementById('body-wrap');
			const btn = document.getElementById('mode-toggle');

			if (savedMax) {
				bodyWrap.classList.add('max-width');
				if (btn) btn.innerHTML = '<div class="icon-v"></div>';
			} else {
				bodyWrap.classList.remove('max-width');
				if (btn) btn.innerHTML = '<div class="icon-h"></div>';
			}

			persistentWallpaper();

			// 3. Restore Sidebar Docking
			currentDock = localStorage.getItem('gallery_dock') || 'right';
			updateDock(currentDock);

			// 4. Restore Settings & Notes
			const n = localStorage.getItem('gallery_notes');
			if (n) document.getElementById('user-note').value = n;

			autoFlush = localStorage.getItem('gallery_flush') === 'true';
			updateAutoFlushUI();



			// Restore Grid Columns
			const savedCols = localStorage.getItem('gallery_cols') || 3;
			document.documentElement.style.setProperty('--grid-cols', savedCols);
			document.getElementById('col-slider').value = savedCols;



			// Set initial slider visibility
			const container = document.getElementById('grid-slider-container');
			const icon = document.getElementById('toggle-icon');

			if (sidebarIsGrid) {
				container.style.display = 'flex';
				icon.className = 'css-list';
				icon.innerHTML = '<div></div><div></div><div></div>';
			} else {
				container.style.display = 'none';
				icon.className = 'css-grid';
				icon.innerHTML = '<div></div><div></div><div></div><div></div>';
			}


			const savedAddUrl = localStorage.getItem('gallery_add_url');
			if (savedAddUrl) {
				document.getElementById('add-url-input').value = savedAddUrl;
				document.getElementById('add-btn').href = savedAddUrl;
			}

			// Restore or initialize Collections
			const rawPaths = localStorage.getItem('gallery_paths');
			if (rawPaths) {
				savedPaths = JSON.parse(rawPaths).map(p => ({ ...p, data: null }));
			} else {
				// DEFAULT PATH: Starter Pack
				savedPaths = [{
					path: "https://magicbakery.github.io/starterpack.json",
					checked: true,
					data: null
				}];
			}

			renderPathList();
			// Load data for all checked paths
			savedPaths.forEach((item, index) => {
				if (item.checked && (item.path.startsWith('http'))) {
					importFromURL(item.path);
				}
			});
		};

		function moveCurrentCard(direction) {
			const main = document.getElementById('main');
			const centeredCard = main.querySelector('.card.is-centered');

			if (!centeredCard) return;

			if (direction === -1) {
				// Move Left/Up: Insert before the previous sibling
				const prev = centeredCard.previousElementSibling;
				if (prev && prev.classList.contains('card')) {
					main.insertBefore(centeredCard, prev);
				}
			} else if (direction === 1) {
				// Move Right/Down: Insert after the next sibling
				const next = centeredCard.nextElementSibling;
				if (next && next.classList.contains('card')) {
					// insertBefore(node, nextNext) effectively moves it after next
					main.insertBefore(next, centeredCard);
				}
			}

			// After moving, re-center the view on the same card immediately
			setTimeout(() => {
				centeredCard.scrollIntoView({
					behavior: 'smooth',
					block: 'center',
					inline: 'center'
				});

				// Refresh UI if you have counters or specific ordering logic
				if (typeof refreshAllUI === "function") refreshAllUI();
			}, 50);
		}

		function persistentWallpaper() {
			const savedWallpaper = localStorage.getItem('gallery_wallpaper');
			const defaultWallpaper = "https://substackcdn.com/image/fetch/$s_!KRIG!,w_720,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc5630f5a-5397-4ad1-b713-9ade6321e486_1536x1024.jpeg";
			const b = document.body;

			// Apply the image logic
			if (savedWallpaper) {
				b.style.backgroundImage = `url("${savedWallpaper}")`;
			} else {
				b.style.backgroundImage = `url("${defaultWallpaper}")`;
			}


		}
		function setCenteredAsWallpaper() {
			// Find the card currently highlighted as center
			const centeredCard = document.querySelector('.card.is-centered');

			if (centeredCard) {
				const path = centeredCard.dataset.path;
				// Call your existing setWallpaper function
				// We pass 'null' for the event since there is no click event to prevent
				setWallpaper(path, null);
			} else {
				// Optional: show a toast if no card is found
				showToast("No image centered");
			}
		}
		function setWallpaper(url, e) {
			if (e) e.preventDefault();
			const b = document.body;

			// Check if we are clearing the wallpaper or setting a new one
			if (b.style.backgroundImage.includes(url)) {
				b.style.backgroundImage = 'none';
				localStorage.removeItem('gallery_wallpaper');
			} else {
				b.style.backgroundImage = `url("${url}")`;
				localStorage.setItem('gallery_wallpaper', url);
			}
		}

		async function smartImport() {
			let clipboardText = "";
			try {
				// 1. Try to read the clipboard
				clipboardText = await navigator.clipboard.readText();
				clipboardText = clipboardText ? clipboardText.trim() : "";
			} catch (err) {
				console.warn("Clipboard access denied, defaulting to file picker.");
			}

			// 2. Decision: Is it a Web URL?
			if (clipboardText.startsWith('http://') || clipboardText.startsWith('https://')) {
				showToast("URL detected in clipboard. Importing...");
				importFromURL(clipboardText);
			} else {
				// 3. Fallback: Open the local file dialog
				document.getElementById('json-input').click();
			}
		}

		async function importFromURL(url) {
			try {
				const response = await fetch(url);
				if (!response.ok) throw new Error(`HTTP ${response.status}`);
				const importedData = await response.json();

				const pathName = url;
				const existingIndex = savedPaths.findIndex(p => p.path === pathName);

				if (existingIndex === -1) {
					savedPaths.push({ path: pathName, checked: true, data: importedData });
				} else {
					savedPaths[existingIndex].data = importedData;
					savedPaths[existingIndex].checked = true;
				}

				renderPathList();
				loadActiveCollections();
				showToast(`Loaded: ${pathName.split('/').pop()}`);
			} catch (err) {
				showToast("Web Import Failed: " + err.message);
				// If web import fails, maybe the user actually wanted the file picker
				document.getElementById('json-input').click();
			}
		}
		function toggleImages() {
			const i = document.getElementById('collapsible-images');
			// Toggle between none and flex so it maintains its space-filling behavior
			i.style.display = (i.style.display === 'none') ? 'flex' : 'none';
			refreshAllUI();
		}
		function toggleOverlay(btn) {
			const card = btn.closest('.card');
			const overlay = card.querySelector('.card-tag-overlay');

			// Toggle between none and flex
			if (overlay.style.display === 'flex') {
				overlay.style.display = 'none';
			} else {
				overlay.style.display = 'flex';
				// Ensure the overlay content is up to date
				updateAllCardOverlays();
			}
		}
		function togglePathCheck(index) {
			savedPaths[index].checked = !savedPaths[index].checked;
			renderPathList();
			loadActiveCollections();
		}
		function toggleSettings() {
			const s = document.getElementById('settings-panel');
			// Toggle between 'none' and 'flex'
			if (s.style.display === 'none' || s.style.display === '') {
				s.style.display = 'flex';
			} else {
				s.style.display = 'none';
			}
		}
		function removePath(index) {
			savedPaths.splice(index, 1);
			renderPathList();
			loadActiveCollections();
		}
		function loadActiveCollections() {
			let combined = [];
			savedPaths.forEach(item => {
				if (item.checked && item.data) {
					combined = combined.concat(Array.isArray(item.data) ? item.data : [item.data]);
				}
			});

			// Fast duplicate removal using a Map
			const uniqueMap = new Map();
			combined.forEach(item => uniqueMap.set(item.p, item));
			DATA = Array.from(uniqueMap.values());

			// ADD THIS SECTION: Update the global tag list
			const tags = new Set();
			DATA.forEach(item => {
				if (item.t && Array.isArray(item.t)) {
					item.t.forEach(tag => tags.add(tag));
				}
			});
			ALL_TAGS = Array.from(tags).sort(); // Update the cloud source

			refreshAllUI();
		}


		function importJSON(input) {
			const file = input.files[0];
			if (!file) return;
			const reader = new FileReader();
			reader.onload = (e) => {
				try {
					const importedData = JSON.parse(e.target.result);

					// Use webkitRelativePath if available, otherwise fallback to name
					const pathName = file.webkitRelativePath || file.name;

					const existingIndex = savedPaths.findIndex(p => p.path === pathName);
					if (existingIndex === -1) {
						savedPaths.push({ path: pathName, checked: true, data: importedData });
					} else {
						savedPaths[existingIndex].data = importedData;
						savedPaths[existingIndex].checked = true;
					}

					renderPathList();
					loadActiveCollections();
					showToast(`Imported: ${pathName}`);
				} catch (err) {
					showToast("Error: Invalid JSON");
				}
				input.value = "";
			};
			reader.readAsText(file);
		}

		function renderPathList() {
			const container = document.getElementById('path-list-container');
			if (!container) return;
			container.innerHTML = '';

			// Calculate the counts for the header display
			const greenCount = savedPaths.filter(p => p.data !== null).length;
			const totalCount = savedPaths.length;

			// Update the UI with the "Green / Total" format
			document.getElementById('collection-count').innerText = `${greenCount}/${totalCount}`;

			savedPaths.forEach((item, index) => {
				const isLoaded = item.data !== null;
				const div = document.createElement('div');
				// Apply 'loaded' class if data exists (green), 'stale' if checked but no data (yellow)
				div.className = `path-entry ${isLoaded ? 'loaded' : (item.checked ? 'stale' : '')}`;

				div.innerHTML = `
            <input type="checkbox" ${item.checked ? 'checked' : ''} onchange="togglePathCheck(${index})">
            <div class="path-text" onclick="handlePathClick(${index})">${item.path}</div>
            <button class="inline-toggle action-btn" onclick="removePath(${index})">✕</button>
        `;
				container.appendChild(div);
			});

			// Save metadata to local storage
			const metadata = savedPaths.map(p => ({ path: p.path, checked: p.checked }));
			localStorage.setItem('gallery_paths', JSON.stringify(metadata));
		}

		async function handlePathClick(index) {
			const path = savedPaths[index].path;
			const isURL = path.startsWith('http://') || path.startsWith('https://');

			if (isURL) {
				showToast("Fetching data from URL...");
				await importFromURL(path);
			} else {
				try {
					await navigator.clipboard.writeText(path);
					showToast("Path copied. Paste into file picker.");
					document.getElementById('json-input').click();
				} catch (err) {
					showToast("Clipboard failed. Opening picker...");
					document.getElementById('json-input').click();
				}
			}
		}

		function showToast(msg) {
			const t = document.getElementById('toast');
			t.innerText = msg;
			t.classList.add('show');
			setTimeout(() => t.classList.remove('show'), 2500);
		}
		function updateCenteredCard() {
			const m = document.getElementById('main');
			const isVertical = document.getElementById('body-wrap').classList.contains('max-width');
			const cards = m.querySelectorAll('.card');

			// Find the midpoint of the visible viewport
			const centerX = m.scrollLeft + (m.clientWidth / 2);
			const centerY = m.scrollTop + (m.clientHeight / 2);

			let closestCard = null;
			let minDistance = Infinity;

			cards.forEach(card => {
				card.classList.remove('is-centered');

				// Midpoints of the card relative to the scroll container
				const midX = card.offsetLeft + (card.offsetWidth / 2);
				const midY = card.offsetTop + (card.offsetHeight / 2);

				// Calculate distance based on current mode
				const dist = isVertical ? Math.abs(centerY - midY) : Math.abs(centerX - midX);

				if (dist < minDistance) {
					minDistance = dist;
					closestCard = card;
				}
			});

			if (closestCard) {
				closestCard.classList.add('is-centered');
			}
		}
		function updateStageCount() {
			const count = document.querySelectorAll('.card').length;
			document.getElementById('stage-count').innerText = count;
		}
		function syncSidebarHighlights() {
			const activePaths = Array.from(document.querySelectorAll('.card')).map(c => c.dataset.path);
			document.querySelectorAll('.file-item').forEach(item => {
				const itemPath = item.dataset.path;
				item.classList.toggle('active-item', activePaths.includes(itemPath));
			});
			updateStageCount();
		}

		function createCard(item) {
			const m = document.getElementById('main');
			const isVertical = document.getElementById('body-wrap').classList.contains('max-width');

			// Duplicate check
			const existing = Array.from(document.querySelectorAll('.card')).find(c => c.dataset.path === item.p);
			if (existing) {
				if (existing.classList.contains('pinned')) {
					existing.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
				} else {
					existing.remove();
					syncSidebarHighlights();
				}
				return;
			}

			if (autoFlush) {
				document.querySelectorAll('.card').forEach(c => {
					if (!c.classList.contains('pinned')) c.remove();
				});
			}

			const c = document.createElement('div');
			c.className = 'card';
			c.dataset.path = item.p;
			c.innerHTML = `
        <div class="card-tools">
          <button class="tool-btn pin-btn" title="Star"><div class="icon-star"></div></button>
          <button class="tool-btn" onclick="toggleOverlay(this)">#</button>
          
          
          <button class="tool-btn" onclick="this.closest('.card').remove(); syncSidebarHighlights();" title="Close">✕</button>
        </div>
        <div class="card-tag-overlay"></div>
        <img src="${item.p}" onerror="handleMissingImage(this, '${item.p}')">`;

			c.querySelector('.pin-btn').onclick = function () {
				this.style.color = c.classList.toggle('pinned') ? 'var(--gold)' : 'white';
			};

			const cards = Array.from(m.querySelectorAll('.card'));

			// --- UPDATED INSERTION LOGIC ---
			if (cards.length === 0) {
				m.appendChild(c);
			} else {
				// Find the center point of the container
				const centerX = m.scrollLeft + (m.clientWidth / 2);
				const centerY = m.scrollTop + (m.clientHeight / 2);

				let closestCard = cards[0];
				let minDistance = Infinity;

				cards.forEach(card => {
					// Calculate center of card relative to the container
					const midX = card.offsetLeft + (card.offsetWidth / 2);
					const midY = card.offsetTop + (card.offsetHeight / 2);

					// Choose distance metric based on current mode
					const dist = isVertical ? Math.abs(centerY - midY) : Math.abs(centerX - midX);

					if (dist < minDistance) {
						minDistance = dist;
						closestCard = card;
					}
				});

				if (currentDock === 'left') {
					closestCard.insertAdjacentElement('beforebegin', c);
				} else {
					closestCard.insertAdjacentElement('afterend', c);
				}
			}


			// --- UPDATED SCROLL LOGIC ---
			setTimeout(() => {
				// If vertical, scroll until the new card is at the center (or bottom)
				// If horizontal, use existing centerline logic
				c.scrollIntoView({
					behavior: 'smooth',
					block: 'center',
					inline: 'center'
				});
				updateAllCardOverlays();
				syncSidebarHighlights();
				updateCenteredCard();
			}, 50);
		}

		function updateAllCardOverlays() {
			document.querySelectorAll('.card').forEach(card => {
				const path = card.dataset.path;
				const item = DATA.find(i => i.p === path);
				if (!item) return;

				const overlay = card.querySelector('.card-tag-overlay');
				overlay.innerHTML = "";
				[...item.t].sort().forEach(t => {
					const p = document.createElement('div');
					p.className = 'tag-pill';
					if (activeTags.has(t)) p.classList.add('active');
					p.innerText = t;
					p.onclick = (e) => { e.stopPropagation(); toggleTag(t); };
					overlay.appendChild(p);
				});
			});
		}

		function toggleAutoFlush() {
			autoFlush = !autoFlush;
			localStorage.setItem('gallery_flush', autoFlush);
			updateAutoFlushUI();
			showToast(autoFlush ? "Auto-Flush Enabled" : "Auto-Flush Disabled");
		}

		function updateAutoFlushUI() {
			const btn = document.getElementById('auto-flush-btn');
			btn.classList.toggle('active-gold', autoFlush); // Solid yellow when active
			btn.classList.toggle('action-btn', !autoFlush); // Semi-transparent when inactive
		}

		function toggleTagSort() {
			// 1. Switch the underlying mode
			tagSortMode = (tagSortMode === 'alpha') ? 'freq' : 'alpha';
			localStorage.setItem('gallery_tag_sort', tagSortMode);

			const btn = document.getElementById('tag-sort-btn');

			// 2. Show the FUTURE state (the opposite of current mode)
			// If current is alpha, show '1-9' (the frequency option)
			// If current is freq, show 'A-Z' (the alphabetical option)
			btn.innerText = (tagSortMode === 'alpha') ? '1-9' : 'A-Z';

			// 3. Keep it semi-transparent by ensuring only 'action-btn' is used
			btn.className = 'inline-toggle action-btn';

			refreshAllUI();
		}
		function updateTagSortUI() {
			document.getElementById('tag-sort-btn').innerText = tagSortMode === 'alpha' ? 'A-Z' : '1-9';
		}

		function refreshAllUI() {
			const q = document.getElementById('master-search').value.toLowerCase();
			const list = document.getElementById('file-list');
			list.innerHTML = "";
			list.className = "file-list" + (sidebarIsGrid ? " grid-view" : "");

			const filtered = DATA.filter(i => {
				const matchesActive = Array.from(activeTags).every(at => i.t.includes(at));
				const matchesSearch = q === "" || i.t.some(it => it.toLowerCase().includes(q));
				return matchesActive && matchesSearch;
			});

			// 1. Calculate tag frequencies in the current filtered set
			const tagFreq = {};
			filtered.forEach(i => i.t.forEach(t => tagFreq[t] = (tagFreq[t] || 0) + 1));

			// 2. Sort the cloud based on the active mode (Alpha vs Frequency)
			let sortedTags = ALL_TAGS.filter(t => t.toLowerCase().includes(q));

			if (tagSortMode === 'freq') {
				sortedTags.sort((a, b) => (tagFreq[b] || 0) - (tagFreq[a] || 0) || a.localeCompare(b));
			} else {
				sortedTags.sort((a, b) => a.localeCompare(b));
			}

			const cloud = document.getElementById('tag-cloud');
			cloud.innerHTML = "";

			sortedTags.forEach(t => {
				const count = tagFreq[t] || 0;
				if (count === 0 && activeTags.size > 0 && !activeTags.has(t)) return; // Hide empty tags if filtering

				const p = document.createElement('div');
				p.className = 'tag-pill' + (activeTags.has(t) ? ' active' : '');
				// Optional: Add a small count indicator next to the tag name
				p.innerHTML = `${t} <span class="tag-count-small">${count}</span>`;
				p.onclick = () => {
					if (activeTags.has(t)) activeTags.delete(t);
					else activeTags.add(t);
					refreshAllUI();
				};
				cloud.appendChild(p);
			});

			document.getElementById('tag-count').innerText = cloud.children.length;
			document.getElementById('img-count').innerText = filtered.length;

			// ... rest of function (file-item generation) remains same
			filtered.forEach((item, idx) => {
				const d = document.createElement('div');
				d.className = 'file-item';
				d.dataset.path = item.p;
				d.id = 'f-' + idx;
				d.innerHTML = sidebarIsGrid ? `<img src="${item.p}" loading="lazy">` : item.n;
				d.onclick = () => createCard(item);
				list.appendChild(d);
			});
			updateAllCardOverlays();
			syncSidebarHighlights();
			updateStageCount();
		}

		function clearWorkspace() {
			document.querySelectorAll('.card').forEach(c => {
				if (!c.classList.contains('pinned')) c.remove();
			});
			syncSidebarHighlights();
		}

		function exportFilteredData() {
			const q = document.getElementById('master-search').value.toLowerCase();
			const filtered = DATA.filter(i => {
				const matchesActive = Array.from(activeTags).every(at => i.t.includes(at));
				return matchesActive && (q === "" || i.t.some(it => it.toLowerCase().includes(q)));
			});
			const blob = new Blob([JSON.stringify(filtered, null, 2)], { type: 'application/json' });
			const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
			a.download = `Filtered_Data_${new Date().toISOString().slice(0, 10)}.json`; a.click();
			showToast(`Exported ${filtered.length} items.`);
		}
		function exportGallery() {
			let docClone = document.documentElement.cloneNode(true);
			let bodyWrap = docClone.querySelector('#body-wrap');
			if (bodyWrap) bodyWrap.classList.add('collapsed');

			// Ensure Meta Charset is present
			let head = docClone.querySelector('head');
			if (!head.querySelector('meta[charset]')) {
				let meta = document.createElement('meta');
				meta.setAttribute('charset', 'UTF-8');
				head.prepend(meta);
			}

			let html = docClone.outerHTML;

			// 3. Inject current data and tags
			html = html.replace(/let DATA = \[.*?\];/, `let DATA = ${JSON.stringify(DATA)};`);
			html = html.replace(/let ALL_TAGS = \[.*?\];/, `let ALL_TAGS = ${JSON.stringify(ALL_TAGS)};`);

			const blob = new Blob(['<!DOCTYPE html>\n' + html], { type: 'text/html' });
			const a = document.createElement('a');
			a.href = URL.createObjectURL(blob);
			a.download = 'Gallery_Export.html';
			a.click();
		}

		function updateStageCount() { document.getElementById('stage-count').innerText = document.querySelectorAll('.card').length; }
		// New function to handle the side-specific click
		function restoreAndDock(side) {
			updateDock(side);      // Move the sidebar to clicked side
			toggleSidebar(true);   // Show the sidebar
		}
		function handleCornerClick(clickedSide) {
			const bodyWrap = document.getElementById('body-wrap');
			const isCollapsed = bodyWrap.classList.contains('collapsed');

			if (currentDock !== clickedSide) {
				// Instant side swap and show
				updateDock(clickedSide);
				toggleSidebar(true);
			} else {
				// Toggle fade in/out
				toggleSidebar(isCollapsed);
			}
		}
		function toggleSidebar(show) {
			const bodyWrap = document.getElementById('body-wrap');
			bodyWrap.classList.toggle('collapsed', !show);
		}
		function updateDock(side) {
			currentDock = side;
			// Add/Remove class to handle the layout direction
			document.body.classList.toggle('dock-left', side === 'left');


			// Save preference
			localStorage.setItem('gallery_dock', side);
		}
		function handleLinkAction(e) { e.preventDefault(); const filtered = Array.from(activeTags).filter(t => !t.match(/^\[.*\]$/)); navigator.clipboard.writeText((document.getElementById('user-note').value + " " + filtered.join(' ')).trim()); const btn = document.getElementById('add-btn'); btn.innerText = '✓'; setTimeout(() => btn.innerText = '+', 1000); }


		function toggleFocus(card) { cycleViewMode(); setTimeout(() => { card.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' }); }, 150); }
		function handleMissingImage(img, path) { const card = img.closest('.card'); DATA = DATA.filter(i => i.p !== path); card.remove(); refreshAllUI(); }
		function toggleTag(t) { if (activeTags.has(t)) activeTags.delete(t); else activeTags.add(t); refreshAllUI(); }
		function saveNotes(v) { localStorage.setItem('gallery_notes', v); }

		function toggleStageTools() {
			const s = document.getElementById('stage-tools');
			// Check for empty string (initial state)
			s.style.display = (s.style.display === 'none' || s.style.display === '') ? 'flex' : 'none';
		}
		function toggleCollections() {
			const c = document.getElementById('collapsible-collections');
			c.style.display = (c.style.display === 'none' || c.style.display === '') ? 'flex' : 'none';
		}
		function toggleTagCloud() {
			const h = document.getElementById('collapsible-tags');
			h.style.display = (h.style.display === 'none') ? 'block' : 'none';
		}
		function cycleViewMode() {
			const bodyWrap = document.getElementById('body-wrap');
			const btn = document.getElementById('mode-toggle');
			const isMax = bodyWrap.classList.toggle('max-width');

			localStorage.setItem('gallery_is_max_width', isMax);

			// Set character based on current mode
			// icon-v is used for Max Height mode, icon-h for Max Width mode
			btn.innerHTML = isMax ? '<div class="icon-v"></div>' : '<div class="icon-h"></div>';
			// Trigger highlight update immediately after switching modes
			setTimeout(updateCenteredCard, 100);
		}

		function toggleSidebarView() {
			sidebarIsGrid = !sidebarIsGrid;
			const icon = document.getElementById('toggle-icon');
			const container = document.getElementById('grid-slider-container'); // Get the slider container

			if (sidebarIsGrid) {
				icon.className = 'css-list';
				icon.innerHTML = '<div></div><div></div><div></div>';
				if (container) container.style.display = 'flex'; // Show slider
			} else {
				icon.className = 'css-grid';
				icon.innerHTML = '<div></div><div></div><div></div><div></div>';
				if (container) container.style.display = 'none'; // Hide slider
			}

			refreshAllUI();
		}
		function updateGridCols(v) {
			document.documentElement.style.setProperty('--grid-cols', v);
			// document.getElementById('col-val').innerText = v; // REMOVE OR COMMENT OUT THIS LINE
			localStorage.setItem('gallery_cols', v);
		}

		document.getElementById('main').addEventListener('wheel', (e) => {
			if (!document.getElementById('body-wrap').classList.contains('max-width')) {
				e.preventDefault();
				// Standardize: deltaY always moves scrollLeft forward
				document.getElementById('main').scrollLeft += e.deltaY;
			}
		});
		// Click outside to hide sidebar
		// Refined Click-to-Hide Logic
		document.addEventListener('mousedown', (e) => {
			const sidebar = document.getElementById('sidebar');
			const bodyWrap = document.getElementById('body-wrap');
			const isSidebarOpen = !bodyWrap.classList.contains('collapsed');

			// If sidebar is closed, do nothing
			if (!isSidebarOpen) return;

			// Check if the click was on the main background or an image, but NOT a button
			const clickedMain = document.getElementById('main').contains(e.target);

			const clickedButton =
				e.target.closest('.tool-btn') ||
				e.target.closest('.sq-btn') ||
				e.target.closest('.card-tag-overlay') ||
				e.target.closest('.tag-btn'); // Assuming your tags have this class

			// Hide only if clicking main area/image AND not clicking a functional button
			if (clickedMain && !clickedButton) {
				toggleSidebar(false);
			}
		});
		// Add this to your initialization logic
		document.getElementById('main').addEventListener('scroll', updateCenteredCard);

		// Also run it once on load to highlight the first card
		window.addEventListener('load', updateCenteredCard);
	</script>


</body>

</html>